This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-12T13:11:56.179Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
.vite/deps/_metadata.json
.vite/deps/package.json
api.js
api/_supabase.js
api/conversations/[id]/index.js
api/conversations/[id]/participants/[userId].js
api/conversations/index.js
api/device/[deviceId].js
api/device/register.js
api/index.js
api/signal/bundles/[userId].js
components.json
eslint.config.js
index.html
lib/cors.js
package.json
public/vite.svg
README.md
src/App.jsx
src/assets/react.svg
src/components/NewChatModal.jsx
src/components/NewGroupModal.jsx
src/components/ui/alert.tsx
src/components/ui/avatar.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dialog.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/sheet.tsx
src/components/ui/slider.tsx
src/components/ui/switch.tsx
src/components/ui/tabs.tsx
src/hooks/use-mobile.js
src/index.css
src/lib/backend.js
src/lib/db.js
src/lib/localDb.js
src/lib/signalContext.jsx
src/lib/signalCrypto.js
src/lib/signalUtils.js
src/lib/supabaseClient.js
src/lib/utils.ts
src/main.jsx
src/pages/AboutPage.jsx
src/pages/ChatPage.jsx
src/pages/CryptoTestPage.jsx
src/pages/ForgotPasswordPage.jsx
src/pages/HomePage.jsx
src/pages/LoginPage.jsx
src/pages/nehahelp.jsx
src/pages/ProfilePage.jsx
src/pages/SettingsPage.jsx
src/pages/SignupPage.jsx
tsconfig.app.json
tsconfig.json
vite.config.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

/frontend/.env
.env

.cursor

repomix-output.txt
.vercel

================
File: .vite/deps/_metadata.json
================
{
  "hash": "f9adf7a4",
  "configHash": "e6e6f40b",
  "lockfileHash": "1a8da3de",
  "browserHash": "2a038793",
  "optimized": {},
  "chunks": {}
}

================
File: .vite/deps/package.json
================
{
  "type": "module"
}

================
File: api.js
================
// api.js -----------------------------------------------------------
const API = "http://localhost:3001";

async function post(path, payload) {
  const res = await fetch(`${API}${path}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const text = await res.text(); // easier to read error
    throw new Error(`HTTP ${res.status}: ${text}`);
  }
  return res.json();
}

// exported high-level helpers
export const api = {
  genKeys: (user_id) => post("/api/keys/generate", { user_id }),
  initSess: (sender_id, recipient_id) =>
    post("/api/sessions/initiate", { sender_id, recipient_id }),
  encrypt: (sender_id, recipient_id, plaintext) =>
    post("/api/messages/encrypt", { sender_id, recipient_id, plaintext }),
  decrypt: (recipient_id, sender_id, header_b64, ciphertext_b64) =>
    post("/api/messages/decrypt", {
      recipient_id,
      sender_id,
      header_b64,
      ciphertext_b64,
    }),
};

================
File: api/_supabase.js
================
// api/_supabase.js
import { createClient } from "@supabase/supabase-js";
import "dotenv/config";

// these **must** be set in your Vercel Environment Variables
const URL = process.env.SUPABASE_URL;
const KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
if (!URL || !KEY) {
  throw new Error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY env vars");
}

export const supabaseAdmin = createClient(URL, KEY);

================
File: api/conversations/[id]/index.js
================
import { supabaseAdmin } from "../../_supabase";

export default async function handler(req, res) {
  const { id } = req.query;
  if (req.method === "PATCH") {
    const { groupName, groupAvatarUrl } = req.body;
    const updates = {};
    if (groupName !== undefined) updates.group_name = groupName;
    if (groupAvatarUrl !== undefined) updates.group_avatar_url = groupAvatarUrl;
    if (Object.keys(updates).length === 0) {
      return res.status(400).json({ error: "No fields to update" });
    }

    const { data, error } = await supabaseAdmin
      .from("conversations")
      .update(updates)
      .eq("id", id)
      .eq("is_group", true)
      .select()
      .single();

    if (error) return res.status(500).json({ error: error.message });
    if (!data) return res.status(404).json({ error: "Group not found" });

    return res.status(200).json({ conversation: data });
  }

  res.setHeader("Allow", "PATCH");
  return res.status(405).json({ error: "Method not allowed" });
}

================
File: api/conversations/[id]/participants/[userId].js
================
import { supabaseAdmin } from "../../../../_supabase";

export default async function handler(req, res) {
  const { id, userId } = req.query;
  if (req.method !== "DELETE") {
    res.setHeader("Allow", "DELETE");
    return res.status(405).json({ error: "Method not allowed" });
  }

  // 1️⃣ Remove the participant
  const { error: delErr } = await supabaseAdmin
    .from("conversation_participants")
    .delete()
    .match({ conversation_id: id, profile_id: userId });
  if (delErr) {
    console.error("Error deleting participant:", delErr);
    return res.status(500).json({ error: delErr.message });
  }

  // 2️⃣ Check remaining participants
  const { data: remaining, error: fetchErr } = await supabaseAdmin
    .from("conversation_participants")
    .select("profile_id")
    .eq("conversation_id", id);
  if (fetchErr) {
    console.error("Error fetching participants:", fetchErr);
    return res.status(500).json({ error: fetchErr.message });
  }

  // 3️⃣ If none left, delete the conversation
  if (!remaining || remaining.length === 0) {
    const { error: convDelErr } = await supabaseAdmin
      .from("conversations")
      .delete()
      .eq("id", id);
    if (convDelErr) {
      console.error("Error deleting empty conversation:", convDelErr);
      // we still return 204 even if cleanup fails
    }
  }

  return res.status(204).end();
}

================
File: api/conversations/index.js
================
import { supabaseAdmin } from "../_supabase";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    res.setHeader("Allow", "POST");
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { groupName, groupAvatarUrl, participantIds } = req.body;
  if (!Array.isArray(participantIds) || participantIds.length < 2) {
    return res
      .status(400)
      .json({
        error: "participantIds must be an array of at least 2 user IDs",
      });
  }

  // 1️⃣ Create the conversation row
  const { data: conv, error: convErr } = await supabaseAdmin
    .from("conversations")
    .insert({
      is_group: true,
      group_name: groupName || null,
      group_avatar_url: groupAvatarUrl || null,
    })
    .select()
    .single();

  if (convErr) {
    console.error("Error creating conversation:", convErr);
    return res.status(500).json({ error: convErr.message });
  }

  // 2️⃣ Add participants
  const rows = participantIds.map((pid) => ({
    conversation_id: conv.id,
    profile_id: pid,
  }));
  const { error: partErr } = await supabaseAdmin
    .from("conversation_participants")
    .insert(rows);

  if (partErr) {
    console.error("Error inserting participants:", partErr);
    return res.status(500).json({ error: partErr.message });
  }

  return res.status(201).json({ conversationId: conv.id });
}

================
File: api/device/[deviceId].js
================
// api/device/[deviceId].js
import { supabaseAdmin } from "../_supabase.js";
import { cors } from "../../lib/cors.js";

export default cors(async function handler(req, res) {
  const { deviceId } = req.query;

  if (req.method !== "DELETE") {
    res.setHeader("Allow", "DELETE");
    return res.status(405).end();
  }

  try {
    // delete bundle first
    let { error: bundleErr } = await supabaseAdmin
      .from("bundles")
      .delete()
      .eq("device_id", deviceId);

    if (bundleErr) throw bundleErr;

    // delete device
    const { error: devErr } = await supabaseAdmin
      .from("devices")
      .delete()
      .eq("device_id", deviceId);

    if (devErr) throw devErr;

    return res.status(204).end();
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: err.message });
  }
});

================
File: api/device/register.js
================
// api/device/register.js
import { supabaseAdmin } from "../_supabase.js";
import { cors } from "../../lib/cors.js";

export default cors(async function handler(req, res) {
  if (req.method !== "POST") {
    res.setHeader("Allow", "POST");
    return res.status(405).end();
  }

  const {
    userId,
    registrationId,
    identityKey,
    signedPreKeyId,
    signedPreKeyPublicKey,
    signedPreKeySignature,
    preKeyId,
    preKeyPublicKey,
  } = req.body;

  try {
    // 1️⃣ Create device row
    const { data: deviceData, error: deviceError } = await supabaseAdmin
      .from("devices")
      .insert({ user_id: userId })
      .select("device_id")
      .single();

    if (deviceError || !deviceData) {
      console.error("Error inserting device:", deviceError);
      throw new Error("Device registration failed");
    }
    const deviceId = deviceData.device_id;

    // 2️⃣ Upsert bundle
    const { error: upsertError } = await supabaseAdmin.from("bundles").upsert(
      {
        device_id: deviceId,
        registration_id: registrationId,
        identity_key_b64: identityKey,
        signed_pre_key_id: signedPreKeyId,
        signed_pre_key_public_b64: signedPreKeyPublicKey,
        signed_pre_key_sig_b64: signedPreKeySignature,
        pre_key_id: preKeyId,
        pre_key_public_b64: preKeyPublicKey,
      },
      { onConflict: "device_id" }
    );

    if (upsertError) {
      console.error("Error upserting bundle:", upsertError);
      throw new Error("Bundle upsert failed");
    }

    return res.status(200).json({ deviceId });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: err.message });
  }
});

================
File: api/index.js
================
// api/index.js
import { cors } from "../lib/cors.js";

async function handler(req, res) {
  res.status(200).json({ message: "Secure Chat Backend (JS)" });
}

export default cors(handler);

================
File: api/signal/bundles/[userId].js
================
// api/signal/bundles/[userId].js
import { supabaseAdmin } from "../../_supabase.js";
import { cors } from "../../../lib/cors.js";

export default cors(async function handler(req, res) {
  const { userId } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", "GET");
    return res.status(405).end();
  }

  try {
    // fetch devices
    const { data: devices, error: devErr } = await supabaseAdmin
      .from("devices")
      .select("device_id")
      .eq("user_id", userId);

    if (devErr) throw devErr;

    const deviceIds = devices.map((d) => d.device_id);
    if (deviceIds.length === 0) {
      return res.status(200).json([]);
    }

    // fetch bundles
    const { data: bundles, error: bundleErr } = await supabaseAdmin
      .from("bundles")
      .select(
        `
        device_id,
        registration_id,
        identity_key_b64,
        signed_pre_key_id,
        signed_pre_key_public_b64,
        signed_pre_key_sig_b64,
        pre_key_id,
        pre_key_public_b64
      `
      )
      .in("device_id", deviceIds);

    if (bundleErr) throw bundleErr;

    // shape response
    const response = bundles.map((b) => ({
      deviceId: b.device_id,
      registrationId: b.registration_id,
      identityKey: b.identity_key_b64,
      signedPreKeyId: b.signed_pre_key_id,
      signedPreKeyPublicKey: b.signed_pre_key_public_b64,
      signedPreKeySignature: b.signed_pre_key_sig_b64,
      preKeyId: b.pre_key_id,
      preKeyPublicKey: b.pre_key_public_b64,
    }));

    return res.status(200).json(response);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: err.message });
  }
});

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: lib/cors.js
================
// lib/cors.js
import Cors from "micro-cors";

export const cors = Cors({
  allowMethods: ["GET", "POST", "DELETE", "OPTIONS"],
  allowHeaders: ["Content-Type", "Authorization"],
  origin: ["http://localhost:5173", "https://dds-secure-chat-web.vercel.app"],
});

================
File: package.json
================
{
  "name": "secure_chat_ruc",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@privacyresearch/libsignal-protocol-typescript": "^0.0.16",
    "@radix-ui/react-avatar": "^1.1.7",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-dialog": "^1.1.11",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-scroll-area": "^1.2.6",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-slider": "^1.3.2",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.2.2",
    "@radix-ui/react-tabs": "^1.1.9",
    "@signalapp/libsignal-client": "^0.70.1",
    "@supabase/supabase-js": "^2.49.4",
    "@tailwindcss/vite": "^4.1.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dexie": "^4.0.11",
    "dotenv": "^16.5.0",
    "emoji-picker-react": "^4.12.2",
    "framer-motion": "^12.9.1",
    "from": "^0.1.7",
    "idb-keyval": "^6.2.1",
    "import": "^0.0.6",
    "lucide-react": "^0.503.0",
    "micro-cors": "^0.1.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.5.2",
    "signal": "^7.0.6",
    "tailwind-merge": "^3.2.0",
    "tailwindcss": "^4.1.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@types/node": "^22.14.1",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "tw-animate-css": "^1.2.8",
    "vite": "^6.3.1"
  }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

================
File: src/App.jsx
================
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { useState, useEffect } from "react";
import "./index.css";
import HomePage from "./pages/HomePage"; // Import the HomePage
import SignupPage from "./pages/SignupPage"; // Import the SignupPage
import SettingsPage from "./pages/SettingsPage"; // Import the SettingsPage
import ProfilePage from "./pages/ProfilePage"; // Import the ProfilePage
import LoginPage from "./pages/LoginPage"; // Import the LoginPage
import ForgotPasswordPage from "./pages/ForgotPasswordPage"; // Import the ForgotPasswordPage
import ChatPage from "./pages/ChatPage"; // Import the ChatPage
import CryptoTestPage from "./pages/CryptoTestPage"; // Import the CryptoTestPage
import AboutPage from "./pages/AboutPage"; // Import the AboutPage
import { supabase } from "./lib/supabaseClient"; // Assuming client is exported as supabase
import { SignalProvider } from "./lib/signalContext";

function App() {
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setLoading(false);
    });

    // Listen for auth state changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
    });

    // Cleanup subscription on unmount
    return () => subscription.unsubscribe();
  }, []);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-white">
        Loading Session...
      </div>
    );
  }

  return (
    <SignalProvider userId={session?.user?.id}>
      <Router>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/crypto-test" element={<CryptoTestPage />} />
          {/* <Route path="/signup" element={<SignupPage />} /> No need for signup if logged in */}
          <Route path="/settings" element={<SettingsPage />} />
          <Route path="/profile" element={<ProfilePage />} />
          {/* <Route path="/login" element={<LoginPage />} /> No need for login if logged in */}
          {/* <Route path="/forgot-password" element={<ForgotPasswordPage />} /> No need if logged in */}
          <Route path="/chat" element={<ChatPage />} />
          <Route path="/signup" element={<SignupPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/about" element={<AboutPage />} />
        </Routes>
      </Router>
    </SignalProvider>
  );
}

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/NewChatModal.jsx
================
import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { supabase } from "../lib/supabaseClient";
import { Button } from "./ui/button";

export default function NewChatModal({ currentUser, onUserSelect }) {
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const handler = setTimeout(() => {
      if (searchQuery.trim().length > 1) {
        performSearch();
      } else {
        setSearchResults([]);
      }
    }, 500);

    return () => {
      clearTimeout(handler);
    };
  }, [searchQuery, currentUser]);

  const performSearch = async () => {
    if (!currentUser || !searchQuery.trim()) return;

    setLoading(true);
    setError(null);
    try {
      const searchTerm = `%${searchQuery.trim()}%`;
      const { data, error: searchError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url")
        .or(`username.ilike.${searchTerm},full_name.ilike.${searchTerm}`)
        .neq("id", currentUser.id)
        .limit(10);

      if (searchError) throw searchError;

      setSearchResults(data || []);
    } catch (err) {
      console.error("Error searching users:", err);
      setError("Failed to search users.");
      setSearchResults([]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <DialogContent className="bg-slate-800 border-slate-700 text-white sm:max-w-[425px]">
      <DialogHeader>
        <DialogTitle>Start New Chat</DialogTitle>
        <DialogDescription>
          Search for users by username or full name.
        </DialogDescription>
      </DialogHeader>
      <div className="p-0">
        <Input
          placeholder="Search users..."
          className="mb-4 bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
        />
        <ScrollArea className="h-[300px]">
          {loading && (
            <p className="text-center text-slate-400">Searching...</p>
          )}
          {error && <p className="text-center text-red-400">{error}</p>}
          {!loading &&
            searchResults.length === 0 &&
            searchQuery.trim().length > 1 && (
              <p className="text-center text-slate-400">No users found.</p>
            )}
          {!loading &&
            searchResults.map((user) => (
              <div
                key={user.id}
                className="flex items-center gap-3 p-2 mb-1 rounded-md hover:bg-slate-700 cursor-pointer"
                onClick={() => onUserSelect(user)}
              >
                <Avatar className="h-9 w-9">
                  <AvatarImage
                    src={user.avatar_url || "/placeholder.svg"}
                    alt={user.username}
                  />
                  <AvatarFallback className="bg-emerald-600">
                    {(user.full_name || user.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")
                      .toUpperCase()}
                  </AvatarFallback>
                </Avatar>
                <div className="flex-1 min-w-0">
                  <p className="font-medium truncate">
                    {user.full_name || user.username}
                  </p>
                  {user.full_name && user.username && (
                    <p className="text-sm text-slate-400 truncate">
                      @{user.username}
                    </p>
                  )}
                </div>
              </div>
            ))}
        </ScrollArea>
      </div>
    </DialogContent>
  );
}

================
File: src/components/NewGroupModal.jsx
================
import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Checkbox } from "@/components/ui/checkbox";
import {
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { supabase } from "../lib/supabaseClient";
import { Button } from "./ui/button";

export default function NewGroupModal({
  allUsers,
  currentUser,
  onCreate,
  onOpenChange,
}) {
  const [groupName, setGroupName] = useState("");
  const [selectedUserIds, setSelectedUserIds] = useState(new Set());
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [loadingSearch, setLoadingSearch] = useState(false);
  const [searchError, setSearchError] = useState(null);

  useEffect(() => {
    if (allUsers && currentUser) {
      setSearchResults(allUsers.filter((u) => u.id !== currentUser.id));
    }
  }, [allUsers, currentUser]);

  useEffect(() => {
    const handler = setTimeout(() => {
      if (searchQuery.trim().length > 0) {
        performSearch();
      } else if (allUsers && currentUser) {
        setSearchResults(allUsers.filter((u) => u.id !== currentUser.id));
        setSearchError(null);
      } else {
        setSearchResults([]);
      }
    }, 300);

    return () => {
      clearTimeout(handler);
    };
  }, [searchQuery, currentUser, allUsers]);

  const performSearch = async () => {
    if (!currentUser || !searchQuery.trim()) {
      return;
    }

    setLoadingSearch(true);
    setSearchError(null);
    try {
      const searchTerm = `%${searchQuery.trim()}%`;
      const { data, error: dbSearchError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url")
        .or(`username.ilike.${searchTerm},full_name.ilike.${searchTerm}`)
        .neq("id", currentUser.id)
        .limit(20);

      if (dbSearchError) throw dbSearchError;

      setSearchResults(data || []);
    } catch (err) {
      console.error("Error searching users for group:", err);
      setSearchError("Failed to search users.");
      setSearchResults([]);
    } finally {
      setLoadingSearch(false);
    }
  };

  const toggleUserSelection = (userId) => {
    setSelectedUserIds((prevSelected) => {
      const next = new Set(prevSelected);
      if (next.has(userId)) {
        next.delete(userId);
      } else {
        next.add(userId);
      }
      return next;
    });
  };

  const handleCreateGroup = () => {
    if (!groupName.trim() || selectedUserIds.size === 0) {
      alert("Please enter a group name and select at least one member.");
      return;
    }
    onCreate({
      name: groupName.trim(),
      memberIds: Array.from(selectedUserIds),
    });
    if (onOpenChange) {
      onOpenChange(false);
    }
  };

  return (
    <DialogContent className="bg-slate-800 border-slate-700 text-white sm:max-w-md">
      <DialogHeader>
        <DialogTitle>Create New Group</DialogTitle>
        <DialogDescription>
          Select members and give your group a name.
        </DialogDescription>
      </DialogHeader>
      <div className="space-y-4">
        <Input
          placeholder="Group name"
          className="bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
          value={groupName}
          onChange={(e) => setGroupName(e.target.value)}
        />
        <Input
          placeholder="Search users to add..."
          className="bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
        />
        <ScrollArea className="h-[250px] border border-slate-700 rounded-md p-2">
          {loadingSearch && (
            <p className="text-center text-slate-400">Searching...</p>
          )}
          {searchError && (
            <p className="text-center text-red-400">{searchError}</p>
          )}
          {!loadingSearch &&
            searchResults.length === 0 &&
            searchQuery.trim().length > 0 && (
              <p className="text-center text-slate-400">
                No users found matching your search.
              </p>
            )}
          {!loadingSearch &&
            searchResults.length === 0 &&
            searchQuery.trim().length === 0 &&
            allUsers &&
            allUsers.length <= 1 && (
              <p className="text-center text-slate-400">
                No other users available to create a group.
              </p>
            )}
          {!loadingSearch &&
            searchResults.map((user) => (
              <label
                key={user.id}
                className="flex items-center gap-3 p-2 mb-1 rounded-md hover:bg-slate-700 cursor-pointer"
                htmlFor={`user-${user.id}`}
              >
                <Checkbox
                  id={`user-${user.id}`}
                  checked={selectedUserIds.has(user.id)}
                  onCheckedChange={() => toggleUserSelection(user.id)}
                  className="border-slate-500 data-[state=checked]:bg-emerald-500 data-[state=checked]:text-white"
                />
                <Avatar className="h-9 w-9">
                  <AvatarImage
                    src={user.avatar_url || "/placeholder.svg"}
                    alt={user.username}
                  />
                  <AvatarFallback className="bg-emerald-600">
                    {(user.full_name || user.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")
                      .toUpperCase()}
                  </AvatarFallback>
                </Avatar>
                <div className="flex-1 min-w-0">
                  <p className="font-medium truncate">
                    {user.full_name || user.username}
                  </p>
                  {user.full_name && user.username && (
                    <p className="text-sm text-slate-400 truncate">
                      @{user.username}
                    </p>
                  )}
                </div>
              </label>
            ))}
        </ScrollArea>
        <Button
          className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
          onClick={handleCreateGroup}
          disabled={
            !groupName.trim() || selectedUserIds.size === 0 || loadingSearch
          }
        >
          Create Group
        </Button>
      </div>
    </DialogContent>
  );
}

================
File: src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

================
File: src/components/ui/avatar.tsx
================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

================
File: src/components/ui/checkbox.tsx
================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }

================
File: src/components/ui/dialog.tsx
================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

================
File: src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: src/components/ui/label.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: src/components/ui/scroll-area.tsx
================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

================
File: src/components/ui/select.tsx
================
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

================
File: src/components/ui/sheet.tsx
================
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: src/components/ui/slider.tsx
================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }

================
File: src/components/ui/switch.tsx
================
import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }

================
File: src/components/ui/tabs.tsx
================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: src/hooks/use-mobile.js
================
import { useState, useEffect } from "react";

export const useMobile = () => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth < 768); // Adjust breakpoint as needed
    };

    // Set initial value
    handleResize();

    // Listen for window resize events
    window.addEventListener("resize", handleResize);

    // Clean up event listener on unmount
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  return isMobile;
};

================
File: src/index.css
================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/lib/backend.js
================
// src/lib/backend.js

// e.g. VITE_BACKEND_URL = "https://dds-secure-chat-web.vercel.app/api"
const API = import.meta.env.VITE_BACKEND_URL;

// helper to avoid double-slashes or duplicate "/api"
function buildUrl(path) {
  // remove trailing slash from API, if any
  const base = API.replace(/\/+$/, "");
  // ensure path starts with a single slash
  const suffix = path.startsWith("/") ? path : `/${path}`;
  return `${base}${suffix}`;
}

/** POST helper that automatically JSON-encodes the body */
export async function post(path, payload) {
  const url = buildUrl(path);
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    let msg = `HTTP ${res.status}`;
    try {
      const errorData = await res.json();
      if (errorData?.message) msg += `: ${errorData.message}`;
    } catch {
      /* ignore JSON parse errors */
    }
    throw new Error(msg);
  }
  return res.json();
}

/** GET helper */
export async function get(path) {
  const url = buildUrl(path);
  const res = await fetch(url);
  if (!res.ok) {
    let msg = `HTTP ${res.status}`;
    if (res.status === 404) {
      msg = `Not found: ${path}`;
      try {
        const { detail } = await res.json();
        if (detail) msg += `: ${detail}`;
      } catch {}
    } else {
      try {
        const err = await res.json();
        if (err?.detail) msg += `: ${err.detail}`;
        else if (err?.message) msg += `: ${err.message}`;
      } catch {}
    }
    throw new Error(msg);
  }
  return res.json();
}

================
File: src/lib/db.js
================
// src/lib/db.js
import Dexie from "dexie";

// --- Namespacing Dexie Instances --- START ---
// Cache Dexie instances per userId
const dexieInstances = new Map();

/**
 * Gets a Dexie instance for the specific user.
 * @param {string} userId
 * @returns {Dexie}
 */
function getCacheDb(userId) {
  if (!userId) {
    throw new Error("[getCacheDb] userId is required.");
  }

  if (!dexieInstances.has(userId)) {
    const dbName = `SecureChatDB_${userId}`; // Use the same naming convention
    console.log(`[Dexie Cache] Creating/Getting instance for DB: ${dbName}`);
    const db = new Dexie(dbName);

    // Define the schema (make sure this matches the latest version needed)
    db.version(2).stores({
      messages: "id, conversationId, timestamp, content",
    });
    // Add migration logic if needed for future versions

    // You might need error handling for Dexie opening itself, though less common than raw IDB
    // db.open().catch(err => {
    //   console.error(`Failed to open Dexie DB ${dbName}:`, err);
    //   dexieInstances.delete(userId); // Remove instance if open fails
    // });

    dexieInstances.set(userId, db);
  }

  return dexieInstances.get(userId);
}
// --- Namespacing Dexie Instances --- END ---

// Example usage (can add helper functions here later if needed)
// export async function addMessage(message) {
//   await db.messages.put(message); // put handles add or update
// }

// export async function getMessagesForConversation(conversationId) {
//   return await db.messages
//     .where('conversationId')
//     .equals(conversationId)
//     .sortBy('timestamp');
// }

// Helper function to add/update message with plaintext
// Now requires userId to get the correct DB instance
export async function cacheSentMessage(userId, message) {
  if (!userId) throw new Error("cacheSentMessage requires userId.");
  const db = getCacheDb(userId);
  console.log(
    `[Dexie Cache] Caching sent message ${message.id} for user ${userId}:`,
    message.content
  );
  try {
    const putKey = await db.messages.put(message);
    console.log(
      `[Dexie Cache] Successfully put message ${message.id} for user ${userId} with key:`,
      putKey
    );
  } catch (error) {
    console.error(
      `[Dexie Cache] Error putting message ${message.id} for user ${userId}:`,
      error
    );
  }
}

// Helper function to get cached message plaintext
// Now requires userId
export async function getCachedMessageContent(userId, messageId) {
  if (!userId) throw new Error("getCachedMessageContent requires userId.");
  const db = getCacheDb(userId);
  const cachedMsg = await db.messages.get(messageId);
  console.log(
    `[Dexie Cache] Cache lookup for ${messageId} (User: ${userId}): ${
      cachedMsg ? "Found" : "Not Found"
    }`
  );
  return cachedMsg?.content;
}

// REMOVED: Old export
// export const db = new Dexie("secureChatDatabase");

// NEW: Export the necessary functions
export { getCacheDb };

================
File: src/lib/localDb.js
================
// import * as signal from "@privacyresearch/libsignal-protocol-typescript"; // REMOVED: No longer needed here

const DB_NAME = "SecureChatDB"; // Base name, not used directly anymore
const DB_VERSION = 1;
const KEY_STORE_NAME = "signalKeys";
const SESSION_STORE_NAME = "signalSessions";
// Add other stores as needed by the SignalProtocolStore interface
const PREKEY_STORE_NAME = "signalPreKeys";
const SIGNED_PREKEY_STORE_NAME = "signalSignedPreKeys";
const IDENTITY_STORE_NAME = "signalIdentity";

// --- Namespace DB Connections --- START ---
// Use a Map to store DB connection promises, keyed by userId
const dbPromiseMap = new Map();

function getDb(userId) {
  if (!userId) {
    return Promise.reject(new Error("getDb requires a userId"));
  }

  if (!dbPromiseMap.has(userId)) {
    const userDbName = `SecureChatDB_${userId}`;
    console.log(`[localDb] Creating/Opening DB promise for: ${userDbName}`);

    const promise = new Promise((resolve, reject) => {
      console.log(`Opening IndexedDB: ${userDbName} version ${DB_VERSION}`);
      const request = indexedDB.open(userDbName, DB_VERSION);

      request.onerror = (event) => {
        console.error("IndexedDB error:", event.target.error);
        reject(`IndexedDB error: ${event.target.error}`);
        dbPromiseMap.delete(userId); // Remove promise on error
      };

      request.onsuccess = (event) => {
        console.log("IndexedDB opened successfully.");
        const db = event.target.result; // Get the DB instance

        // --- Add event listeners to the DB connection itself --- START ---
        db.onclose = () => {
          console.warn("IndexedDB connection closed unexpectedly.");
          dbPromiseMap.delete(userId); // Remove promise so it reopens
        };
        db.onerror = (event) => {
          // Log errors that occur on the connection after it's opened
          console.error(
            "Unhandled IndexedDB database error:",
            event.target.error
          );
          // Optionally close and reset
          dbPromiseMap.delete(userId);
        };
        db.onversionchange = () => {
          // Handle requests to upgrade the DB from other tabs/windows
          console.warn(
            "IndexedDB version change requested. Closing old connection..."
          );
          db.close(); // Close the current connection to allow the upgrade
          dbPromiseMap.delete(userId); // Reset promise
        };
        // --- Add event listeners to the DB connection itself --- END ---

        // Resolve the promise with the db instance
        resolve(db);
      }; // End of request.onsuccess

      // Assign onupgradeneeded directly to the request
      request.onupgradeneeded = (event) => {
        console.log("IndexedDB upgrade needed.");
        const db = event.target.result;
        if (!db.objectStoreNames.contains(KEY_STORE_NAME)) {
          console.log(`Creating object store: ${KEY_STORE_NAME}`);
          db.createObjectStore(KEY_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(SESSION_STORE_NAME)) {
          console.log(`Creating object store: ${SESSION_STORE_NAME}`);
          db.createObjectStore(SESSION_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(PREKEY_STORE_NAME)) {
          console.log(`Creating object store: ${PREKEY_STORE_NAME}`);
          db.createObjectStore(PREKEY_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(SIGNED_PREKEY_STORE_NAME)) {
          console.log(`Creating object store: ${SIGNED_PREKEY_STORE_NAME}`);
          db.createObjectStore(SIGNED_PREKEY_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(IDENTITY_STORE_NAME)) {
          console.log(`Creating object store: ${IDENTITY_STORE_NAME}`);
          db.createObjectStore(IDENTITY_STORE_NAME);
        }
        console.log("IndexedDB upgrade complete.");
      };
    }); // End of new Promise
    dbPromiseMap.set(userId, promise);
  }
  return dbPromiseMap.get(userId);
}
// --- Namespace DB Connections --- END ---

// --- Helper function to perform DB operations ---
async function performDbOperation(userId, storeName, mode, operation) {
  if (!userId) throw new Error("performDbOperation requires userId");
  const db = await getDb(userId); // Pass userId here
  return new Promise((resolve, reject) => {
    let requestResult = undefined; // Variable to store result from request.onsuccess

    // --- Wrap transaction creation in try-catch --- START ---
    try {
      const transaction = db.transaction(storeName, mode);
      const store = transaction.objectStore(storeName);

      // Add logging for transaction aborts
      transaction.onabort = (event) => {
        console.error(
          `IndexedDB transaction ABORTED on ${storeName} (Mode: ${mode}):`,
          event.target.error
        );
        reject(
          event.target.error || new Error(`Transaction aborted on ${storeName}`)
        );
      };

      const request = operation(store);

      request.onsuccess = (event) => {
        // Store the result for read operations or if needed
        requestResult = event.target.result;
        // For read operations, we could resolve here, but waiting for
        // transaction complete is safer even for reads if subsequent
        // operations depend on this read finishing *within its transaction*.
        // Let's simplify and always resolve on transaction complete/error.
      };
      request.onerror = (event) => {
        console.error(
          `IndexedDB request error on ${storeName} (Mode: ${mode}):`,
          event.target.error
        );
        // Don't reject here, let transaction.onerror handle it to ensure
        // the transaction error bubbles up properly.
      };

      transaction.oncomplete = () => {
        // Transaction succeeded, resolve with the stored result
        console.debug(
          `IndexedDB transaction complete on ${storeName}. Mode: ${mode}.`
        );
        resolve(requestResult);
      };
      transaction.onerror = (event) => {
        console.error(
          `IndexedDB transaction error on ${storeName} (Mode: ${mode}):`,
          event.target.error
        );
        reject(event.target.error); // Reject promise on transaction error
      };
    } catch (err) {
      console.error(
        `Error initiating transaction on ${storeName} (Mode: ${mode}):`,
        err
      );
      // Check if the error is the specific connection closing error
      if (err instanceof DOMException && err.name === "InvalidStateError") {
        console.warn(
          "Database connection was closed when trying to start transaction. Resetting promise..."
        );
        // Reset dbPromise to force re-initialization on next call
        dbPromiseMap.delete(userId); // Pass userId here
        // Reject with a specific error message
        reject(
          new Error(
            "Database connection was closed. Please retry the operation."
          )
        );
      } else {
        reject(err); // Re-throw other errors
      }
    }
    // --- Wrap transaction creation in try-catch --- END ---
  });
}

// --- Base64 Helpers ---
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function base64ToArrayBuffer(base64) {
  const binary_string = atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }
  return bytes.buffer;
}

// --- Serialization Helpers using Base64 ---
function serializeBuffers(obj) {
  if (!obj) return obj;
  if (obj instanceof ArrayBuffer) {
    return {
      __type: "ArrayBuffer",
      // Use standard Base64 encoding
      data: arrayBufferToBase64(obj),
    };
  }
  if (typeof obj === "object") {
    const newObj = Array.isArray(obj) ? [] : {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = serializeBuffers(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
}

function deserializeBuffers(obj) {
  if (!obj) return obj;
  if (
    typeof obj === "object" &&
    obj.__type === "ArrayBuffer" &&
    typeof obj.data === "string"
  ) {
    // Use standard Base64 decoding
    return base64ToArrayBuffer(obj.data);
  }
  if (typeof obj === "object") {
    const newObj = Array.isArray(obj) ? [] : {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = deserializeBuffers(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
}

// --- SignalProtocolStore Implementation (Partial) ---

export class IndexedDBStore {
  /**
   * @param {string} userId The user ID for namespacing the database.
   */
  constructor(userId) {
    if (!userId) {
      throw new Error("IndexedDBStore requires a userId for namespacing.");
    }
    this.userId = userId;
    console.log(`[IndexedDBStore] Initialized for user: ${this.userId}`);
    // getDb(this.userId); // Don't necessarily need to trigger connection here
  }

  /**
   * Get the stored identity key pair.
   * @returns {Promise<import('@privacyresearch/libsignal-protocol-typescript').KeyPairType | undefined>}
   */
  async getIdentityKeyPair() {
    console.debug("[IndexedDBStore] getIdentityKeyPair called");
    const serialized = await performDbOperation(
      this.userId,
      IDENTITY_STORE_NAME,
      "readonly",
      (store) => store.get("identityKey") // Correct key name used before
    );
    const result = deserializeBuffers(serialized);
    console.debug(
      "[IndexedDBStore] getIdentityKeyPair result:",
      result ? `Found for ${this.userId}` : `Not Found for ${this.userId}`
    );
    return result;
  }

  /**
   * Get the local registration ID.
   * @returns {Promise<number | undefined>}
   */
  async getLocalRegistrationId() {
    console.debug("[IndexedDBStore] getLocalRegistrationId called");
    const regId = await performDbOperation(
      this.userId,
      KEY_STORE_NAME, // Stored in KEY_STORE before
      "readonly",
      (store) => store.get("registrationId")
    );
    console.debug(
      "[IndexedDBStore] getLocalRegistrationId result:",
      regId !== undefined
        ? `${regId} for ${this.userId}`
        : `Not Found for ${this.userId}`
    );
    return regId;
  }

  async isTrustedIdentity(identifier, identityKey /*, direction */) {
    console.debug(`[IndexedDBStore] isTrustedIdentity for ${identifier}`);
    const trusted = await this.loadIdentityKey(identifier);
    if (!trusted) {
      // If not trusted, save the new identity key.
      console.debug(
        `[IndexedDBStore] No trusted identity found for ${identifier}, saving new one.`
      );
      await this.saveIdentity(identifier, identityKey);
      return true; // Trust the newly saved identity
    }
    // Compare existing trusted key with the provided one.
    const trustedB64 = arrayBufferToBase64(trusted);
    const identityKeyB64 = arrayBufferToBase64(identityKey);
    const match = trustedB64 === identityKeyB64;
    console.debug(
      `[IndexedDBStore] Trusted identity comparison for ${identifier}: ${match}`
    );
    return match;
  }

  /**
   * Load a pre-key record.
   * @param {number} keyId
   * @returns {Promise<import('@privacyresearch/libsignal-protocol-typescript').KeyPairType | undefined>}
   */
  async loadPreKey(keyId) {
    console.debug(`[IndexedDBStore] loadPreKey called for keyId: ${keyId}`);
    const serialized = await performDbOperation(
      this.userId,
      PREKEY_STORE_NAME,
      "readonly",
      (store) => store.get(Number(keyId)) // Used Number(keyId) before
    );
    const result = deserializeBuffers(serialized);
    console.debug(
      `[IndexedDBStore] loadPreKey result for ${keyId}:`,
      result ? `Found for ${this.userId}` : `Not Found for ${this.userId}`
    );
    // Ensure the return type matches KeyPairType (pubKey: ArrayBuffer, privKey: ArrayBuffer)
    if (
      result &&
      result.pubKey instanceof ArrayBuffer &&
      result.privKey instanceof ArrayBuffer
    ) {
      return result;
    } else if (serialized) {
      console.warn(
        `[IndexedDBStore] Deserialized PreKey ${keyId} is not the expected KeyPairType:`,
        result
      );
      return undefined;
    }
    return undefined;
  }

  /**
   * Load a session record for the given identifier.
   * @param {string} identifier - The identifier of the session partner (e.g., recipientId.deviceId).
   * @returns {Promise<ArrayBuffer | undefined>} The session record ArrayBuffer, or undefined if not found.
   */
  async loadSession(identifier) {
    console.debug(`[IndexedDBStore] loadSession called for: ${identifier}`);
    const serialized = await performDbOperation(
      this.userId,
      SESSION_STORE_NAME,
      "readonly",
      (store) => store.get(identifier)
    );
    const sessionRecord = deserializeBuffers(serialized);
    console.debug(
      `[IndexedDBStore] loadSession result for ${identifier}:`,
      sessionRecord
        ? `Found (${
            sessionRecord instanceof ArrayBuffer
              ? sessionRecord.byteLength
              : typeof sessionRecord
          } bytes) for ${this.userId}`
        : `Not Found for ${this.userId}`
    );
    return sessionRecord instanceof ArrayBuffer ? sessionRecord : undefined;
  }

  /**
   * Load a signed pre-key record.
   * @param {number} keyId - The key ID of the signed pre-key.
   * @returns {Promise<import('@privacyresearch/libsignal-protocol-typescript').KeyPairType | undefined>}
   */
  async loadSignedPreKey(keyId) {
    console.debug(
      `[IndexedDBStore] loadSignedPreKey called for keyId: ${keyId}`
    );
    const serialized = await performDbOperation(
      this.userId,
      SIGNED_PREKEY_STORE_NAME,
      "readonly",
      (store) => store.get(Number(keyId)) // Used Number(keyId) before
    );
    const result = deserializeBuffers(serialized);
    console.debug(
      `[IndexedDBStore] loadSignedPreKey result for ${keyId}:`,
      result ? `Found for ${this.userId}` : `Not Found for ${this.userId}`
    );
    // Ensure the return type matches KeyPairType
    if (
      result &&
      result.pubKey instanceof ArrayBuffer &&
      result.privKey instanceof ArrayBuffer
    ) {
      return result;
    } else if (serialized) {
      console.warn(
        `[IndexedDBStore] Deserialized SignedPreKey ${keyId} is not the expected KeyPairType:`,
        result
      );
      return undefined;
    }
    return undefined;
  }

  /**
   * Load the public identity key for the given identifier.
   * @param {string} identifier - The identifier of the remote user (e.g., recipientId.deviceId).
   * @returns {Promise<ArrayBuffer | undefined>} The public identity key ArrayBuffer, or undefined if not found.
   */
  async loadIdentityKey(identifier) {
    console.debug(`[IndexedDBStore] loadIdentityKey called for: ${identifier}`);
    const serialized = await performDbOperation(
      this.userId,
      IDENTITY_STORE_NAME,
      "readonly",
      (store) => store.get(`identity_${identifier}`)
    );
    const identityKey = deserializeBuffers(serialized);
    console.debug(
      `[IndexedDBStore] loadIdentityKey result for ${identifier}:`,
      identityKey instanceof ArrayBuffer
        ? `Found for ${this.userId}`
        : `Not Found for ${this.userId}`
    );
    return identityKey instanceof ArrayBuffer ? identityKey : undefined;
  }

  /**
   * Store the identity key pair for the local user.
   * @param {import('@privacyresearch/libsignal-protocol-typescript').KeyPairType} identityKeyPair
   * @returns {Promise<void>}
   */
  async storeIdentityKeyPair(identityKeyPair) {
    console.debug("[IndexedDBStore] storeIdentityKeyPair called");
    const serialized = serializeBuffers(identityKeyPair);
    await performDbOperation(
      this.userId,
      IDENTITY_STORE_NAME,
      "readwrite",
      (store) => store.put(serialized, "identityKey") // Correct key name used before
    );
    console.debug(
      `[IndexedDBStore] Stored identity key pair for ${this.userId}.`
    );
  }

  /**
   * Store the local registration ID.
   * @param {number} registrationId
   * @returns {Promise<void>}
   */
  async storeLocalRegistrationId(registrationId) {
    console.debug("[IndexedDBStore] storeLocalRegistrationId called");
    await performDbOperation(
      this.userId,
      KEY_STORE_NAME, // Stored in KEY_STORE before
      "readwrite",
      (store) => store.put(registrationId, "registrationId")
    );
    console.debug(
      `[IndexedDBStore] Stored local registration ID for ${this.userId}.`
    );
  }

  /**
   * Store a pre-key record.
   * @param {number} keyId
   * @param {import('@privacyresearch/libsignal-protocol-typescript').KeyPairType} preKey
   * @returns {Promise<void>}
   */
  async storePreKey(keyId, preKey) {
    console.debug(`[IndexedDBStore] storePreKey called for keyId: ${keyId}`);
    const serialized = serializeBuffers(preKey);
    await performDbOperation(
      this.userId,
      PREKEY_STORE_NAME,
      "readwrite",
      (store) => store.put(serialized, Number(keyId)) // Used Number(keyId) before
    );
    console.debug(
      `[IndexedDBStore] Stored pre-key ${keyId} for ${this.userId}.`
    );
  }

  /**
   * Store a session record for the given identifier.
   * @param {string} identifier - The identifier of the session partner (e.g., recipientId.deviceId).
   * @param {ArrayBuffer} session - The session record ArrayBuffer.
   * @returns {Promise<void>}
   */
  async storeSession(identifier, session) {
    console.debug(`[IndexedDBStore] storeSession called for: ${identifier}`);
    const serialized = serializeBuffers(session); // Session is ArrayBuffer
    await performDbOperation(
      this.userId,
      SESSION_STORE_NAME,
      "readwrite",
      (store) => store.put(serialized, identifier)
    );
    console.debug(
      `[IndexedDBStore] Stored session for ${identifier} for ${this.userId}.`
    );
  }

  /**
   * Store a signed pre-key record.
   * @param {number} keyId
   * @param {import('@privacyresearch/libsignal-protocol-typescript').KeyPairType} signedPreKey
   * @returns {Promise<void>}
   */
  async storeSignedPreKey(keyId, signedPreKey) {
    console.debug(
      `[IndexedDBStore] storeSignedPreKey called for keyId: ${keyId}`
    );
    const serialized = serializeBuffers(signedPreKey);
    await performDbOperation(
      this.userId,
      SIGNED_PREKEY_STORE_NAME,
      "readwrite",
      (store) => store.put(serialized, Number(keyId)) // Used Number(keyId) before
    );
    console.debug(
      `[IndexedDBStore] Stored signed pre-key ${keyId} for ${this.userId}.`
    );
  }

  /**
   * Associate a public identity key with an identifier.
   * Marks the identity as trusted.
   * @param {string} identifier - The identifier of the remote user (e.g., recipientId.deviceId).
   * @param {ArrayBuffer} identityKey - The public identity key ArrayBuffer.
   * @returns {Promise<void>}
   */
  async saveIdentity(identifier, identityKey) {
    console.debug(`[IndexedDBStore] saveIdentity called for: ${identifier}`);
    const serialized = serializeBuffers(identityKey);
    await performDbOperation(
      this.userId,
      IDENTITY_STORE_NAME,
      "readwrite",
      (store) => store.put(serialized, `identity_${identifier}`)
    );
    console.debug(
      `[IndexedDBStore] Saved identity for ${identifier} for ${this.userId}.`
    );
  }

  /**
   * Remove a pre-key record.
   * @param {number} keyId
   * @returns {Promise<void>}
   */
  async removePreKey(keyId) {
    console.debug(`[IndexedDBStore] removePreKey called for keyId: ${keyId}`);
    await performDbOperation(
      this.userId,
      PREKEY_STORE_NAME,
      "readwrite",
      (store) => store.delete(Number(keyId)) // Used Number(keyId) before
    );
    console.debug(
      `[IndexedDBStore] Removed pre-key ${keyId} for ${this.userId}.`
    );
  }

  /**
   * Remove a session record.
   * @param {string} identifier - The identifier of the session partner (e.g., recipientId.deviceId).
   * @returns {Promise<void>}
   */
  async removeSession(identifier) {
    console.debug(`[IndexedDBStore] removeSession called for: ${identifier}`);
    await performDbOperation(
      this.userId,
      SESSION_STORE_NAME,
      "readwrite",
      (store) => store.delete(identifier)
    );
    console.debug(
      `[IndexedDBStore] Removed session for ${identifier} for ${this.userId}.`
    );
  }

  /**
   * Remove a signed pre-key record.
   * @param {number} keyId
   * @returns {Promise<void>}
   */
  async removeSignedPreKey(keyId) {
    console.debug(
      `[IndexedDBStore] removeSignedPreKey called for keyId: ${keyId}`
    );
    await performDbOperation(
      this.userId,
      SIGNED_PREKEY_STORE_NAME,
      "readwrite",
      (store) => store.delete(Number(keyId)) // Used Number(keyId) before
    );
    console.debug(
      `[IndexedDBStore] Removed signed pre-key ${keyId} for ${this.userId}.`
    );
  }

  /**
   * Remove all session records for a given base identifier (user ID).
   * This is NOT part of the standard SignalProtocolStore interface but can be useful.
   * @param {string} identifierBase - The base identifier (e.g., user ID).
   * @returns {Promise<void>}
   */
  async removeAllSessions(identifierBase) {
    console.warn(
      `[IndexedDBStore] removeAllSessions called for base: ${identifierBase} for user ${this.userId}. This is a non-standard operation.`
    );
    await performDbOperation(
      this.userId,
      SESSION_STORE_NAME,
      "readwrite",
      (store) => {
        const cursorReq = store.openCursor();
        cursorReq.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            // Check if the key (identifier) starts with the base identifier
            if (String(cursor.key).startsWith(identifierBase + ".")) {
              console.debug(
                `[IndexedDBStore] Removing session via removeAllSessions: ${cursor.key} for user ${this.userId}`
              );
              cursor.delete();
            }
            cursor.continue();
          }
        };
        // Return the request object for the helper to handle completion/error
        return cursorReq;
      }
    );
    console.warn(
      `[IndexedDBStore] Finished removeAllSessions for ${identifierBase} for user ${this.userId}.`
    );
  }

  /**
   * Remove the identity key associated with an identifier.
   * @param {string} identifier - The identifier of the remote user (e.g., recipientId.deviceId).
   * @returns {Promise<void>}
   */
  async removeIdentity(identifier) {
    console.debug(`[IndexedDBStore] removeIdentity called for: ${identifier}`);
    // Remove the trusted identity marker
    await performDbOperation(
      this.userId,
      IDENTITY_STORE_NAME,
      "readwrite",
      (store) => store.delete(`identity_${identifier}`)
    );
    // Note: This does NOT remove the local user's identity key pair stored under "identityKey".
    console.debug(
      `[IndexedDBStore] Removed identity trust for ${identifier} for ${this.userId}.`
    );
  }

  /**
   * Check if a session record exists for the given identifier.
   * @param {string} identifier - The identifier of the session partner (e.g., recipientId.deviceId).
   * @returns {Promise<boolean>}
   */
  async containsSession(identifier) {
    console.debug(`[IndexedDBStore] containsSession called for: ${identifier}`);
    const count = await performDbOperation(
      this.userId,
      SESSION_STORE_NAME,
      "readonly",
      (store) => store.count(identifier)
    );
    const exists = count > 0;
    console.debug(
      `[IndexedDBStore] containsSession result for ${identifier}: ${exists} for user ${this.userId}`
    );
    return exists;
  }

  // libsignal older builds might call sessionExists, alias for compatibility
  sessionExists(identifier) {
    return this.containsSession(identifier);
  }

  // libsignal expects deleteSession
  async deleteSession(identifier) {
    console.warn("deleteSession is deprecated/non-standard? Use removeSession");
    return this.removeSession(identifier);
  }

  // libsignal expects deleteAllSessions
  async deleteAllSessions(identifierBase) {
    console.warn(
      "deleteAllSessions is non-standard. Using custom implementation."
    );
    return this.removeAllSessions(identifierBase);
  }

  /**
   * Clears all data from all signal-related object stores for the specific user instance.
   * USE WITH CAUTION.
   * @returns {Promise<void[]>}
   */
  async clearAllData() {
    console.warn(
      `[IndexedDBStore] CLEARING ALL DATA for user ${this.userId}...`
    );
    const storesToClear = [
      KEY_STORE_NAME,
      SESSION_STORE_NAME,
      PREKEY_STORE_NAME,
      SIGNED_PREKEY_STORE_NAME,
      IDENTITY_STORE_NAME,
    ];

    const clearPromises = storesToClear.map((storeName) =>
      performDbOperation(this.userId, storeName, "readwrite", (store) =>
        store.clear()
      )
    );

    return Promise.all(clearPromises).then(() => {
      console.warn(
        `[IndexedDBStore] ALL DATA CLEARED for user ${this.userId}.`
      );
    });
  }
}

================
File: src/lib/signalContext.jsx
================
// SignalContext.jsx
import { createContext, useContext, useEffect, useState } from "react";
import { supabase } from "./supabaseClient"; // Adjusted path assuming supabaseClient is in src/lib
import { IndexedDBStore } from "./localDb"; // Adjusted path assuming localDb is in src/lib

const SignalContext = createContext();

export function SignalProvider({ children }) {
  // ───────── State we expose ─────────
  const [signalStore, setSignalStore] = useState(null);
  const [deviceId, setDeviceId] = useState(null);
  const [isReady, setIsReady] = useState(false);
  const [initError, setInitError] = useState(null);

  // ───────── Who is logged-in right now? ─────────
  const [userId, setUserId] = useState(null);

  useEffect(() => {
    const { data: listener } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        const newUserId = session?.user?.id ?? null;
        console.log(
          `[SignalContext Auth Listener] Auth state changed. New User ID: ${newUserId}`
        );
        setUserId(newUserId);
      }
    );
    // Run once on mount in case we already have a session
    supabase.auth.getSession().then(({ data: { session } }) => {
      const initialUserId = session?.user?.id ?? null;
      console.log(
        `[SignalContext Auth Listener] Initial session check. User ID: ${initialUserId}`
      );
      setUserId(initialUserId);
    });

    return () => {
      console.log("[SignalContext Auth Listener] Unsubscribing auth listener.");
      listener?.subscription?.unsubscribe();
    };
  }, []);

  // ───────── (re)create store whenever userId changes ─────────
  useEffect(() => {
    console.log(
      `[SignalContext Store Effect] Running effect for userId: ${userId}`
    );
    // 1. Signing-out path
    if (!userId) {
      console.log(
        "[SignalContext Store Effect] User logged out or no user. Tearing down store."
      );
      setSignalStore(null);
      setDeviceId(null);
      setIsReady(false);
      setInitError(null); // Clear errors on logout
      return;
    }

    // 2. Signing-in path
    let cancelled = false;
    setIsReady(false); // Set to not ready while initializing for this user
    setInitError(null); // Clear previous errors

    (async () => {
      try {
        console.log(
          `[SignalContext Store Effect] Initializing store for user ${userId}...`
        );
        const store = new IndexedDBStore(userId); // ← userId guaranteed
        const localStorageKey = `${userId}_deviceId`;
        let didString = localStorage.getItem(localStorageKey);
        let didNumber;

        if (!didString) {
          // First time on this browser for this user – create a fresh random deviceId
          console.log(
            `[SignalContext Store Effect] No deviceId found in localStorage for key ${localStorageKey}. Generating new one.`
          );
          didNumber = crypto.getRandomValues(new Uint32Array(1))[0];
          // Ensure it's not zero, although highly unlikely for Uint32
          if (didNumber === 0) didNumber = 1;
          didString = String(didNumber);
          localStorage.setItem(localStorageKey, didString);
          console.log(
            `[SignalContext Store Effect] Generated and saved new deviceId: ${didNumber}`
          );
          // --------
          // NOTE: The original logic to generate keys + register bundle was here.
          // This new implementation *omits* that step.
          // If key generation/registration is still needed on first use,
          // it needs to be added back here or handled elsewhere.
          // --------
        } else {
          didNumber = Number(didString);
          console.log(
            `[SignalContext Store Effect] Found deviceId in localStorage: ${didNumber}`
          );
        }

        if (!cancelled) {
          console.log(
            `[SignalContext Store Effect] Initialization complete for user ${userId}. Setting state.`
          );
          setSignalStore(store);
          setDeviceId(didNumber);
          setIsReady(true);
          setInitError(null);
        }
      } catch (e) {
        if (!cancelled) {
          console.error("[SignalProvider] init failed:", e);
          setInitError(e.message ?? String(e));
          // Ensure state is reset on error
          setSignalStore(null);
          setDeviceId(null);
          setIsReady(false);
        }
      }
    })();

    return () => {
      console.log(`[SignalContext Store Effect] Cleanup for userId: ${userId}`);
      cancelled = true;
    };
  }, [userId]);

  return (
    <SignalContext.Provider
      value={{ signalStore, deviceId, isReady, initializationError: initError }}
    >
      {children}
    </SignalContext.Provider>
  );
}

export const useSignal = () => useContext(SignalContext);

================
File: src/lib/signalCrypto.js
================
import { get, set } from 'idb-keyval';

const { subtle } = crypto;

// Generate an ECDH key pair
async function generateKeyPair() {
  try {
    return await subtle.generateKey(
      {
        name: 'ECDH',
        namedCurve: 'P-256',
      },
      true,
      ['deriveKey', 'deriveBits']
    );
  } catch (error) {
    throw new Error(`Failed to generate key pair: ${error.message}`);
  }
}

// Initialize keys for a user
async function initializeKeys(userId) {
  try {
    const identityKeyPair = await generateKeyPair();
    const preKeyPair = await generateKeyPair();

    await set(`${userId}:identityKey`, {
      publicKey: await subtle.exportKey('jwk', identityKeyPair.publicKey),
      privateKey: await subtle.exportKey('jwk', identityKeyPair.privateKey),
    });
    await set(`${userId}:preKey`, {
      publicKey: await subtle.exportKey('jwk', preKeyPair.publicKey),
      privateKey: await subtle.exportKey('jwk', preKeyPair.privateKey),
    });

    return {
      identityKey: await subtle.exportKey('spki', identityKeyPair.publicKey),
      preKey: await subtle.exportKey('spki', preKeyPair.publicKey),
    };
  } catch (error) {
    throw new Error(`Failed to initialize keys for ${userId}: ${error.message}`);
  }
}

// Retrieve stored keys
async function getKeys(userId) {
  try {
    const identityKeyData = await get(`${userId}:identityKey`);
    const preKeyData = await get(`${userId}:preKey`);

    if (!identityKeyData || !preKeyData) {
      throw new Error('Keys not found in storage');
    }

    const identityKeyPair = {
      publicKey: await subtle.importKey(
        'jwk',
        identityKeyData.publicKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        false,
        []
      ),
      privateKey: await subtle.importKey(
        'jwk',
        identityKeyData.privateKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveKey', 'deriveBits']
      ),
    };
    const preKeyPair = {
      publicKey: await subtle.importKey(
        'jwk',
        preKeyData.publicKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        false,
        []
      ),
      privateKey: await subtle.importKey(
        'jwk',
        preKeyData.privateKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveKey', 'deriveBits']
      ),
    };

    return { identityKeyPair, preKeyPair };
  } catch (error) {
    throw new Error(`Failed to retrieve keys for ${userId}: ${error.message}`);
  }
}

// Perform X3DH key agreement
async function initiateX3DH(ourUserId, theirUserId, theirPublicKeys) {
  try {
    const { identityKeyPair, preKeyPair } = await getKeys(ourUserId);

    // Import their public identity key
    const theirIdentityKey = await subtle.importKey(
      'spki',
      theirPublicKeys.identityKey,
      { name: 'ECDH', namedCurve: 'P-256' },
      false,
      []
    );

    // Derive shared secret using our identity private key and their identity public key
    const sharedSecret = await subtle.deriveBits(
      {
        name: 'ECDH',
        public: theirIdentityKey,
      },
      identityKeyPair.privateKey,
      256
    );

    // Log shared secret for debugging
    const sharedSecretHex = Array.from(new Uint8Array(sharedSecret))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    console.log(`Shared secret for ${ourUserId} -> ${theirUserId}: ${sharedSecretHex}`);

    // Convert to AES-GCM key
    const derivedKey = await subtle.importKey(
      'raw',
      sharedSecret,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );

    await set(`${ourUserId}:sharedKey:${theirUserId}`, derivedKey);
    return derivedKey;
  } catch (error) {
    throw new Error(`X3DH failed for ${ourUserId} -> ${theirUserId}: ${error.message}`);
  }
}

// Encrypt a message
async function encryptMessage(userId, recipientId, message) {
  try {
    const sharedKey = await get(`${userId}:sharedKey:${recipientId}`);
    if (!sharedKey) throw new Error('Shared key not found');

    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const ciphertext = await subtle.encrypt(
      {
        name: 'AES-GCM',
        iv,
      },
      sharedKey,
      data
    );

    return {
      iv: iv.buffer,
      ciphertext,
    };
  } catch (error) {
    throw new Error(`Encryption failed for ${userId} -> ${recipientId}: ${error.message}`);
  }
}

// Decrypt a message
async function decryptMessage(userId, senderId, { iv, ciphertext }) {
  try {
    const sharedKey = await get(`${userId}:sharedKey:${senderId}`);
    if (!sharedKey) throw new Error('Shared key not found');

    const ivArray = new Uint8Array(iv);

    const plaintext = await subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: ivArray,
      },
      sharedKey,
      ciphertext
    );

    const decoder = new TextDecoder();
    return decoder.decode(plaintext);
  } catch (error) {
    throw new Error(`Decryption failed for ${userId} <- ${senderId}: ${error.message}`);
  }
}

export { initializeKeys, getKeys, initiateX3DH, encryptMessage, decryptMessage };

================
File: src/lib/signalUtils.js
================
"use strict";

import {
  KeyHelper,
  SignalProtocolAddress,
  SessionBuilder,
  SessionCipher,
  //setLogger,
} from "@privacyresearch/libsignal-protocol-typescript";
// import { get } from "./backend"; // Assuming backend.js is in the same directory or adjust path - REMOVED

// --- Enable Signal Library Debug Logging ---
// Uncomment the line below to see detailed logs from the Signal library itself
//setLogger(console.log);
// ---

/**
 * Represents the public key bundle needed to establish a session.
 * @typedef {import('@privacyresearch/libsignal-protocol-typescript').PreKeyBundleType<ArrayBuffer>} PreKeyBundleType
 */

/**
 * Represents the Signal Protocol store interface.
 * You must provide an object conforming to this interface.
 * @typedef {import('@privacyresearch/libsignal-protocol-typescript').SignalProtocolStore} SignalProtocolStore
 */

/**
 * Represents the encrypted message structure.
 * @typedef {import('@privacyresearch/libsignal-protocol-typescript').MessageType} MessageType
 */

// --- Add bufToB64 helper ---
function bufToB64(buf) {
  // Ensure buf is ArrayBuffer
  if (!(buf instanceof ArrayBuffer)) {
    console.error("[bufToB64] Input is not ArrayBuffer:", buf);
    if (buf === null || buf === undefined) return null; // Handle null/undefined gracefully if they sneak in
    throw new Error("bufToB64: Expected ArrayBuffer input.");
  }
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
// --- End bufToB64 helper ---

/**
 * Initializes the Signal protocol state for the current device.
 * Generates identity keys, registration ID, a signed pre-key, and a one-time pre-key,
 * storing them in the provided store.
 * It then returns a bundle formatted for server registration with Base64 encoded keys.
 * @param {import('@privacyresearch/libsignal-protocol-typescript').SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} userId - The user's identifier, to be included in the returned bundle.
 * @returns {Promise<{
 *   userId: string,
 *   registrationId: number,
 *   identityKey: string, // Base64 encoded
 *   signedPreKeyId: number,
 *   signedPreKeyPublicKey: string, // Base64 encoded
 *   signedPreKeySignature: string, // Base64 encoded
 *   preKeyId: number,
 *   preKeyPublicKey: string // Base64 encoded
 * }>} An object containing the user ID, registration ID, and Base64 encoded public identity key,
 *      signed pre-key components, and one-time pre-key components, formatted for the server.
 */
export const initializeSignalProtocol = async (store, userId) => {
  if (!userId || typeof userId !== "string" || userId.trim() === "") {
    console.error(
      "[initializeSignalProtocol] Invalid or missing userId:",
      userId
    );
    throw new Error("userId must be a non-empty string.");
  }
  // Basic check for store
  if (
    !store ||
    typeof store.storeIdentityKeyPair !== "function" ||
    typeof store.storeLocalRegistrationId !== "function" ||
    typeof store.storeSignedPreKey !== "function" ||
    typeof store.storePreKey !== "function"
  ) {
    console.error(
      "[initializeSignalProtocol] Invalid store object provided:",
      store
    );
    throw new Error("Invalid or incomplete store object provided.");
  }

  // ❶ identity & registration
  const identity = await KeyHelper.generateIdentityKeyPair();
  const registrationId = KeyHelper.generateRegistrationId();

  await store.storeIdentityKeyPair(identity);
  await store.storeLocalRegistrationId(registrationId);

  // ❷ signed-pre-key
  // Use a seed for the ID; the library returns the actual ID in the generated object.
  // Max value for signedPreKeyId is 2147483647 (2^31 - 1).
  const signedPreKeyIdSeed = Math.floor(Math.random() * (2 ** 31 - 2)) + 1; // Range: 1 to 2^31 - 2
  const signedPreKey = await KeyHelper.generateSignedPreKey(
    identity,
    signedPreKeyIdSeed
  );
  // signedPreKey is { keyId: number, keyPair: KeyPairType, signature: ArrayBuffer }
  // Store using the keyId from the signedPreKey object and its keyPair.
  console.log(`[SignalUtils] Storing SignedPreKey ID: ${signedPreKey.keyId}`);
  await store.storeSignedPreKey(signedPreKey.keyId, signedPreKey.keyPair);
  console.log(`[SignalUtils] Stored SignedPreKey ID: ${signedPreKey.keyId}`);

  // ❸ first one-time pre-key
  // Max value for preKeyId for libsignal-protocol-typescript is 16777215 (0xFFFFFF).
  const preKeyIdSeed = Math.floor(Math.random() * 16777214) + 1; // Range: 1 to 2^24 - 2
  const preKey = await KeyHelper.generatePreKey(preKeyIdSeed);
  // preKey is { keyId: number, keyPair: KeyPairType }
  // Store using the keyId from the preKey object (as a string) and its keyPair.
  console.log(`[SignalUtils] Storing PreKey ID: ${preKey.keyId}`);
  await store.storePreKey(preKey.keyId, preKey.keyPair);
  console.log(`[SignalUtils] Stored PreKey ID: ${preKey.keyId}`);

  console.log(
    `[SignalUtils] Initialized Signal protocol for user ${userId}. RegID: ${registrationId}, SignedPKID: ${signedPreKey.keyId}, PreKeyID: ${preKey.keyId}`
  );

  // ❹ build bundle in **Base-64**
  const bundle = {
    userId,
    registrationId,
    identityKey: bufToB64(identity.pubKey),
    signedPreKeyId: signedPreKey.keyId, // Use the keyId from the generated object
    signedPreKeyPublicKey: bufToB64(signedPreKey.keyPair.pubKey),
    signedPreKeySignature: bufToB64(signedPreKey.signature),
    preKeyId: preKey.keyId, // Use the keyId from the generated object
    preKeyPublicKey: bufToB64(preKey.keyPair.pubKey),
  };

  // console.log("[SignalUtils] Generated bundle for server:", JSON.stringify(bundle, (k,v) => typeof v === 'string' && v.length > 30 ? v.substring(0,30) + '...' : v, 2));
  return bundle;
};

/**
 * Builds a Signal session with a recipient using their PreKeyBundle.
 * @param {SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} recipientId - The recipient's identifier.
 * @param {number} deviceId - The recipient's device ID.
 * @param {PreKeyBundleType} preKeyBundle - The recipient's pre-key bundle fetched from the server.
 * @returns {Promise<void>}
A promise that resolves when the session is built and stored, or rejects on identity key mismatch.
 */
export const buildSession = async (
  store,
  recipientId,
  deviceId,
  preKeyBundle
) => {
  const recipientAddress = new SignalProtocolAddress(recipientId, deviceId);
  const sessionBuilder = new SessionBuilder(store, recipientAddress);

  console.log(`Building session with ${recipientId}:${deviceId}`);
  try {
    await sessionBuilder.processPreKey(preKeyBundle);
    console.log(`Session built with ${recipientId}:${deviceId}`);
  } catch (error) {
    console.error("Error processing pre-key bundle:", error);
    throw error; // Re-throw for handling upstream
  }
};

/**
 * Encrypts a message for a recipient.
 * Establishes a session if one doesn't exist (via PreKeyWhisperMessage).
 * @param {SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} recipientId - The recipient's identifier.
 * @param {number} deviceId - The recipient's device ID.
 * @param {ArrayBuffer} plaintextBuffer - The message content to encrypt as an ArrayBuffer.
 * @returns {Promise<MessageType>} The encrypted message object (contains type and body).
 */
export const encryptMessage = async (
  store,
  recipientId,
  deviceId,
  plaintextBuffer
) => {
  const recipientAddress = new SignalProtocolAddress(recipientId, deviceId);
  const sessionCipher = new SessionCipher(store, recipientAddress);

  try {
    const session = await store.loadSession(recipientAddress.toString());
    console.log(
      `[encryptMessage] Session state loaded for ${recipientId}:${deviceId} before encrypt:`,
      session
    );
  } catch (e) {
    console.warn(
      `[encryptMessage] Could not load session for logging before encrypt`,
      e
    );
  }

  console.log(`Encrypting message for ${recipientId}:${deviceId}`);
  try {
    const ciphertext = await sessionCipher.encrypt(plaintextBuffer);
    console.log(
      `Message encrypted (type ${ciphertext.type}) for ${recipientId}:${deviceId}`
    );

    if (ciphertext.type === 3) {
      try {
        const raw = Uint8Array.from(ciphertext.body, (c) => c.charCodeAt(0));
        console.log(
          `[DBG-TX] type=${ciphertext.type}  len=${raw.byteLength}`,
          `sha256=${await crypto.subtle
            .digest("SHA-256", raw)
            .then((buf) =>
              [...new Uint8Array(buf)]
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("")
            )}`
        );
      } catch (dbgError) {
        console.error("[DBG-TX] Error logging debug info:", dbgError);
      }
    }
    return ciphertext;
  } catch (error) {
    console.error("Error encrypting message:", error);
    throw error;
  }
};

/**
 * Decrypts an incoming message.
 * Handles both PreKeyWhisperMessages (establishing a session) and WhisperMessages.
 * @param {SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} myUserId - The ID of the user receiving the message (current user).
 * @param {number} myDeviceId - The device ID of the user receiving the message.
 * @param {string} theirUserId - The sender's identifier.
 * @param {number} theirDeviceId - The sender's device ID.
 * @param {MessageType} ciphertext - The incoming encrypted message object (body is expected to be a *Uint8Array*).
 * @returns {Promise<ArrayBuffer | null>} A promise resolving to the decrypted plaintext ArrayBuffer, or null if decryption fails.
 */
export const decryptMessage = async (
  store,
  myUserId,
  myDeviceId,
  theirUserId,
  theirDeviceId,
  ciphertext
) => {
  const senderAddress = new SignalProtocolAddress(theirUserId, theirDeviceId);
  const sessionCipher = new SessionCipher(store, senderAddress);
  const senderAddressString = senderAddress.toString();
  const recipientAddressString = new SignalProtocolAddress(
    myUserId,
    myDeviceId
  ).toString();

  console.log(
    `Attempting decryption of message type ${ciphertext.type} from ${senderAddressString} to ${recipientAddressString}`
  );

  const bodyUint8Array = ciphertext.body;
  if (!(bodyUint8Array instanceof Uint8Array)) {
    console.error(
      `[decryptMessage] Expected ciphertext.body to be a Uint8Array, but got: ${typeof bodyUint8Array}`
    );
    return null;
  }

  try {
    let plaintextBuffer = null;

    if (ciphertext.type === 3) {
      console.log(`Processing PreKeyWhisperMessage (Type 3)...`);
      plaintextBuffer = await sessionCipher
        .decryptPreKeyWhisperMessage(bodyUint8Array.buffer, "binary")
        .catch(async (err) => {
          if (err instanceof Error && err.message?.includes("Bad MAC")) {
            console.warn(
              `Bad MAC error on PreKeyWhisperMessage from ${senderAddressString}. Session likely stale. Wiping session and retrying...`
            );
            await store.removeSession(senderAddressString);
            const freshCipher = new SessionCipher(store, senderAddress);
            return freshCipher.decryptPreKeyWhisperMessage(
              bodyUint8Array.buffer,
              "binary"
            );
          } else {
            console.error(
              `Non-MAC decryption error (PreKeyWhisperMessage) from ${senderAddressString}:`,
              err
            );
            throw err;
          }
        });
      console.log(
        plaintextBuffer
          ? `Successfully processed PreKeyWhisperMessage from ${senderAddressString}`
          : `Failed to process PreKeyWhisperMessage from ${senderAddressString} after potential retry.`
      );
    } else if (ciphertext.type === 1) {
      console.log(
        `Decrypting WhisperMessage (Type 1) from ${senderAddressString}...`
      );
      try {
        plaintextBuffer = await sessionCipher.decryptWhisperMessage(
          bodyUint8Array.buffer,
          "binary"
        );
        console.log(
          `Successfully decrypted WhisperMessage from ${senderAddressString}`
        );
      } catch (e) {
        if (e instanceof Error && e.message?.includes("Bad MAC")) {
          console.error(
            `🛑 Bad MAC error decrypting WhisperMessage (Type 1) from ${senderAddressString}. This could be due to out-of-order messages or session state mismatch. No automatic retry. Raw error:`,
            e
          );
          plaintextBuffer = null;
        } else {
          console.error(
            `Non-MAC decryption error (WhisperMessage) from ${senderAddressString}:`,
            e
          );
          throw e;
        }
      }
    } else {
      console.warn(
        `Received message with unknown type: ${ciphertext.type} from ${senderAddressString}`
      );
      throw new Error(`Unknown message type: ${ciphertext.type}`);
    }

    if (plaintextBuffer) {
      try {
        console.log(
          `📩 Decrypted content from ${senderAddressString}: "`,
          arrayBufferToString(plaintextBuffer).substring(0, 50) + "...",
          `"`
        );
      } catch (logError) {
        console.warn(
          "Could not log decrypted plaintext (decoding error?)",
          logError
        );
      }
    }
    return plaintextBuffer;
  } catch (error) {
    console.error(
      `Decryption failed catastrophically for message from ${senderAddressString}:`,
      error
    );
    return null;
  }
};

/**
 * Helper to convert ArrayBuffer to Base64 string.
 * Useful for transmitting binary data (like keys or ciphertexts) as strings.
 * @param {ArrayBuffer} buffer
 * @returns {string}
 */
export function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}

/**
 * Helper to convert Base64 string back to ArrayBuffer.
 * @param {string} base64
 * @returns {ArrayBuffer | null} Null if input is invalid or conversion fails.
 */
export function base64ToArrayBuffer(base64) {
  if (!base64 || typeof base64 !== "string") {
    console.warn("[base64ToArrayBuffer] Received invalid input:", base64);
    return null;
  }
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
  } catch (error) {
    console.error("Error converting Base64 to ArrayBuffer:", base64, error);
    return null;
  }
}

/**
 * Helper to convert string to ArrayBuffer.
 * @param {string} str
 * @returns {ArrayBuffer}
 */
export function stringToArrayBuffer(str) {
  return new TextEncoder().encode(str).buffer;
}

/**
 * Helper to convert ArrayBuffer to string.
 * @param {ArrayBuffer} buffer
 * @returns {string}
 */
export function arrayBufferToString(buffer) {
  return new TextDecoder().decode(new Uint8Array(buffer));
}

/**
 * Helper function to convert an ArrayBuffer or Uint8Array to a plain hexadecimal string.
 * @param {ArrayBuffer | Uint8Array} buffer The data to convert.
 * @returns {string} The hexadecimal string representation (e.g., "a1b2c3d4").
 */
export function buf2hex(buffer) {
  const byteArray =
    buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
  return [...byteArray].map((x) => x.toString(16).padStart(2, "0")).join("");
}

/**
 * Helper function to convert PostgreSQL bytea hex escape format ('\\x...') to a Uint8Array.
 * @param {string | null | undefined} hexString The '\\x...' formatted string.
 * @returns {Uint8Array} The resulting Uint8Array.
 * @throws {Error} If the input format is invalid.
 */
export function hexToUint8Array(hexString) {
  if (
    !hexString ||
    typeof hexString !== "string" ||
    !hexString.startsWith("\\x")
  ) {
    throw new Error(
      `[hexToUint8Array] Invalid or non-hex string format received: ${hexString}`
    );
  }
  const hex = hexString.substring(2);

  if (hex.length % 2 !== 0) {
    throw new Error(
      `[hexToUint8Array] Hex string (after prefix removal) must have an even number of digits: ${hex}`
    );
  }

  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    const byte = parseInt(hex.substring(i, i + 2), 16);
    if (isNaN(byte)) {
      throw new Error(
        `[hexToUint8Array] Invalid hex character pair found: ${hex.substring(
          i,
          i + 2
        )}`
      );
    }
    byteArray[i / 2] = byte;
  }
  return byteArray;
}

/**
 * Converts an array of pre-key bundle objects from the backend into a Map.
 * @param {Array<object>} arr - Array of bundle objects from /api/signal/bundles/:userId.
 * Each object is expected to have deviceId, registrationId, identityKey (Base64),
 * signedPreKeyId, signedPreKeyPublicKey (Base64), signedPreKeySignature (Base64),
 * preKeyId, preKeyPublicKey (Base64).
 * @returns {Map<number, PreKeyBundleType>} A map of deviceId to PreKeyBundle.
 */
export function bundlesToMap(arr) {
  const map = new Map();
  if (!Array.isArray(arr)) {
    console.error("[bundlesToMap] Input is not an array:", arr);
    return map; // Return empty map
  }
  for (const b of arr) {
    // --- Better Fix: Normalize device ID --- START ---
    // Determine the device ID, checking common variations
    const deviceId = b.deviceId ?? b.device_id; // Check camelCase first, then snake_case

    if (typeof deviceId !== "number") {
      console.warn(
        "[bundlesToMap] Skipping bundle object due to missing or invalid deviceId/device_id:",
        b
      );
      continue; // Skip if no valid device ID found
    }
    // --- Better Fix: Normalize device ID --- END ---

    // Validate other basic structure of b - Ensure required keys exist
    if (
      b &&
      b.identityKey && // Base64 string
      typeof b.registrationId === "number" &&
      typeof b.signedPreKeyId === "number" &&
      b.signedPreKeyPublicKey && // Base64 string
      b.signedPreKeySignature && // Base64 string
      typeof b.preKeyId === "number" &&
      b.preKeyPublicKey // Base64 string
    ) {
      const identityKeyBuffer = base64ToArrayBuffer(b.identityKey);
      const signedPreKeyPublicKeyBuffer = base64ToArrayBuffer(
        b.signedPreKeyPublicKey
      );
      const signedPreKeySignatureBuffer = base64ToArrayBuffer(
        b.signedPreKeySignature
      );
      const preKeyPublicKeyBuffer = base64ToArrayBuffer(b.preKeyPublicKey);

      // Check for nulls from base64ToArrayBuffer which indicates conversion failure
      if (
        !identityKeyBuffer ||
        !signedPreKeyPublicKeyBuffer ||
        !signedPreKeySignatureBuffer ||
        !preKeyPublicKeyBuffer
      ) {
        console.warn(
          "[bundlesToMap] Failed to convert one or more keys from Base64 for deviceId:",
          b.deviceId,
          "Bundle data:",
          b
        );
        continue; // Skip this bundle if any key conversion fails
      }

      // Construct the bundle object for the map
      const bundleForMap = {
        registrationId: b.registrationId,
        identityKey: identityKeyBuffer,
        signedPreKey: {
          keyId: b.signedPreKeyId,
          publicKey: signedPreKeyPublicKeyBuffer,
          signature: signedPreKeySignatureBuffer,
        },
        preKey: {
          keyId: b.preKeyId,
          publicKey: preKeyPublicKeyBuffer,
        },
        // --- Better Fix: Explicitly add deviceId to the bundle object ---
        deviceId: deviceId, // Store the normalized deviceId here
        // --- Better Fix: End ---
      };

      map.set(deviceId, bundleForMap); // Use the normalized deviceId as the key
    } else {
      console.warn(
        `[bundlesToMap] Skipping bundle object for deviceId ${deviceId} due to missing required fields:`,
        b
      );
    }
  }
  return map;
}

================
File: src/lib/supabaseClient.js
================
import { createClient } from "@supabase/supabase-js";

// Read environment variables
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Check if variables are set
if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error(
    "Supabase URL and Anon Key must be provided in .env file with VITE_ prefix"
  );
}

// Create and export the Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/main.jsx
================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);

================
File: src/pages/AboutPage.jsx
================
import { Link } from "react-router-dom";
import React from 'react';
import { AlertCircle, ArrowLeft, Lock, Shield } from "lucide-react";


const About = () => {
  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
    <header className="container mx-auto p-4">
      <Link
        to="/"
        className="inline-flex items-center text-slate-300 hover:text-white"
      >
        <ArrowLeft className="h-4 w-4 mr-2" />
        Back to Home
      </Link>
    </header>

      <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col py-10">
      <div className="max-w-4xl mx-auto bg-gradient-to-b p-8 rounded-lg shadow-md">
        <h1 className="text-3xl font-bold text-center text-white mb-6">About the project</h1>
        <p className="text-white mb-8">
          Welcome to our About page! Here you can learn more about our company, our mission, and our team.
          Welcome to our About page! Here you can learn more about our project.
        </p>

        <section className="mb-8">
          <h2 className="text-2xl font-semibold text-white mb-4">Our Mission</h2>
          <h2 className="text-2xl font-semibold text-white mb-4">Our project</h2>
          <p className="text-white">
            Our mission is to provide high-quality services and products to our customers. We strive to exceed expectations and deliver exceptional value.
            The project is based on end to end message encryption. It is a web application that allows users to send and receive encrypted messages securely.
            The application uses the double ratchet algorithm to ensure that messages are encrypted and decrypted securely. 
          </p>
        </section>
        

       <section className="mb-8">
          <h2 className="text-2xl font-semibold text-gray-800 mb-4">Meet the Team</h2>
          <h2 className="text-2xl font-semibold text-white mb-4">The group:</h2>
          <div className="space-y-4">

            <div className="team-member">
              <h3 className="text-xl font-semibold text-white">Abul Kasem Mohammed Omar Sharif</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-white">Mads Holt Jensen</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-gray-800">John Doe</h3>
              <p className="text-gray-600">CEO & Founder</p>
              <h3 className="text-xl font-semibold text-white">Neha Sharma</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-gray-800">Jane Smith</h3>
              <p className="text-gray-600">CTO</p>
              <h3 className="text-xl font-semibold text-white">Ivan Mezinov</h3>
              </div>

              <div className="team-member">
              <h3 className="text-xl font-semibold text-white">Victor Wejergang Petersen</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-gray-800">Emily Johnson</h3>
              <p className="text-gray-600">Marketing Director</p>
              <h3 className="text-xl font-semibold text-white">Morten Allan Jensen</h3>
            </div>


          </div>
        </section>

        @todo: Add more sections as needed
        @todo add back button 
        @todo Write about the project and members
        </div>
        </div>
      </div>

  );
};

export default About;

================
File: src/pages/ChatPage.jsx
================
import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import EmojiPicker from "emoji-picker-react";

import {
  ArrowLeft,
  LogOut,
  Menu,
  MessageSquare,
  MoreVertical,
  Pencil,
  Plus,
  Search,
  Send,
  Settings,
  User,
  Users,
} from "lucide-react";
import { Link, useNavigate } from "react-router-dom";
import { AnimatePresence } from "framer-motion";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useMobile } from "../hooks/use-mobile";
import { supabase } from "../lib/supabaseClient";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import NewChatModal from "../components/NewChatModal";
import NewGroupModal from "../components/NewGroupModal";
import { useSignal } from "../lib/signalContext.jsx";
import {
  encryptMessage,
  decryptMessage,
  arrayBufferToString,
  buf2hex,
  hexToUint8Array,
  bundlesToMap,
} from "../lib/signalUtils";
import {
  SignalProtocolAddress,
  SessionBuilder,
} from "@privacyresearch/libsignal-protocol-typescript";
import { get, post } from "../lib/backend";
import { cacheSentMessage, getCachedMessageContent } from "../lib/db";

// Helper function to convert PostgreSQL bytea hex escape format ('\\x...') to ArrayBuffer
/* REMOVED - Use hexToUint8Array from signalUtils instead
function hexStringToArrayBuffer(hexString) {
  // Check if the string starts with the literal '\x'
  if (!hexString || !hexString.startsWith("\\x")) {
    // Note: In JS string literals, '\\x' represents the two characters \ and x
    console.warn(
      "[hexStringToArrayBuffer] Invalid or non-hex string format received:",
      hexString
    );
    return null;
  }
  // Remove the leading '\x' prefix (2 characters)
  const hex = hexString.substring(2);

  // Validate remaining hex string length
  if (hex.length % 2 !== 0) {
    console.error(
      "[hexStringToArrayBuffer] Hex string (after prefix removal) must have an even number of digits:",
      hex
    );
    return null;
  }

  // Convert hex pairs to bytes
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    const byte = parseInt(hex.substring(i, i + 2), 16);
    if (isNaN(byte)) {
      // Add check for invalid hex characters
      console.error(
        `[hexStringToArrayBuffer] Invalid hex character pair found: ${hex.substring(
          i,
          i + 2
        )}`
      );
      return null;
    }
    byteArray[i / 2] = byte;
  }
  return byteArray.buffer; // Return the underlying ArrayBuffer
}
*/

// Helper function to convert ArrayBuffer or ArrayBufferView to PostgreSQL bytea hex format ('\\x...')
/* REMOVED - Use binaryStringToHex from signalUtils instead
function arrayBufferToHex(input) {
  console.log("[arrayBufferToHex] Received input:", input);

  // Accept both kinds transparently
  // 🔧 NEW – accept the raw binary string returned by SessionCipher.encrypt
  let view;
  if (typeof input === "string") {
    // Each charCode is already 0-255, so this is loss-less
    console.log(
      "[arrayBufferToHex] Input is string, attempting charCode conversion."
    );
    view = Uint8Array.from(input, (ch) => ch.charCodeAt(0));
  } else if (input instanceof ArrayBuffer) {
    console.log("[arrayBufferToHex] Input is ArrayBuffer.");
    view = new Uint8Array(input);
  } else if (ArrayBuffer.isView(input)) {
    console.log("[arrayBufferToHex] Input is ArrayBufferView.");
    view = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
  } else {
    console.error("[arrayBufferToHex] Unsupported input:", input);
    return null;
  }

  if (!view) {
    // This case should technically not be reachable if the checks above are exhaustive
    console.error(
      "[arrayBufferToHex] Failed to create Uint8Array view from input.",
      input
    );
    return null;
  }

  if (!view.byteLength) {
    console.warn("[arrayBufferToHex] Received empty buffer/view.");
    return "\\x";
  }

  try {
    // More modern/concise hex conversion
    const hex = [...view].map((b) => b.toString(16).padStart(2, "0")).join("");
    console.log("[arrayBufferToHex] Joined hex string (no prefix):", hex);

    const finalHexString = "\\x" + hex;
    console.log(
      "[arrayBufferToHex] Final hex string with prefix:",
      finalHexString
    );
    return finalHexString;
  } catch (error) {
    console.error(
      "[arrayBufferToHex] Error during conversion:",
      error,
      "Input:",
      input
    );
    return null; // Return null on error
  }
}
*/

// Helper function to convert ArrayBuffer to Base64 string
// eslint-disable-next-line no-unused-vars
function arrayBufferToBase64(buffer) {
  if (!buffer) {
    console.warn("[arrayBufferToBase64] Received null input.");
    return null;
  }
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}

// --- NEW HELPER FUNCTION --- START ---
/**
 * Try to build a Signal session, and if we get "Identity key changed",
 * reset that peer's session+identity and then build again.
 */
async function safeProcessPreKey(store, userId, deviceId, bundle) {
  const addr = new SignalProtocolAddress(userId, deviceId);
  const addrStr = addr.toString();
  const builder = new SessionBuilder(store, addr);

  // 1) Check whether we've already saved & trusted this identity:
  let trusted = false;
  try {
    // Check if the specific identityKey from the bundle is already trusted for this address.
    // This also implicitly checks if an identity exists for addrStr.
    trusted = await store.isTrustedIdentity(addrStr, bundle.identityKey);
    if (trusted) {
      console.log(
        `[safeProcessPreKey] Identity for ${addrStr} from bundle is already trusted.`
      );
    } else {
      // If not trusted, it could be a new peer, or a peer whose key changed AND our stored one is stale.
      // We might also have no identity at all for them.
      const existingKey = await store.loadIdentityKey(addrStr); // Check if *any* key is stored
      if (!existingKey) {
        console.log(
          `[safeProcessPreKey] No identity previously stored for ${addrStr}. Will trust new one from bundle.`
        );
      } else {
        console.log(
          `[safeProcessPreKey] Stored identity for ${addrStr} exists but does not match bundle. Will attempt to save new one.`
        );
      }
    }
  } catch (e) {
    // isTrustedIdentity or loadIdentityKey might throw if the store is in an unexpected state or addrStr is totally new
    // (though typically they return false/null if not found).
    // We assume not trusted if any error occurs here, and proceed to save.
    console.warn(
      `[safeProcessPreKey] Error checking trusted identity for ${addrStr}, assuming not trusted: ${e.message}`
    );
    trusted = false;
  }

  if (!trusted) {
    // If not trusted (either because it's new, different, or check failed), save it.
    // This is the crucial step to prevent false "Identity key changed" if no identity was there before.
    console.log(
      `[safeProcessPreKey] Attempting to save and trust new identity for ${addrStr} from bundle.`
    );
    await store.saveIdentity(addrStr, bundle.identityKey);
    console.log(
      `[safeProcessPreKey] Successfully saved new identity for ${addrStr}.`
    );
  }

  // 2) Now build the session
  try {
    console.log(
      `[safeProcessPreKey] Attempting SessionBuilder.processPreKey for ${addrStr}...`
    );
    await builder.processPreKey(bundle);
    console.log(
      `[safeProcessPreKey] Session built/updated successfully for ${addrStr}.`
    );
  } catch (err) {
    // If processPreKey *still* throws "Identity key changed" here,
    // it means a genuine rotation happened and the key we just saved (if we did)
    // or the key that was previously trusted, is now outdated by this very bundle.
    if (err.message?.includes("Identity key changed")) {
      console.warn(
        `[safeProcessPreKey] Genuine identity key rotation detected by processPreKey for ${addrStr}. Clearing old session/identity, re-saving new identity, and retrying processPreKey.`
      );
      await store.removeSession(addrStr); // Clear potentially stale session with the very old identity

      // Explicitly remove the old identity before saving the new one
      if (typeof store.removeIdentity === "function") {
        await store.removeIdentity(addrStr);
        console.log(`[safeProcessPreKey] Removed old identity for ${addrStr}.`);
      } else {
        // If store doesn't have a direct removeIdentity, this situation is harder to recover from cleanly
        // without knowing the store's internal structure. For now, we'll log and proceed to save,
        // hoping saveIdentity overwrites correctly. This might be a point of failure if not.
        console.warn(
          `[safeProcessPreKey] store.removeIdentity is not a function. Attempting to overwrite identity for ${addrStr}.`
        );
      }

      await store.saveIdentity(addrStr, bundle.identityKey); // Re-save/ensure the identity from THIS bundle is current
      console.log(
        `[safeProcessPreKey] Re-saved new identity for ${addrStr} due to rotation detected by processPreKey.`
      );

      // Retry processPreKey with the newly trusted identity
      try {
        console.log(
          `[safeProcessPreKey] Retrying SessionBuilder.processPreKey for ${addrStr} after identity reset...`
        );
        await builder.processPreKey(bundle);
        console.log(
          `[safeProcessPreKey] Session rebuilt successfully for ${addrStr} after genuine key rotation.`
        );
      } catch (err2) {
        console.error(
          `[safeProcessPreKey] Second SessionBuilder.processPreKey FAILED for ${addrStr} even after handling rotation: ${err2.message}. Rethrowing.`,
          err2
        );
        throw err2;
      }
    } else {
      // For other errors during processPreKey (e.g., invalid bundle format)
      console.error(
        `[safeProcessPreKey] Error during SessionBuilder.processPreKey for ${addrStr} (not identity change): ${err.message}. Rethrowing.`,
        err
      );
      throw err;
    }
  }
}
// --- NEW HELPER FUNCTION --- END ---

// --- NEW HELPER FUNCTION: Only build outbound session if sender ---
async function ensureOutboundSession(store, myId, peerId, deviceId, bundle) {
  const address = new SignalProtocolAddress(peerId, deviceId);
  const hasSession = await store.containsSession(address.toString());
  // Only the SENDER should ever build a session proactively.
  if (hasSession) return;
  const builder = new SessionBuilder(store, address);
  await builder.processPreKey(bundle);
}

export default function ChatPage() {
  console.log("--- ChatPage Component Rendering ---");

  const [currentUser, setCurrentUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [conversations, setConversations] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [loadingConversations, setLoadingConversations] = useState(true);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [error, setError] = useState(null);
  const [messageSubscription, setMessageSubscription] = useState(null);
  const [isNewChatModalOpen, setIsNewChatModalOpen] = useState(false);
  const [isNewGroupModalOpen, setIsNewGroupModalOpen] = useState(false);
  const [allUsers, setAllUsers] = useState([]);
  const [selectedFile, setSelectedFile] = useState(null);
  const fileInputRef = useRef();

  // New states for button loading
  const [isRenamingGroup, setIsRenamingGroup] = useState(false);
  const [isLeavingGroup, setIsLeavingGroup] = useState(false);

  const isMobile = useMobile();
  const navigate = useNavigate();
  const messagesEndRef = useRef(null);
  const sig = useSignal();
  const { isReady, signalStore, deviceId, initializationError } = sig || {};
  const currentUserRef = useRef(currentUser);
  const selectedConversationRef = useRef(selectedConversation);

  console.log("[render] messages state length =", messages.length, messages);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // 1. Get current user and profile
  useEffect(() => {
    if (!sig) {
      console.log("[Effect 1] Signal context hook not ready, deferring.");
      return;
    }
    const fetchUserAndProfile = async () => {
      console.log("[Effect 1] Running fetchUserAndProfile...");
      setLoadingConversations(true);
      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession();
      if (sessionError) {
        console.error("Error getting session:", sessionError);
        setError("Failed to load user session.");
        setLoadingConversations(false);
        return;
      }
      if (!session?.user) {
        console.log("No user session found, redirecting to login.");
        navigate("/login");
        return;
      }
      setCurrentUser(session.user);
      if (session?.user && signalStore) {
        try {
          console.log(
            "[Effect 1] Initializing Signal protocol via context store for",
            session.user.id
          );
        } catch (initError) {
          console.error(
            "[Effect 1] Failed to initialize Signal protocol:",
            initError
          );
          setError(
            `Failed to initialize secure session keys: ${initError.message}`
          );
          setLoadingConversations(false);
          return;
        }
      }
      const { data: profileData, error: profileError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url, status")
        .eq("id", session.user.id)
        .single();
      if (profileError && profileError.code !== "PGRST116") {
        console.error("Error fetching profile:", profileError);
        setError(`Failed to load user profile: ${profileError.message}`);
      } else if (!profileData) {
        console.warn("[Effect 1] Profile not found for user:", session.user.id);
        setError("User profile not found. Please complete profile setup.");
      } else {
        setProfile(profileData);
        setError(null);
      }
    };
    fetchUserAndProfile();
  }, [navigate, sig]);

  useEffect(() => {
    currentUserRef.current = currentUser;
  }, [currentUser]);

  useEffect(() => {
    selectedConversationRef.current = selectedConversation;
  }, [selectedConversation]);

  // 2. Fetch conversations once user profile is loaded
  useEffect(() => {
    if (!profile?.id) {
      if (!loadingConversations && !profile) setLoadingConversations(false);
      return;
    }
    const fetchConversations = async () => {
      setLoadingConversations(true);
      try {
        const { data: participantData, error: participantError } =
          await supabase
            .from("conversation_participants")
            .select("conversation_id")
            .eq("profile_id", profile.id);
        if (participantError) throw participantError;
        const conversationIds = participantData.map((p) => p.conversation_id);
        if (conversationIds.length === 0) {
          setConversations([]);
          setLoadingConversations(false);
          return;
        }
        const { data: convData, error: convError } = await supabase
          .from("conversations")
          .select(
            `id, created_at, is_group, group_name, group_avatar_url, conversation_participants(profile_id, profiles(id, username, full_name, avatar_url, status))`
          )
          .in("id", conversationIds);
        if (convError) throw convError;
        const formattedConversations = convData.map((conv) => {
          const participants = conv.conversation_participants.map(
            (p) => p.profiles
          );
          const otherParticipant =
            participants.find((p) => p.id !== profile.id) || participants[0];
          const isGroup = conv.is_group;
          return {
            id: conv.id,
            name: isGroup
              ? conv.group_name || "Unnamed Group"
              : otherParticipant?.full_name ||
                otherParticipant?.username ||
                "Unknown User",
            lastMessage: "...",
            time: "",
            unread: 0,
            avatar: isGroup
              ? conv.group_avatar_url
              : otherParticipant?.avatar_url,
            participants,
            is_group: isGroup,
            group_name: conv.group_name,
            group_avatar_url: conv.group_avatar_url,
          };
        });
        setConversations(formattedConversations);
        if (!selectedConversation && formattedConversations.length > 0) {
          setSelectedConversation(formattedConversations[0]);
        } else if (formattedConversations.length === 0) {
          setSelectedConversation(null);
        }
      } catch (fetchError) {
        console.error("Error fetching conversations:", fetchError);
        setError("Failed to load conversations.");
      } finally {
        setLoadingConversations(false);
      }
    };
    fetchConversations();
  }, [profile?.id, selectedConversation]); // Keep selectedConversation here to re-evaluate if it changes elsewhere

  // 3. Fetch messages when selectedConversation changes
  useEffect(() => {
    if (!isReady) {
      console.log(
        "[Effect 3] Signal context not ready, deferring message fetch."
      );
      setMessages([]);
      return;
    }
    const { signalStore } = sig;
    if (!selectedConversation?.id || !currentUser?.id) {
      setMessages([]);
      return;
    }
    const recipientParticipant = selectedConversation.participants.find(
      (p) => p.id !== currentUser.id
    );
    if (!recipientParticipant) {
      setError("Error identifying recipient.");
      setMessages([]);
      setLoadingMessages(false);
      return;
    }
    const fetchMessagesAndEnsureSession = async () => {
      setLoadingMessages(true);
      setError(null);
      try {
        // --- FIX 2: Targeted Message Fetching ---
        const { data, error: messagesError } = await supabase
          .from("messages")
          .select(
            `id, body, type, created_at, profile_id, device_id, target_device_id, profiles ( id, full_name, username, avatar_url )`
          )
          .eq("conversation_id", selectedConversation.id)
          // Fetch messages TO this device OR FROM this user (own messages)
          // --- FIX: Correct PostgREST .or() filter --- START ---
          .or(`target_device_id.eq.${deviceId},profile_id.eq.${currentUser.id}`)
          // --- FIX: Correct PostgREST .or() filter --- END ---
          .order("created_at", { ascending: true });
        console.log("[FetchMessages] raw rows after filtering:", data);
        // --- END FIX 2 ---

        if (messagesError) throw messagesError;
        const decryptedMessages = [];
        for (const msg of data) {
          // --- FIX: Deduplicate messages before decrypting --- START ---
          // Check if this message ID already exists in the current state
          // Use a check against the `messages` state directly before processing.
          // Note: This assumes `messages` state reflects messages successfully processed so far.
          if (messages.some((m) => m.id === msg.id)) {
            console.log(
              `[FetchMessages] Skipping msg ${msg.id} - already processed.`
            );
            continue; // Skip to the next message
          }
          // Alternative check: Check against the temporary `decryptedMessages` array being built,
          // if multiple rows for the same logical message might exist in `data` (less likely with correct filtering)
          // if (decryptedMessages.some(dm => dm.id === msg.id)) {
          //   console.log(`[FetchMessages] Skipping msg ${msg.id} - duplicate row in fetch results.`);
          //   continue;
          // }
          // --- FIX: Deduplicate messages before decrypting --- END ---

          let processedContent = null;
          const senderProfile = msg.profiles;
          const timestamp = msg.created_at
            ? new Date(msg.created_at).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              })
            : "";
          const isSelfSent = msg.profile_id === currentUser.id;
          const myCurrentDeviceId = deviceId;
          if (
            !isSelfSent &&
            msg.target_device_id !== undefined &&
            msg.target_device_id !== null &&
            msg.target_device_id !== myCurrentDeviceId
          ) {
            continue;
          }
          // --- Namespacing: Pass userId to getCachedMessageContent --- START ---
          const cachedContent = await getCachedMessageContent(
            currentUser.id,
            msg.id
          );
          // --- Namespacing: Pass userId to getCachedMessageContent --- END ---
          if (cachedContent) {
            processedContent = cachedContent;
          } else {
            if (isSelfSent) {
              processedContent = "[Self, Uncached - Error]";
            } else {
              // --- FIX: Do NOT preemptively build session for type 3 (PreKeyWhisper) messages ---
              const dbHexString = msg.body;
              let bodyUint8Array;
              try {
                bodyUint8Array = hexToUint8Array(dbHexString);
              } catch (e) {
                console.error(
                  `[Effect 3] Hex conversion error for msg ${msg.id}:`,
                  e
                );
                processedContent = "[DB Body Corrupt]";
                decryptedMessages.push({
                  id: msg.id,
                  senderId: senderProfile?.id || msg.profile_id,
                  senderName:
                    senderProfile?.full_name ||
                    senderProfile?.username ||
                    "Unknown User",
                  senderAvatar: senderProfile?.avatar_url,
                  content: processedContent,
                  timestamp,
                  isSelf: false,
                });
                continue;
              }
              if (bodyUint8Array) {
                const senderDeviceIdNum = Number(msg.device_id || 1);
                const addr = new SignalProtocolAddress(
                  msg.profile_id,
                  senderDeviceIdNum
                );
                const addrStr = addr.toString();
                try {
                  // For type 3, let libsignal handle session creation on decrypt
                  const plaintextBuffer = await decryptMessage(
                    signalStore,
                    currentUser.id, // myUserId
                    myCurrentDeviceId, // myDeviceId
                    msg.profile_id, // theirUserId
                    senderDeviceIdNum, // theirDeviceId
                    { type: msg.type, body: bodyUint8Array }
                  );
                  if (plaintextBuffer) {
                    processedContent = arrayBufferToString(plaintextBuffer);
                    // --- Namespacing: Pass userId to cacheSentMessage --- START ---
                    await cacheSentMessage(currentUser.id, {
                      id: msg.id,
                      content: processedContent,
                      conversationId: selectedConversation.id,
                      timestamp: msg.created_at,
                    });
                    // --- Namespacing: Pass userId to cacheSentMessage --- END ---
                  } else {
                    processedContent = "[Decryption Failed - No Buffer]";
                  }
                } catch (decryptionError) {
                  // Handle duplicate prekey decryption gracefully
                  if (
                    decryptionError.message?.toLowerCase().includes("duplicate")
                  ) {
                    console.warn(
                      `[FetchMessages] Duplicate prekey message for ${addrStr} (msg ID: ${msg.id}), ignoring.`
                    );
                    continue;
                  }
                  // --- FIX 3: Improved Bad MAC Handling ---
                  // Check if it's a BadMacError specifically for PreKey messages (type 3)
                  // Note: You might need to adjust how BadMacError is detected depending on libsignal's exact error object structure
                  if (
                    decryptionError.message?.includes("Bad MAC") &&
                    msg.type === 3
                  ) {
                    console.warn(
                      `[FetchMessages] Bad MAC for PreKeyWhisperMessage ${addrStr} (msg ID: ${msg.id}). Likely wrong key/device or duplicate. Ignoring.`
                    );
                    // Instead of full recovery, just mark as failed/skip
                    processedContent =
                      "[Decryption Failed - Bad MAC / Wrong Key]";
                    // Or simply 'continue;' if you don't want to show anything
                  }
                  // --- END FIX 3 ---
                  // Keep recovery for other errors, but maybe only if session exists?
                  // Example: Keep recovery attempt for other potential errors if a session WAS expected
                  // The original "Bad MAC" recovery logic is now conditional
                  else if (decryptionError.message?.includes("Bad MAC")) {
                    // This block handles Bad MAC for non-PreKey messages (less common, might indicate actual corruption/ratchet issue)
                    // Or it handles the case where we decided *not* to simply ignore the PreKey Bad MAC above
                    console.warn(
                      `[FetchMessages Recover] Bad MAC detected for ${addrStr} (msg ID: ${msg.id}), attempting session reset and retry (Original Logic)...`
                    );
                    try {
                      await signalStore.removeSession(addrStr);
                      console.log(
                        `[FetchMessages Recover] Removed session for ${addrStr}.`
                      );
                      const peerBundlesData = await get(
                        `/signal/bundles/${msg.profile_id}`
                      );
                      if (!peerBundlesData || !Array.isArray(peerBundlesData)) {
                        throw new Error(
                          `[FetchMessages Recover] No valid bundles array found for peer ${msg.profile_id}.`
                        );
                      }
                      const bundleMap = bundlesToMap(peerBundlesData);
                      const bundleForDevice = bundleMap.get(senderDeviceIdNum);
                      if (!bundleForDevice) {
                        throw new Error(
                          `[FetchMessages Recover] Bundle not found for ${addrStr} (Device ID: ${senderDeviceIdNum}) after fetching.`
                        );
                      }
                      console.log(
                        `[FetchMessages Recover] Fetched bundle for ${addrStr}.`
                      );
                      await safeProcessPreKey(
                        signalStore,
                        msg.profile_id,
                        senderDeviceIdNum,
                        bundleForDevice
                      );
                      console.log(
                        `[FetchMessages Recover] Session rebuilt for ${addrStr} via safeProcessPreKey.`
                      );
                      const plaintextBufferRetry = await decryptMessage(
                        signalStore,
                        currentUser.id, // myUserId
                        myCurrentDeviceId, // myDeviceId
                        msg.profile_id, // theirUserId
                        senderDeviceIdNum, // theirDeviceId
                        { type: msg.type, body: bodyUint8Array }
                      );
                      if (plaintextBufferRetry) {
                        processedContent =
                          arrayBufferToString(plaintextBufferRetry);
                        // --- Namespacing: Pass userId to cacheSentMessage --- START ---
                        await cacheSentMessage(currentUser.id, {
                          id: msg.id,
                          content: processedContent, // --- FIX 4: Ensure caching after successful retry ---
                          conversationId: selectedConversation.id,
                          timestamp: msg.created_at,
                        });
                        // --- Namespacing: Pass userId to cacheSentMessage --- END ---
                        console.log(
                          `[FetchMessages Recover] Decryption successful for ${addrStr} after retry.`
                        );
                      } else {
                        processedContent =
                          "[Decryption Failed After Retry - No Buffer]";
                        console.warn(
                          `[FetchMessages Recover] Decryption for ${addrStr} still failed after retry (no buffer).`
                        );
                      }
                    } catch (recoveryError) {
                      console.error(
                        `[FetchMessages Recover] Error during recovery for ${addrStr}: ${recoveryError.message}`,
                        recoveryError
                      );
                      processedContent =
                        "[Decryption Error After Recovery Attempt]";
                    }
                  } else {
                    // For errors other than "Bad MAC"
                    console.error(
                      `[Effect 3] Decryption error for msg ${msg.id} (not Bad MAC):`,
                      decryptionError
                    );
                    processedContent = "[Decryption Error - Other]";
                  }
                }
              } else {
                // This case handles when bodyUint8Array is null/undefined
                console.warn(
                  `[Effect 3] Skipping msg ${msg.id} due to missing bodyUint8Array.`
                );
                // Optionally add a placeholder message or just skip
                processedContent = "[Message Body Missing/Invalid]";
                // We need to push something to maintain message order, or `continue;` to skip entirely.
                // Let's push the error message for now.
              }
            }
          }
          decryptedMessages.push({
            id: msg.id,
            senderId: senderProfile?.id || msg.profile_id,
            senderName:
              senderProfile?.full_name ||
              senderProfile?.username ||
              (isSelfSent ? "Me" : "Unknown User"),
            senderAvatar: senderProfile?.avatar_url,
            content: processedContent,
            timestamp,
            isSelf: isSelfSent,
          });
        }
        setMessages(decryptedMessages);
      } catch (err) {
        setError(`Failed to load messages: ${err.message}`);
        setMessages([]);
      } finally {
        setLoadingMessages(false);
      }
    };
    fetchMessagesAndEnsureSession();
  }, [selectedConversation?.id, currentUser?.id, sig, isReady]);

  // 4. Scroll to bottom
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Define handleNewMessage in the component scope
  const handleNewMessage = async (payload) => {
    // Use refs for currentUser and selectedConversation to get latest values
    const currentUserService = currentUserRef.current;
    const selectedConversationService = selectedConversationRef.current;

    if (!isReady || !sig) {
      console.warn(
        "[Realtime HNM] Context not ready or sig not available. Skipping message."
      );
      return;
    }
    const {
      signalStore: currentSignalStore,
      deviceId: myCurrentDeviceIdFromContext,
    } = sig;
    const currentUserId = currentUserService?.id;

    if (!currentUserId) {
      console.warn(
        "[Realtime HNM] currentUser.id is not available. Skipping message."
      );
      return;
    }

    const { new: newMessageData } = payload;

    if (
      !selectedConversationService ||
      newMessageData.conversation_id !== selectedConversationService.id
    ) {
      console.log(
        "[Realtime HNM] Message for different or no selected conversation. Skipping."
      );
      return;
    }

    if (newMessageData.profile_id === currentUserId) {
      console.log("[Realtime HNM] Message is from self. Skipping.");
      return;
    }

    // Log and compare device IDs, coercing to string for comparison
    console.log(
      `[Realtime HNM] Comparing device IDs: incoming.target_device_id = ${
        newMessageData.target_device_id
      } (type: ${typeof newMessageData.target_device_id}), myCurrentDeviceId = ${myCurrentDeviceIdFromContext} (type: ${typeof myCurrentDeviceIdFromContext})`
    );

    // --- FIX 2b: Realtime Device ID Filter ---
    // Use the same logic as the main fetch query filter (check target OR self-sent)
    // Although this handler is specifically for non-self messages, double-check target_device_id
    if (
      newMessageData.target_device_id !== undefined &&
      newMessageData.target_device_id !== null && // Keep null check
      String(newMessageData.target_device_id) !==
        String(myCurrentDeviceIdFromContext)
    ) {
      console.log(
        `[Realtime HNM] Message not for this deviceId (Target: ${String(
          newMessageData.target_device_id
        )}, Mine: ${String(myCurrentDeviceIdFromContext)}). Skipping.`
      );
      return;
    }
    // --- END FIX 2b ---

    if (messages.some((msg) => msg.id === newMessageData.id)) {
      console.log(
        `[Realtime HNM] Message ${newMessageData.id} already exists. Skipping.`
      );
      return;
    }

    const senderAddress = new SignalProtocolAddress(
      newMessageData.profile_id,
      newMessageData.device_id || 1
    );
    const senderAddressString = senderAddress.toString();

    // --- FIX: Do NOT preemptively build session for type 3 (PreKeyWhisper) messages ---
    // Let libsignal handle session creation on decrypt

    const { data: senderProfile } = await supabase
      .from("profiles")
      .select("id, full_name, username, avatar_url")
      .eq("id", newMessageData.profile_id)
      .single();

    let bodyUint8Array;
    try {
      bodyUint8Array = hexToUint8Array(newMessageData.body);
    } catch (conversionError) {
      console.error(
        `[Realtime HNM] Hex conversion error for msg ${newMessageData.id}:`,
        conversionError
      );
      return;
    }
    if (!bodyUint8Array) {
      console.warn("[Realtime HNM] bodyUint8Array is null after conversion.");
      return;
    }

    const ciphertextForDecryption = {
      type: newMessageData.type,
      body: bodyUint8Array,
    };

    let plaintextBuffer;
    try {
      plaintextBuffer = await decryptMessage(
        currentSignalStore,
        currentUserId, // myUserId
        myCurrentDeviceIdFromContext, // myDeviceId
        newMessageData.profile_id, // theirUserId
        newMessageData.device_id || 1, // theirDeviceId
        ciphertextForDecryption
      );
    } catch (e) {
      // Handle duplicate prekey decryption gracefully
      if (e.message?.toLowerCase().includes("duplicate")) {
        console.warn(
          `[Realtime HNM] Duplicate prekey message for ${senderAddressString} (msg ID: ${newMessageData.id}), ignoring.`
        );
        return;
      }
      // --- FIX 3b: Improved Bad MAC Handling (Realtime) ---
      // Check if it's a BadMacError specifically for PreKey messages (type 3)
      if (e.message?.includes("Bad MAC") && newMessageData.type === 3) {
        console.warn(
          `[Realtime HNM] Bad MAC for PreKeyWhisperMessage ${senderAddressString} (msg ID: ${newMessageData.id}). Likely wrong key/device or duplicate. Ignoring.`
        );
        return; // Don't proceed, don't show error in UI
      }
      // --- END FIX 3b ---

      console.error("[Realtime HNM] Decryption error (other):", e);
      // Maybe show a temporary error or just log and return
      // For now, just return to avoid adding a broken message
      return;
    }
    if (!plaintextBuffer) {
      console.warn("[Realtime HNM] Decryption returned null.");
      return;
    }
    const plaintext = arrayBufferToString(plaintextBuffer);
    // Ensure selectedConversation is still valid before caching
    // --- FIX 4b: Ensure Caching (Realtime) ---
    if (
      selectedConversationService &&
      selectedConversationService.id === newMessageData.conversation_id
    ) {
      // --- Namespacing: Pass userId to cacheSentMessage --- START ---
      await cacheSentMessage(
        currentUserId, // Pass currentUserId
        {
          id: newMessageData.id,
          content: plaintext,
          conversationId: selectedConversationService.id,
          timestamp: newMessageData.created_at,
        }
      );
      // --- Namespacing: Pass userId to cacheSentMessage --- END ---
    }
    // --- END FIX 4b ---

    const formatted = {
      id: newMessageData.id,
      senderId: senderProfile?.id || newMessageData.profile_id,
      senderName:
        senderProfile?.full_name || senderProfile?.username || "Unknown",
      senderAvatar: senderProfile?.avatar_url,
      content: plaintext,
      timestamp: new Date(newMessageData.created_at).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
      isSelf: false, // Realtime messages are never from self in this handler
    };
    setMessages((prevMessages) => {
      // Check for duplicates again with prevMessages to be absolutely sure
      if (prevMessages.some((msg) => msg.id === formatted.id)) {
        return prevMessages;
      }
      return [...prevMessages, formatted];
    });
  };

  // 5. Realtime subscription
  useEffect(() => {
    if (!isReady || !selectedConversation?.id) {
      return;
    }

    if (messageSubscription) {
      console.log(
        `[Realtime Effect] Explicitly unsubscribing existing messageSubscription (topic: ${messageSubscription.topic}) before creating new one for conv ${selectedConversation.id}.`
      );
      messageSubscription.unsubscribe();
    }

    console.log(
      `[Realtime Effect] Setting up subscription for conversation: ${selectedConversation.id}`
    );
    const chan = supabase
      .channel(`messages:${selectedConversation.id}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
          filter: `conversation_id=eq.${selectedConversation.id}`,
        },
        handleNewMessage // Now correctly references the function in component scope
      )
      .subscribe((status, err) => {
        if (err) {
          console.error(
            `[Realtime] SUBSCRIBE ERROR for conv ${selectedConversation.id}:`,
            err
          );
        } else {
          console.log(
            `[Realtime] Subscription status for conv ${selectedConversation.id}: ${status}`
          );
        }
      });

    setMessageSubscription(chan);

    return () => {
      console.log(
        `[Realtime Effect Cleanup] Unsubscribing channel for conv ${selectedConversation?.id} (channel topic: ${chan.topic})`
      );
      chan.unsubscribe();
    };
  }, [selectedConversation?.id, isReady]);

  const handleSendMessage = async () => {
    if (!isReady) {
      setError("Secure session not ready.");
      return;
    }
    if (
      (!newMessage.trim() && !selectedFile) ||
      !selectedConversation ||
      !currentUser ||
      deviceId === null
    )
      return;

    const { signalStore, deviceId: myDeviceId } = sig;
    const conversationId = selectedConversation.id;
    const profileId = currentUser.id;
    const originalNewMessage = newMessage;

    let contentToProcess = newMessage.trim();
    if (selectedFile) {
      const fileMarker = `[File] ${selectedFile.name}`;
      if (contentToProcess) {
        contentToProcess = `${contentToProcess} ${fileMarker}`;
      } else {
        contentToProcess = fileMarker;
      }
    }

    let successfullySentToAtLeastOneDevice = false;
    let lastInsertedMessageDataForUI = null;
    setError(null); // Clear previous errors

    try {
      const peers = selectedConversation.participants.filter(
        (p) => p.id !== profileId
      );
      if (peers.length === 0) {
        throw new Error("No other participants found in this conversation.");
      }

      const plaintextBytes = new TextEncoder().encode(contentToProcess);

      for (const peer of peers) {
        console.log(`[SendMessage] Processing peer: ${peer.id}`);

        // DEBUGGING BLOCK START
        if (peer.id === "d2fbdbb5-38d1-4d89-8321-ce28ea0fe22f") {
          console.log(`[DEBUG] Checking stored identities for peer ${peer.id}`);
          try {
            const addr79Str = new SignalProtocolAddress(peer.id, 79).toString();
            const key79 = await signalStore.loadIdentityKey(addr79Str);
            console.log(
              "[DEBUG] Stored identityKey for device #79:",
              key79 ? buf2hex(key79) : "null or undefined"
            );

            const addr80Str = new SignalProtocolAddress(peer.id, 80).toString();
            const key80 = await signalStore.loadIdentityKey(addr80Str);
            console.log(
              "[DEBUG] Stored identityKey for device #80:",
              key80 ? buf2hex(key80) : "null or undefined"
            );
          } catch (e) {
            console.error(
              "[DEBUG] Error loading identity keys for debugging:",
              e
            );
          }
        }
        // DEBUGGING BLOCK END

        try {
          const peerBundlesData = await get(`/signal/bundles/${peer.id}`);

          // ---- INSTRUMENTATION START ----
          console.log(`[Signal] 📥 Fetched bundles for peer ${peer.id}:`, {
            count: peerBundlesData?.length || 0,
            deviceIds: Array.isArray(peerBundlesData)
              ? peerBundlesData.map((b) => b.deviceId)
              : "Not an array or undefined",
            rawData: peerBundlesData,
          });
          // ---- INSTRUMENTATION END ----

          if (!peerBundlesData || !Array.isArray(peerBundlesData)) {
            console.warn(`No key bundles found for peer ${peer.id}. Skipping.`);
            continue; // Skip to the next peer
          }
          const bundleMap = bundlesToMap(peerBundlesData);
          if (bundleMap.size === 0) {
            console.warn(
              `No pre-key bundle published for ${peer.id}. Skipping.`
            );
            continue; // Skip to the next peer
          }

          // DEBUGGING BLOCK FOR BUNDLE KEYS (START)
          if (peer.id === "d2fbdbb5-38d1-4d89-8321-ce28ea0fe22f") {
            console.log(
              `[DEBUG] Checking bundle identityKeys for peer ${peer.id}`
            );
            const b79 = bundleMap.get(79);
            const b80 = bundleMap.get(80);

            if (b79 && b79.identityKey) {
              console.log(
                "[DEBUG] Bundle identityKey for #79:",
                buf2hex(new Uint8Array(b79.identityKey))
              );
              console.log("[DEBUG] Full bundle #79:", b79);
            } else {
              console.log(
                "[DEBUG] Bundle for #79 not found or has no identityKey."
              );
            }

            if (b80 && b80.identityKey) {
              console.log(
                "[DEBUG] Bundle identityKey for #80:",
                buf2hex(new Uint8Array(b80.identityKey))
              );
              console.log("[DEBUG] Full bundle #80:", b80);
            } else {
              console.log(
                "[DEBUG] Bundle for #80 not found or has no identityKey."
              );
            }
          }
          // DEBUGGING BLOCK FOR BUNDLE KEYS (END)

          for (const [peerDeviceId, preKeyBundleForDevice] of bundleMap) {
            const addr = new SignalProtocolAddress(peer.id, peerDeviceId);
            const addrStr = addr.toString();
            console.log(`[SendMessage] Processing device: ${addrStr}`);

            try {
              // --- FIX 5: Sender Sanity Check ---
              if (preKeyBundleForDevice.deviceId !== peerDeviceId) {
                console.error(
                  `[SendMessage SANITY FAIL] Mismatch! Bundle deviceId (${preKeyBundleForDevice.deviceId}) !== loop peerDeviceId (${peerDeviceId}) for peer ${peer.id}. Skipping device.`
                );
                continue; // Skip this device, something is wrong upstream
              }
              // --- END FIX 5 ---

              // --- FIX: Sender-Side Identity Safeguard --- START ---
              // Check if the identity key we are about to use for encryption is trusted.
              const identityKeyFromBundle = preKeyBundleForDevice.identityKey; // Already ArrayBuffer
              const isTrusted = await signalStore.isTrustedIdentity(
                addrStr,
                identityKeyFromBundle
              );

              if (!isTrusted) {
                console.warn(
                  `[SendMessage] Identity key in fetched bundle for ${addrStr} is NOT trusted. This might be a stale bundle. Removing old session/identity and trusting the key from THIS bundle before proceeding.`
                );
                await signalStore.removeSession(addrStr); // Remove session based on old identity
                // Ensure removeIdentity function exists before calling
                if (typeof signalStore.removeIdentity === "function") {
                  await signalStore.removeIdentity(addrStr); // Remove the old (potentially wrong) trusted identity
                  console.log(
                    `[SendMessage] Removed old identity for ${addrStr}.`
                  );
                } else {
                  console.warn(
                    `[SendMessage] store.removeIdentity not found, cannot explicitly remove old identity for ${addrStr}. Overwriting.`
                  );
                }
                // Save the identity from the bundle we are about to use.
                await signalStore.saveIdentity(addrStr, identityKeyFromBundle);
                console.log(
                  `[SendMessage] Saved new identity for ${addrStr} from bundle.`
                );
                // Session will be built implicitly by encryptMessage now using the newly trusted key.
                // We could explicitly call ensureOutboundSession here again, but encrypt should handle it.
              }
              // --- FIX: Sender-Side Identity Safeguard --- END ---

              // 1) Ensure identity and session are in sync *before* attempting encryption.
              // Only the SENDER should ever build a session proactively.
              console.log(
                `[SendMessage] Ensuring outbound session for ${addrStr} via ensureOutboundSession...`
              );
              await ensureOutboundSession(
                signalStore,
                profile.id,
                peer.id,
                peerDeviceId,
                preKeyBundleForDevice
              );
              console.log(
                `[SendMessage] Outbound session ensured for ${addrStr}. Proceeding to encrypt.`
              );

              // 2) Now encrypt exactly once.
              // No complex retry logic around encryptMessage here, as safeProcessPreKey should have prepared the session.
              const ct = await encryptMessage(
                signalStore,
                peer.id,
                peerDeviceId,
                plaintextBytes.buffer
              );

              if (!ct) {
                // This case should be rare if safeProcessPreKey succeeded and encryptMessage didn't throw,
                // but check just in case encryptMessage could return null without throwing for some reason.
                console.warn(
                  `[SendMessage] Ciphertext (ct) is undefined for ${addrStr} after encryptMessage, though no error was thrown. Skipping DB insert.`
                );
                continue;
              }

              // 3) Convert to hex & insert into DB as before
              const bodyUint8Array = Uint8Array.from(ct.body, (c) =>
                c.charCodeAt(0)
              );
              const pgByteaLiteral = `\\x${buf2hex(bodyUint8Array)}`;

              const messageToInsert = {
                conversation_id: conversationId,
                profile_id: profileId,
                type: ct.type,
                body: pgByteaLiteral,
                device_id: myDeviceId,
                target_device_id: peerDeviceId,
              };

              console.log(
                `[SendMessage] RAW INSERT ATTEMPT for ${addrStr}. Payload:`,
                JSON.stringify(messageToInsert)
              );

              let insertResult;
              try {
                insertResult = await supabase
                  .from("messages")
                  .insert(messageToInsert)
                  .select();
                console.log(
                  `[SendMessage] RAW INSERT SUCCEEDED for ${addrStr}. Response:`,
                  JSON.stringify(insertResult)
                );
              } catch (rawInsertError) {
                console.error(
                  `[SendMessage] RAW INSERT FAILED for ${addrStr} (exception during await):`,
                  rawInsertError
                );
                setError(
                  `DEBUG: Raw insert failed for ${addrStr}: ${rawInsertError.message}`
                );
                continue; // Skip to next device
              }

              const { data: insertedData, error: dbErr } = insertResult || {
                data: null,
                error: null,
              };

              if (dbErr) {
                console.error(
                  `[SendMessage] DB insert failed for ${addrStr} (from insertResult.error):`,
                  dbErr
                );
                // Optionally set an error state for the user, or retry specific errors
                // For now, just log and continue to the next device/peer
                continue; // Continue to the next device/peer
              }

              if (insertedData && insertedData.length > 0) {
                lastInsertedMessageDataForUI = insertedData[0];
                successfullySentToAtLeastOneDevice = true;
                console.log(`[SendMessage] Successfully sent to ${addrStr}.`);
              } else {
                // This case might indicate a successful insert but no returned data, which could be an issue.
                console.warn(
                  `[SendMessage] DB insert for ${addrStr} reported success but returned no data.`
                );
              }
            } catch (deviceProcessingError) {
              // This catch block now handles errors from safeProcessPreKey (if it re-throws) or the single encryptMessage attempt.
              console.error(
                `[SendMessage] Error processing device ${addrStr}: ${deviceProcessingError.message}. Skipping device.`,
                deviceProcessingError
              );
              continue; // To next device/peer
            } // End try-catch for a single device
          } // End for...of bundleMap (devices for a peer)
        } catch (peerProcessingError) {
          // Errors like failing to fetch bundles for a peer
          console.error(
            `[SendMessage] Error processing peer ${peer.id}: ${peerProcessingError.message}. Skipping peer.`,
            peerProcessingError
          );
          continue; // Skip to the next peer
        }
      } // End for...of peers

      if (successfullySentToAtLeastOneDevice && lastInsertedMessageDataForUI) {
        const newMessageForUI = {
          id: lastInsertedMessageDataForUI.id, // Use the ID from the last successful insert
          senderId: profileId,
          senderName: profile?.full_name || profile?.username || "Me",
          senderAvatar: profile?.avatar_url,
          content: contentToProcess, // The original plaintext content
          timestamp: new Date(
            lastInsertedMessageDataForUI.created_at
          ).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
          isSelf: true,
        };
        setMessages((prevMessages) => [...prevMessages, newMessageForUI]);
        // --- Namespacing: Pass userId to cacheSentMessage --- START ---
        await cacheSentMessage(
          profileId, // Pass current user ID
          { ...newMessageForUI, conversationId }
        );
        // --- Namespacing: Pass userId to cacheSentMessage --- END ---
        setNewMessage("");
        setSelectedFile(null);
        setError(null); // Clear any general error if successful
      } else {
        // This error will be set if the message wasn't sent to *any* device of *any* peer
        throw new Error("Failed to send message to any recipient device.");
      }
    } catch (err) {
      // General errors (e.g., no peers, or if all sends failed and threw the error above)
      console.error("[SendMessage] Overall error:", err);
      setError(`Failed to send message: ${err.message}`);
      setNewMessage(originalNewMessage); // Restore original message on total failure
    }
  };

  const handleFileSelect = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const maxSizeMB = 10;
    if (file.size > maxSizeMB * 1024 * 1024) {
      alert(`File size exceeds ${maxSizeMB}MB limit.`);
      return;
    }

    setSelectedFile(file);
  };

  const handleLogout = async () => {
    // First, sign out from Supabase auth
    const { error: signOutError } = await supabase.auth.signOut();
    if (signOutError) {
      console.error("Error signing out from Supabase:", signOutError);
      // Optionally, you might want to display this error to the user
      // For now, we'll proceed to try clearing local stores anyway
    }

    // Clear localStorage - this should remove the deviceId and any auth tokens.
    // Note: Only clears items for the current origin.
    // We are NOT attempting to delete the namespaced IndexedDB here,
    // as it's complex and prone to 'blocked' errors.
    // User can manually clear site data if needed.
    try {
      console.log("[Logout] Clearing localStorage...");
      localStorage.clear();
      console.log("[Logout] localStorage cleared.");
    } catch (e) {
      console.error("[Logout] Error clearing localStorage:", e);
    }

    // Finally, navigate to login page
    navigate("/login");
  };

  const handleUserSelect = async (selectedUser) => {
    console.log("Selected user to start chat with:", selectedUser);
    if (!currentUser || !profile) {
      console.error("Current user or profile not loaded.");
      return;
    }
    if (selectedUser.id === currentUser.id) {
      console.warn("Cannot start chat with self.");
      return;
    }

    setIsNewChatModalOpen(false); // Close modal immediately

    try {
      // 1. Check if a conversation already exists
      const existingConversation = conversations.find((conv) => {
        // Check if participants array exists and has exactly 2 participants (for 1-on-1 chat)
        // Adjust this logic if group chats need different handling
        if (!conv.participants || conv.participants.length !== 2) return false;
        // Check if both currentUser and selectedUser are participants
        const hasCurrentUser = conv.participants.some(
          (p) => p.id === currentUser.id
        );
        const hasSelectedUser = conv.participants.some(
          (p) => p.id === selectedUser.id
        );
        return hasCurrentUser && hasSelectedUser;
      });

      if (existingConversation) {
        console.log("Found existing conversation:", existingConversation);
        setSelectedConversation(existingConversation);
      } else {
        console.log("No existing conversation found, creating new one...");
        // 2. Create New Conversation
        const { data: newConvData, error: convInsertError } = await supabase
          .from("conversations")
          .insert({})
          .select()
          .single();

        if (convInsertError) throw convInsertError;
        const newConversationId = newConvData.id;
        console.log("Created new conversation with ID:", newConversationId);

        // 3. Add Participants
        const { error: participantInsertError } = await supabase
          .from("conversation_participants")
          .insert([
            { conversation_id: newConversationId, profile_id: currentUser.id },
            { conversation_id: newConversationId, profile_id: selectedUser.id },
          ]);

        if (participantInsertError) throw participantInsertError;
        console.log("Added participants to new conversation.");

        // 4. Construct new conversation object for UI state
        const newConversationForState = {
          id: newConversationId,
          name: selectedUser.full_name || selectedUser.username, // Use selected user's name for 1-on-1
          lastMessage: "", // No messages yet
          time: "",
          unread: 0,
          avatar: selectedUser.avatar_url, // Use selected user's avatar
          participants: [
            {
              // Current user's profile
              id: profile.id,
              username: profile.username,
              full_name: profile.full_name,
              avatar_url: profile.avatar_url,
              status: profile.status,
            },
            {
              // Selected user's profile (from modal data)
              id: selectedUser.id,
              username: selectedUser.username,
              full_name: selectedUser.full_name,
              avatar_url: selectedUser.avatar_url,
              status: "offline", // Assume offline initially, status updates needed separately
            },
          ],
          is_group: false, // New 1-on-1 chats are not groups
          group_name: null,
          group_avatar_url: null,
        };

        // 5. Update State
        setConversations((prev) => [newConversationForState, ...prev]); // Add to beginning
        setSelectedConversation(newConversationForState);
        console.log(
          "Set new conversation as selected:",
          newConversationForState
        );
      }
    } catch (err) {
      console.error("Error starting chat:", err);
      setError("Failed to start chat. " + err.message);
    }
  };

  // Effect to fetch all users for the NewGroupModal
  useEffect(() => {
    const fetchAllUsers = async () => {
      if (!currentUser?.id) return;
      try {
        const { data, error: fetchUsersError } = await supabase
          .from("profiles")
          .select("id, username, full_name, avatar_url")
          .neq("id", currentUser.id); // Exclude current user from the list

        if (fetchUsersError) throw fetchUsersError;
        setAllUsers(data || []);
      } catch (err) {
        console.error("Error fetching all users:", err);
        setError("Failed to load users for group creation.");
        setAllUsers([]); // Ensure allUsers is an empty array on error
      }
    };

    fetchAllUsers();
  }, [currentUser?.id]);

  const handleCreateGroup = async ({ name: groupName, memberIds }) => {
    if (!currentUser || !profile) {
      setError("Current user or profile not loaded. Cannot create group.");
      return;
    }
    if (!groupName || memberIds.length === 0) {
      setError("Group name and at least one member are required.");
      return;
    }

    setIsNewGroupModalOpen(false); // Close modal immediately
    setLoadingConversations(true); // Indicate loading for sidebar update
    setError(null);

    try {
      // 1. Create a conversation row with is_group: true
      const { data: convData, error: convInsertError } = await supabase
        .from("conversations")
        .insert({ is_group: true, group_name: groupName })
        .select()
        .single();

      if (convInsertError) throw convInsertError;
      const newConversationId = convData.id;

      // 2. Add all selected users + yourself as participants
      const participantObjects = memberIds.map((id) => ({
        conversation_id: newConversationId,
        profile_id: id,
      }));
      participantObjects.push({
        conversation_id: newConversationId,
        profile_id: currentUser.id,
      });

      const { error: participantInsertError } = await supabase
        .from("conversation_participants")
        .insert(participantObjects);

      if (participantInsertError) throw participantInsertError;

      // 3. Construct new group object for UI state (fetch full participant profiles)
      // For simplicity now, we'll use the IDs and current user's profile.
      // A more robust solution would fetch all participant profiles here.
      const groupParticipantsProfiles = [
        profile, // Current user's profile
        ...allUsers.filter((u) => memberIds.includes(u.id)),
      ];

      const newGroupForState = {
        id: newConversationId,
        name: groupName, // Sidebar name will be group name
        lastMessage: "Group created",
        time: new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
        unread: 0,
        avatar: null, // Placeholder for group avatar, using default
        participants: groupParticipantsProfiles,
        is_group: true,
        group_name: groupName,
        group_avatar_url: null, // Default group avatar
      };

      // 4. Update State
      setConversations((prev) => [newGroupForState, ...prev]);
      setSelectedConversation(newGroupForState);
      setError(null);
    } catch (err) {
      console.error("Error creating group:", err);
      setError(`Failed to create group: ${err.message}`);
    } finally {
      setLoadingConversations(false);
    }
  };

  // --- Conditional Return for loading Signal context OR other states ---
  if (initializationError) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-red-400">
        Error initializing secure session: {initializationError}
      </div>
    );
  }
  if (!isReady) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-white">
        Initializing secure session...
      </div>
    );
  }
  if (error && !initializationError) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-red-400">
        Error: {error}
      </div>
    );
  }

  // Main component JSX, ensure sig.deviceId is used where myDeviceIdForJSX was used
  return (
    <div className="flex h-screen bg-slate-900">
      {/* Sidebar - Chat List */}
      {(!isMobile || isMobileMenuOpen) && (
        <AnimatePresence>
          <div
            className={`${
              isMobile ? "absolute z-10 w-full max-w-xs" : "w-80"
            } h-full bg-slate-800 border-r border-slate-700 flex flex-col`}
          >
            {/* Header */}
            <div className="p-4 border-b border-slate-700 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <MessageSquare className="h-5 w-5 text-emerald-400" />
                <h1 className="font-bold text-white">Messages</h1>
              </div>
              <div className="flex gap-1">
                <Dialog
                  open={isNewChatModalOpen}
                  onOpenChange={setIsNewChatModalOpen}
                >
                  <DialogTrigger asChild>
                    <Button
                      variant="ghost"
                      size="icon"
                      title="Start new 1-on-1 chat"
                      className="text-slate-400 hover:text-white"
                    >
                      <Plus className="h-5 w-5" />
                    </Button>
                  </DialogTrigger>
                  <NewChatModal
                    currentUser={currentUser}
                    onUserSelect={handleUserSelect}
                    onOpenChange={setIsNewChatModalOpen}
                  />
                </Dialog>
                <Dialog
                  open={isNewGroupModalOpen}
                  onOpenChange={setIsNewGroupModalOpen}
                >
                  <DialogTrigger asChild>
                    <Button
                      variant="ghost"
                      size="icon"
                      title="Create new group chat"
                      className="text-slate-400 hover:text-white"
                    >
                      <Users className="h-5 w-5" />
                    </Button>
                  </DialogTrigger>
                  <NewGroupModal
                    allUsers={allUsers}
                    currentUser={currentUser}
                    onCreate={handleCreateGroup}
                    onOpenChange={setIsNewGroupModalOpen}
                  />
                </Dialog>
                {isMobile && (
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                    onClick={() => setIsMobileMenuOpen(false)}
                  >
                    <ArrowLeft className="h-5 w-5" />
                  </Button>
                )}
              </div>
            </div>

            {/* Search */}
            <div className="p-4 border-b border-slate-700">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                <Input
                  placeholder="Search conversations..."
                  className="pl-9 bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
            </div>

            {/* Chat List Area */}
            <ScrollArea className="flex-1">
              <div className="p-2">
                {conversations.map((conv) => (
                  <div
                    key={conv.id}
                    className={`p-3 rounded-lg cursor-pointer mb-1 hover:bg-slate-700/50 ${
                      selectedConversation?.id === conv.id ? "bg-slate-700" : ""
                    }`}
                    onClick={() => {
                      setSelectedConversation(conv);
                      if (isMobile) setIsMobileMenuOpen(false);
                    }}
                  >
                    <div className="flex items-center gap-3">
                      <Avatar>
                        <AvatarImage
                          src={
                            conv.is_group
                              ? conv.group_avatar_url ||
                                "/group-placeholder.svg"
                              : conv.avatar || "/placeholder.svg"
                          }
                          alt={
                            conv.is_group
                              ? conv.group_name || "Group"
                              : conv.name
                          }
                        />
                        <AvatarFallback className="bg-emerald-500 text-white">
                          {(conv.is_group
                            ? conv.group_name || "Group"
                            : conv.name
                          )
                            ?.split(" ")
                            .map((n) => n[0])
                            .join("") || "??"}
                        </AvatarFallback>
                      </Avatar>
                      <div className="flex-1 min-w-0">
                        <div className="flex justify-between items-center">
                          <h3 className="font-medium text-white truncate">
                            {conv.is_group
                              ? conv.group_name || "Unnamed Group"
                              : conv.name}
                          </h3>
                          <span className="text-xs text-slate-400">
                            {conv.time}
                          </span>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-sm text-slate-400 truncate">
                            {conv.lastMessage}
                          </p>
                          {conv.unread > 0 && (
                            <span className="bg-emerald-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                              {conv.unread}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>

            {/* Footer Profile Section */}
            <div className="p-4 border-t border-slate-700 flex items-center justify-between">
              <Link to="/profile" className="flex items-center gap-3">
                <Avatar>
                  <AvatarImage
                    src={
                      profile?.avatar_url ||
                      "/placeholder.svg?height=40&width=40"
                    }
                    alt="Your Avatar"
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {(profile?.full_name || profile?.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="font-medium text-white">
                    {profile?.full_name || profile?.username || "Loading..."}
                  </p>
                  <p className="text-xs text-slate-400">
                    {profile?.status || "Offline"}
                  </p>
                </div>
              </Link>
              <div className="flex gap-1">
                <Link to="/settings">
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                  >
                    <Settings className="h-5 w-5" />
                  </Button>
                </Link>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-slate-400 hover:text-white"
                  onClick={handleLogout}
                >
                  <LogOut className="h-5 w-5" />
                </Button>
              </div>
            </div>
          </div>
        </AnimatePresence>
      )}

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col h-full">
        {/* Chat Header */}
        <div className="p-4 border-b border-slate-700 flex items-center justify-between bg-slate-800">
          <div className="flex items-center gap-3">
            {isMobile && (
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white"
                onClick={() => setIsMobileMenuOpen(true)}
              >
                <Menu className="h-5 w-5" />
              </Button>
            )}

            {selectedConversation && (
              <>
                <Avatar>
                  <AvatarImage
                    src={
                      selectedConversation.is_group
                        ? selectedConversation.group_avatar_url ||
                          "/group-placeholder.svg"
                        : selectedConversation.avatar || "/placeholder.svg"
                    }
                    alt={
                      selectedConversation.is_group
                        ? selectedConversation.group_name || "Group Chat"
                        : selectedConversation.name
                    }
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {selectedConversation.is_group
                      ? (selectedConversation.group_name || "Group")
                          .split(" ")
                          .map((w) => w[0])
                          .join("")
                      : selectedConversation.name
                          ?.split(" ")
                          .map((n) => n[0])
                          .join("") || "??"}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <h2 className="font-medium text-white">
                    {selectedConversation.is_group
                      ? selectedConversation.group_name || "Unnamed Group"
                      : selectedConversation.name}
                  </h2>
                  <p className="text-xs text-slate-400">Online</p>
                </div>
              </>
            )}
            {!selectedConversation && !loadingConversations && (
              <div className="text-slate-400">
                Select a conversation to start chatting
              </div>
            )}
          </div>

          {/* More Options Sheet - Conditionally render if selectedConversation exists */}
          {selectedConversation && (
            <Sheet>
              <SheetTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-slate-400 hover:text-white"
                >
                  <MoreVertical className="h-5 w-5" />
                </Button>
              </SheetTrigger>
              <SheetContent className="bg-slate-800 border-slate-700 text-white">
                <div className="space-y-4 py-4">
                  <div className="flex flex-col items-center gap-2 pb-4 border-b border-slate-700">
                    <Avatar className="h-20 w-20">
                      <AvatarImage
                        src={
                          selectedConversation?.is_group
                            ? selectedConversation?.group_avatar_url ||
                              "/group-placeholder.svg"
                            : selectedConversation?.avatar || "/placeholder.svg"
                        }
                        alt={
                          selectedConversation?.is_group
                            ? selectedConversation?.group_name || "Group Chat"
                            : selectedConversation?.name
                        }
                      />
                      <AvatarFallback className="bg-emerald-500 text-white text-xl">
                        {(selectedConversation?.is_group
                          ? selectedConversation?.group_name || "Group"
                          : selectedConversation?.name
                        )
                          ?.split(" ")
                          .map((n) => n[0])
                          .join("") || "??"}
                      </AvatarFallback>
                    </Avatar>
                    <h3 className="text-xl font-bold">
                      {selectedConversation?.is_group
                        ? selectedConversation?.group_name || "Unnamed Group"
                        : selectedConversation?.name}
                    </h3>
                    <p className="text-sm text-slate-400">Online</p>
                  </div>

                  <div className="space-y-2">
                    <h4 className="text-sm font-medium text-slate-400">
                      Options
                    </h4>
                    <div className="space-y-1">
                      <Button
                        variant="ghost"
                        className="w-full justify-start text-white"
                      >
                        <User className="mr-2 h-4 w-4" />
                        View Profile
                      </Button>
                      <Button
                        variant="ghost"
                        className="w-full justify-start text-white"
                      >
                        <MessageSquare className="mr-2 h-4 w-4" />
                        Search in Conversation
                      </Button>
                      {selectedConversation?.is_group && (
                        <Button
                          variant="ghost"
                          className="w-full justify-start text-white"
                          onClick={async () => {
                            const newName = window.prompt(
                              "Enter a new group name:",
                              selectedConversation?.group_name || ""
                            );
                            if (
                              !newName ||
                              newName === selectedConversation?.group_name
                            )
                              return;
                            setIsRenamingGroup(true);
                            setError(null);
                            try {
                              await post(
                                `/conversations/${selectedConversation?.id}`,
                                {
                                  group_name: newName,
                                }
                              );
                              // Optimistically update UI
                              setSelectedConversation((c) => ({
                                ...c,
                                group_name: newName,
                                name: newName,
                              }));
                              setConversations((list) =>
                                list.map((c) =>
                                  c.id === selectedConversation?.id
                                    ? {
                                        ...c,
                                        name: newName,
                                        group_name: newName,
                                      }
                                    : c
                                )
                              );
                            } catch (err) {
                              console.error("Error renaming group:", err);
                              setError(
                                `Failed to rename group: ${err.message}`
                              );
                            } finally {
                              setIsRenamingGroup(false);
                            }
                          }}
                          disabled={
                            isRenamingGroup || !selectedConversation?.id
                          }
                        >
                          <Pencil className="mr-2 h-4 w-4" />
                          {isRenamingGroup ? "Renaming..." : "Rename Group"}
                        </Button>
                      )}
                      {selectedConversation?.is_group && (
                        <Button
                          variant="ghost"
                          className="w-full justify-start text-red-400 hover:text-red-300 hover:bg-red-900/20"
                          onClick={async () => {
                            if (
                              !window.confirm(
                                "Are you sure you want to leave this group? You'll have to be re-invited to participate again."
                              )
                            )
                              return;

                            setIsLeavingGroup(true);
                            setError(null);
                            try {
                              const { error: deleteError } = await supabase
                                .from("conversation_participants")
                                .delete()
                                .match({
                                  conversation_id: selectedConversation?.id,
                                  profile_id: currentUser?.id,
                                });

                              if (deleteError) throw deleteError;

                              // Remove from local state & navigate away
                              setConversations((list) =>
                                list.filter(
                                  (c) => c.id !== selectedConversation?.id
                                )
                              );
                              setSelectedConversation(null);
                              // navigate("/chat"); // Decided to keep user on the page
                            } catch (err) {
                              console.error("Error leaving group:", err);
                              setError(`Failed to leave group: ${err.message}`);
                            } finally {
                              setIsLeavingGroup(false);
                            }
                          }}
                          disabled={
                            isLeavingGroup ||
                            !selectedConversation?.id ||
                            !currentUser?.id
                          }
                        >
                          <LogOut className="mr-2 h-4 w-4" />
                          {isLeavingGroup ? "Leaving..." : "Leave Group"}
                        </Button>
                      )}
                      {/* Conditionally render Delete Conversation only if NOT a group and functionality is intended */}
                      {/* For now, completely hiding if not a group, as 1-on-1 delete is not implemented */}
                      {/* 
                      {!selectedConversation.is_group && (
                        <Button
                          variant="ghost"
                          className="w-full justify-start text-red-400 hover:text-red-300 hover:bg-red-900/20"
                          onClick={() => alert("Delete 1-on-1 conversation (not implemented yet)")} 
                        >
                          <LogOut className="mr-2 h-4 w-4" />
                          Delete Conversation
                        </Button>
                      )}
                      */}
                    </div>
                  </div>
                </div>
              </SheetContent>
            </Sheet>
          )}
        </div>

        {/* Messages Area */}
        <ScrollArea className="flex-1 p-4 bg-gradient-to-b from-slate-900 to-slate-800">
          <div className="space-y-4">
            {loadingMessages && (
              <div className="text-center text-slate-400 py-4">
                Loading messages...
              </div>
            )}
            {!loadingMessages &&
              messages.map((message) => (
                <div
                  key={message.id}
                  className={`flex ${
                    message.isSelf ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] ${
                      message.isSelf ? "order-2" : "order-1"
                    }`}
                  >
                    {!message.isSelf && (
                      <div className="flex items-center gap-2 mb-1">
                        <Avatar className="h-6 w-6">
                          <AvatarImage
                            src={message.senderAvatar || "/placeholder.svg"}
                            alt={message.senderName}
                          />
                          <AvatarFallback className="bg-emerald-500 text-white text-xs">
                            {message.senderName
                              ?.split(" ")
                              .map((n) => n[0])
                              .join("") || "??"}
                          </AvatarFallback>
                        </Avatar>
                        <span className="text-xs text-slate-400">
                          {message.senderName}
                        </span>
                      </div>
                    )}
                    <div
                      className={`rounded-lg p-3 ${
                        message.isSelf
                          ? "bg-emerald-500 text-white rounded-tr-none"
                          : "bg-slate-700 text-white rounded-tl-none"
                      }`}
                    >
                      <p>
                        {message.content.startsWith("[File](") ? (
                          // Format: [File](url) filename
                          (() => {
                            const match = message.content.match(
                              /\[File\]\((.*?)\)\s*(.*)/
                            );
                            const url = match?.[1];
                            const name = match?.[2] || "Download File";
                            return (
                              <a
                                href={url}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="underline text-blue-400"
                              >
                                📎 {name}
                              </a>
                            );
                          })()
                        ) : message.content.startsWith("[File] ") ? (
                          // Format: [File] filename (no URL yet — fallback)
                          <span className="text-slate-300">
                            📎 {message.content.slice(7)}
                          </span>
                        ) : (
                          message.content
                        )}
                      </p>
                    </div>
                    <p
                      className={`text-xs text-slate-400 mt-1 ${
                        message.isSelf ? "text-right" : "text-left"
                      }`}
                    >
                      {message.timestamp}
                    </p>
                  </div>
                </div>
              ))}
            {!loadingMessages &&
              messages.length === 0 &&
              selectedConversation && (
                <div className="text-center text-slate-500 pt-10">
                  No messages yet. Start the conversation!
                </div>
              )}
            <div ref={messagesEndRef} />
          </div>
          {!selectedConversation && !loadingConversations && (
            <div className="text-center text-slate-500 pt-10">
              Select a conversation to view messages.
            </div>
          )}
        </ScrollArea>

        {/* Message Input */}
        <div className="p-4 border-t border-slate-700 bg-slate-800 relative">
          <form
            onSubmit={(e) => {
              e.preventDefault();
              handleSendMessage();
            }}
            className="flex items-center gap-2"
          >
            <Button
              type="button"
              variant="ghost"
              className="text-slate-400 hover:text-white"
              onClick={() => fileInputRef.current.click()}
            >
              📎
            </Button>

            <input
              type="file"
              ref={fileInputRef}
              style={{ display: "none" }}
              onChange={handleFileSelect}
            />

            <Input
              placeholder="Type a message..."
              className="bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
              value={newMessage}
              onChange={(e) => setNewMessage(e.target.value)}
              disabled={
                !selectedConversation || loadingConversations || !isReady
              }
            />
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={() => setShowEmojiPicker((prev) => !prev)}
            >
              😀
            </Button>

            <Button
              type="submit"
              size="icon"
              className="bg-emerald-500 hover:bg-emerald-600 text-white"
              disabled={
                (!newMessage.trim() && !selectedFile) ||
                !selectedConversation ||
                loadingConversations ||
                !isReady
              }
            >
              <Send className="h-5 w-5" />
            </Button>
          </form>
          {showEmojiPicker && (
            <div className="absolute bottom-24 right-8 z-50">
              <EmojiPicker
                onEmojiClick={(emojiData) =>
                  setNewMessage((prev) => prev + emojiData.emoji)
                }
              />
            </div>
          )}

          {selectedFile && (
            <div className="text-slate-400 text-xs mt-2 ml-2">
              Attached: {selectedFile.name}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/pages/CryptoTestPage.jsx
================
import { useState } from 'react';
import { clear, get, set } from 'idb-keyval';
import { initializeKeys, initiateX3DH, encryptMessage, decryptMessage } from '../lib/signalCrypto';

function CryptoTestPage() {
  const [result, setResult] = useState('');

  async function runTest() {
    try {
      console.log('Starting test...');

      // Clear idb-keyval to ensure clean state
      await clear();
      console.log('idb-keyval cleared');

      // Initialize keys for Alice and Bob
      console.log('Initializing Alice keys...');
      const aliceKeys = await initializeKeys('alice');
      console.log('Alice keys:', aliceKeys);

      console.log('Initializing Bob keys...');
      const bobKeys = await initializeKeys('bob');
      console.log('Bob keys:', bobKeys);

      // Perform X3DH key agreement
      console.log('Alice initiating X3DH with Bob...');
      const aliceSharedKey = await initiateX3DH('alice', 'bob', bobKeys);
      console.log('Alice shared key:', !!aliceSharedKey);

      console.log('Bob initiating X3DH with Alice...');
      const bobSharedKey = await initiateX3DH('bob', 'alice', aliceKeys);
      console.log('Bob shared key:', !!bobSharedKey);

      // Test encryption and decryption
      const message = 'Hello, Bob!';
      console.log('Encrypting message:', message);
      const encrypted = await encryptMessage('alice', 'bob', message);
      console.log('Encrypted:', encrypted);

      console.log('Decrypting message...');
      const decrypted = await decryptMessage('bob', 'alice', encrypted);
      console.log('Decrypted:', decrypted);

      if (decrypted === message) {
        console.log('✅ Message decrypted correctly');
        setResult('Test passed: Message decrypted correctly');
      } else {
        console.error('❌ Decryption failed: mismatch');
        setResult('Test failed: Decryption mismatch');
      }
    } catch (error) {
      console.error('Test failed:', error);
      setResult(`Test failed: ${error.message}`);
    }
  }

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold">Crypto Test</h1>
      <button
        onClick={runTest}
        className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
      >
        Run Test
      </button>
      <p className="mt-4">{result}</p>
    </div>
  );
}

export default CryptoTestPage;

================
File: src/pages/ForgotPasswordPage.jsx
================
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { AlertCircle, ArrowLeft, Mail } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
// eslint-disable-next-line
import { motion } from "framer-motion";

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!email) {
      setError("Please enter your email address");
      return;
    }

    setIsLoading(true);

    // Simulate API call
    try {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      setIsSubmitted(true);
    } catch (err) {
      setError("Failed to send reset email. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/login"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Login
        </Link>
      </header>

      <main className="flex-1 flex items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="w-full max-w-md"
        >
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-2">
                <Mail className="h-8 w-8 text-emerald-400" />
              </div>
              <CardTitle className="text-2xl text-center text-white">
                Reset your password
              </CardTitle>
              <CardDescription className="text-center text-slate-400">
                Enter your email address and we'll send you a link to reset your
                password
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <Alert
                  variant="destructive"
                  className="mb-4 bg-red-900/20 border-red-800 text-red-300"
                >
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              {isSubmitted ? (
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  className="text-center space-y-4"
                >
                  <div className="bg-emerald-900/20 border border-emerald-800 text-emerald-300 p-4 rounded-md">
                    <p>Reset link sent! Check your email for instructions.</p>
                  </div>
                  <p className="text-slate-400 text-sm">
                    Didn't receive an email? Check your spam folder or{" "}
                    <button
                      onClick={() => setIsSubmitted(false)}
                      className="text-emerald-400 hover:text-emerald-300"
                    >
                      try again
                    </button>
                  </p>
                </motion.div>
              ) : (
                <form onSubmit={handleSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="email" className="text-slate-200">
                      Email
                    </Label>
                    <Input
                      id="email"
                      type="email"
                      placeholder="name@example.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      className="bg-slate-900/50 border-slate-700 text-slate-200"
                    />
                  </div>

                  <Button
                    type="submit"
                    className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
                    disabled={isLoading}
                  >
                    {isLoading ? "Sending..." : "Send reset link"}
                  </Button>
                </form>
              )}
            </CardContent>
            <CardFooter className="flex justify-center">
              <p className="text-sm text-slate-400">
                Remember your password?{" "}
                <Link
                  to="/login"
                  className="text-emerald-400 hover:text-emerald-300"
                >
                  Sign in
                </Link>
              </p>
            </CardFooter>
          </Card>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/HomePage.jsx
================
import { Button } from "@/components/ui/button";
import { ArrowRight, Lock, MessageSquare, Shield, Zap } from "lucide-react";
import { Link } from "react-router-dom";
//eslint-disable-next-line
import { motion, AnimatePresence } from "framer-motion";
import { useEffect, useState } from "react";

export default function HomePage() {
  //Phrases to be displayed on right side of page
  const phrases = [
    "In a world of leaks and hacks, your conversations deserve absolute confidentiality.",
    "Share moments, ideas, and secrets — with complete peace of mind.",
    "No ads. No trackers. Just secure communication.",
    "Your messages are for you — and only you.",
    "Privacy isn't a feature. It's our foundation.",
  ];

  const [currentPhrase, setCurrentPhrase] = useState(0);
  const [randomPosition, setRandomPosition] = useState({ top: "50%", left: "50%" });

  useEffect(() => { 
      const interval = setInterval(() => {
      setCurrentPhrase((prev) => (prev + 1) % phrases.length);
  
      const top = Math.floor(Math.random() * 30) + 30;  // between 30% and 70%
      const left = Math.floor(Math.random() * 5) + 50; // between 60% and 75%           
      setRandomPosition({ top: `${top}%`, left: `${left}%` });
    }, 5000); // 5 seconds
  
    return () => clearInterval(interval);
  }, []);  

  return (
    <div className="flex flex-col min-h-screen bg-gradient-to-b from-slate-900 to-slate-800">
      {/* Header */}
      <header className="container mx-auto p-4 flex justify-between items-center">
        <div className="flex items-center gap-2">
          <Lock className="h-8 w-8 text-emerald-500" />
          <span className="font-bold text-white text-2xl">SecureChat</span>
        </div>
      </header>

       {/* Main Section */}
      <main className="flex-1 container mx-auto px-4 py-12 flex flex-col md:flex-row items-center justify-center text-center gap-8">

        {/* Left Side Content */}
        <div className="hidden 2xl:flex flex-1">
          <div className="flex flex-col">
            <img
              src="/images/green_text.png"
              alt="Chat bubble green"
              className="w-60 ml-0"
            />
            <img
              src="/images/blue_text.png"
              alt="Chat bubble blue"
              className="w-60 ml-30"
            />
          </div>
        </div>


        {/* Center Content */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="flex-1 max-w-md"
        >
          <div className="mb-6 flex justify-center">
            <div className="relative drop-shadow-lg">
              <Lock className="h-20 w-20 text-emerald-500" />
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                transition={{ delay: 0.3, duration: 0.5 }}
                className="absolute -top-1 -right-1 bg-blue-400 rounded-full p-1 shadow-md"
              >
                <Shield className="h-6 w-6 text-slate-900" />
              </motion.div>
            </div>
          </div>

          
          <h1 className="text-3xl md:text-5xl font-bold text-white mb-4 tracking-wide">
            Secure. Private. Encrypted.
          </h1>

          <p className="text-slate-300 mb-8">
            End-to-end encrypted messaging that keeps your conversations private
            and secure.
          </p>
          
          <div className="grid gap-4 mb-8">
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.2, duration: 0.5 }}
              className="flex items-center gap-3 bg-slate-800/50 p-3 rounded-lg text-left border border-slate-700 hover:bg-slate-700 transition"
            >
              <Shield className="h-5 w-5 text-emerald-400 flex-shrink-0" />
              <span className="text-slate-200 text-sm">
                End-to-end encryption for all messages
              </span>
            </motion.div>

            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.3, duration: 0.5 }}
              className="flex items-center gap-3 bg-slate-800/50 p-3 rounded-lg text-left border border-slate-700 hover:bg-slate-700 transition"
            >
              <Zap className="h-5 w-5 text-emerald-400 flex-shrink-0" />
              <span className="text-slate-200 text-sm">
                Fast, reliable messaging on any device
              </span>
            </motion.div>

            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.4, duration: 0.5 }}
              className="flex items-center gap-3 bg-slate-800/50 p-3 rounded-lg text-left border border-slate-700 hover:bg-slate-700 transition"
            >
              <MessageSquare className="h-5 w-5 text-emerald-400 flex-shrink-0" />
              <span className="text-slate-200 text-sm">
                Group chats with the same level of security
              </span>
            </motion.div>
          </div>
            
          <div className="flex flex-col sm:flex-row gap-5">
            <Link to="/login" className="w-full">
              <Button className="w-full bg-emerald-500 hover:bg-emerald-600 text-white">  
                Login
              </Button>
            </Link>  
          </div>

          <div className="flex flex-col sm:flex-row gap-22 mt-4">
            <span className="text-slate-200 text-sm">
                Don't have an account?
            </span>
            <span className="text-slate-200 text-sm">
                Want to learn more?
            </span>
          </div>

          <div className="flex flex-col sm:flex-row gap-4 mt-1">
            <Link to="/signup" className="w-full">
              <Button className="w-full bg-blue-400 hover:bg-blue-600 text-white">
                Get Started <ArrowRight className="ml-2 h-4 w-4" />
              </Button>
            </Link>
            <Link to="/about" className="w-full">
              <Button
                variant="outline"
                className="w-full border-slate-700 text-slate-600 hover:bg-slate-700"
              >
                Learn More
              </Button>
            </Link>
          </div>
        </motion.div>
      

          {/* Right Side */}
          <div className="hidden 2xl:flex flex-1 relative overflow-hidden min-h-[500px]">
            <AnimatePresence mode="wait">
              <motion.div
                key={currentPhrase}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.6 }}
                style={{
                  position: "absolute",
                  top: randomPosition.top,
                  left: randomPosition.left,
                  transform: "translate(-50%, -50%)",
                  maxWidth: "250px",
                }}
                className="bg-slate-800/50 p-4 rounded-lg border border-slate-700 text-slate-200 text-center italic text-xl leading-relaxed"
              >
                “{phrases[currentPhrase]}”
              </motion.div>
            </AnimatePresence>
          </div>

        </main>

      {/* Footer */}
      <footer className="container mx-auto p-4 text-center text-slate-400 text-sm">
        <p>© {new Date().getFullYear()} SecureChat. All rights reserved.</p>
      </footer>
    </div>
  );
}

================
File: src/pages/LoginPage.jsx
================
import { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { AlertCircle, ArrowLeft, Lock, Eye, EyeOff } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
// eslint-disable-next-line
import { motion } from "framer-motion";
import { supabase } from "../lib/supabaseClient";

export default function LoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!email || !password) {
      setError("Please enter both email and password");
      return;
    }

    setIsLoading(true);

    try {
      const { data, error: signInError } =
        await supabase.auth.signInWithPassword({
          email: email,
          password: password,
        });

      if (signInError) {
        setError(signInError.message);
      } else if (data.session) {
        console.log("Login successful, user:", data.session.user);
        console.log("Navigating to chat...");
        navigate("/chat");
      } else {
        console.error("Login response did not include a session");
        setError("An unexpected error occurred. Please try again.");
      }
    } catch (err) {
      console.error("Unexpected error during login:", err);
      setError("An unexpected error occurred. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  //show password
  const handleState = () => {
    setShowPassword((showState) => !showState);
  };


  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Home
        </Link>
      </header>

      <main className="flex-1 flex items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="w-full max-w-md"
        >
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-2">
                <Lock className="h-8 w-8 text-emerald-400" />
              </div>
              <CardTitle className="text-2xl text-center text-white">
                Welcome back
              </CardTitle>
              <CardDescription className="text-center text-slate-400">
                Enter your credentials to access your account
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <Alert
                  variant="destructive"
                  className="mb-4 bg-red-900/20 border-red-800 text-red-300"
                >
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              <form onSubmit={handleSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="email" className="text-slate-200">
                    Email
                  </Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="name@example.com"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <Label htmlFor="password" className="text-slate-200">
                      Password
                    </Label>
                    <Link
                      to="/forgot-password"
                      className="text-xs text-emerald-400 hover:text-emerald-300"
                    >
                      Forgot password?
                    </Link>
                  </div>

                  <div className="relative">
                    <Input
                      id="password"
                      type={showPassword ? "text" : "password"}
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      className="bg-slate-900/50 border-slate-700 text-slate-200"
                    />
                    <button
                      type="button"
                      onClick={handleState}
                      className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-slate-200"
                    >
                      {showPassword ? <Eye size={20} /> : <EyeOff size={20} />}
                    </button>
                  </div>

                </div>

                <Button
                  type="submit"
                  className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
                  disabled={isLoading}
                >
                  {isLoading ? "Signing in..." : "Sign in"}
                </Button>
              </form>
            </CardContent>
            <CardFooter className="flex justify-center">
              <p className="text-sm text-slate-400">
                Don't have an account?
                <Link
                  to="/signup"
                  className="text-emerald-400 hover:text-emerald-300"
                >
                  Sign up
                </Link>
              </p>
            </CardFooter>
          </Card>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/nehahelp.jsx
================
import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import EmojiPicker from "emoji-picker-react";
import {
  ArrowLeft,
  LogOut,
  Menu,
  MessageSquare,
  MoreVertical,
  Plus,
  Search,
  Send,
  Settings,
  User,
} from "lucide-react";
import { Link, useNavigate } from "react-router-dom";
import { AnimatePresence } from "framer-motion";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useMobile } from "../hooks/use-mobile";
import { supabase } from "../lib/supabaseClient";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import NewChatModal from "../components/NewChatModal";
import { post } from "../lib/backend"; // <-- Import post helper
import { db } from "../lib/db"; // <-- Import Dexie db instance

export default function ChatPage() {
  console.log("--- ChatPage Component Rendering ---");
  // --- State Variables ---
  const [currentUser, setCurrentUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [conversations, setConversations] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [loadingConversations, setLoadingConversations] = useState(true);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [error, setError] = useState(null);
  const [messageSubscription, setMessageSubscription] = useState(null);
  const [isNewChatModalOpen, setIsNewChatModalOpen] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const fileInputRef = useRef();

  const isMobile = useMobile();
  const navigate = useNavigate();
  const messagesEndRef = useRef(null);

  // --- Helper Functions ---
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // Format Supabase message to UI structure
  const formatMessage = (msg) => {
    if (!msg || !msg.profiles) {
      console.warn("Attempted to format invalid message:", msg);
      return null; // Or return a default structure
    }
    const senderProfile = msg.profiles;
    const timestamp = msg.created_at
      ? new Date(msg.created_at).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        })
      : "";
    return {
      id: msg.id,
      senderId: senderProfile.id, // Keep sender ID
      senderName:
        senderProfile.full_name || senderProfile.username || "Unknown User",
      senderAvatar: senderProfile.avatar_url,
      content: msg.content,
      timestamp: timestamp,
      isSelf: senderProfile.id === currentUser?.id,
      isEncrypted: msg.is_encrypted, // Pass flag for potential UI indicators
      originalCiphertextType: msg.encryption_header?.type, // Pass original type if needed
    };
  };

  // --- Effects ---

  // 1. Get current user and profile
  useEffect(() => {
    const fetchUserAndProfile = async () => {
      console.log("[Effect 1] Running fetchUserAndProfile...");
      setLoadingConversations(true); // Keep loading conversations true initially

      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession();
      console.log("[Effect 1] Session data:", session);
      console.error("[Effect 1] Session error:", sessionError);

      if (sessionError) {
        console.error("Error getting session:", sessionError);
        setError("Failed to load user session.");
        setLoadingConversations(false);
        return;
      }

      if (!session?.user) {
        console.log("No user session found, redirecting to login.");
        navigate("/login");
        return;
      }

      console.log("[Effect 1] User found:", session.user);
      setCurrentUser(session.user);

      // Fetch profile details
      console.log("[Effect 1] Fetching profile for user ID:", session.user.id);
      const { data: profileData, error: profileError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url, status") // Select id as well
        .eq("id", session.user.id)
        .single();

      console.log("[Effect 1] Profile fetch result:", {
        profileData,
        profileError,
      });

      if (profileError && profileError.code !== "PGRST116") {
        // PGRST116: Row not found, might be acceptable if profile creation is separate
        console.error("Error fetching profile:", profileError);
        setError(`Failed to load user profile: ${profileError.message}`);
        // Don't set profile, let subsequent effects handle null profile
      } else if (!profileData) {
        console.warn("[Effect 1] Profile not found for user:", session.user.id);
        setError("User profile not found. Please complete profile setup."); // More specific error
        // Don't set profile
      } else {
        console.log("[Effect 1] Setting profile state:", profileData);
        setProfile(profileData); // Set profile state successfully
        setError(null); // Clear any previous errors if profile loads
      }
      // setLoadingConversations(false); // Keep loading true until conversations are attempted
    };

    fetchUserAndProfile();
  }, [navigate]);

  // 2. Fetch conversations once user profile is loaded
  useEffect(() => {
    console.log("[Effect 2] Checking profile state:", profile);
    if (!profile?.id) {
      console.log(
        "[Effect 2] No profile ID found, skipping conversation fetch."
      );
      // If profile loading previously failed, we need to stop the main loading indicator
      if (!loadingConversations && !profile) {
        setLoadingConversations(false); // Ensure loading stops if profile never loads
      }
      return;
    }
    const fetchConversations = async () => {
      setLoadingConversations(true);
      console.log("Fetching conversations for profile:", profile.id);
      try {
        // Fetch conversation IDs the user is part of
        const { data: participantData, error: participantError } =
          await supabase
            .from("conversation_participants")
            .select("conversation_id")
            .eq("profile_id", profile.id);

        if (participantError) throw participantError;

        const conversationIds = participantData.map((p) => p.conversation_id);

        if (conversationIds.length === 0) {
          setConversations([]);
          setLoadingConversations(false);
          return;
        }

        // Fetch details for these conversations and their participants
        // This query is more complex: get conversation, its participants, and their profiles
        // Adjust based on performance needs (might need separate queries or a DB function)
        const { data: convData, error: convError } = await supabase
          .from("conversations")
          .select(
            `
            id,
            created_at,
            conversation_participants(
              profile_id,
              profiles(id, username, full_name, avatar_url, status)
            )
          `
          )
          .in("id", conversationIds);

        if (convError) throw convError;

        console.log("Fetched raw conversation data:", convData);
        const formattedConversations = convData.map((conv) => {
          const participants = conv.conversation_participants.map(
            (p) => p.profiles
          );
          // Find the other participant(s) for naming/avatar
          const otherParticipant =
            participants.find((p) => p.id !== profile.id) || participants[0];
          const name =
            otherParticipant?.full_name ||
            otherParticipant?.username ||
            "Unknown User";
          const avatar = otherParticipant?.avatar_url;
          // TODO: Fetch last message and time (requires another query or denormalization)
          return {
            id: conv.id,
            name: name,
            lastMessage: "...",
            time: "",
            unread: 0,
            avatar: avatar,
            participants: participants,
          };
        });
        console.log("Formatted conversations:", formattedConversations);

        setConversations(formattedConversations);
        if (!selectedConversation && formattedConversations.length > 0) {
          console.log(
            "Setting selected conversation to first one:",
            formattedConversations[0]
          );
          setSelectedConversation(formattedConversations[0]);
        } else if (formattedConversations.length === 0) {
          console.log("No conversations found for this user.");
          setSelectedConversation(null); // Ensure it's null if none found
        }
      } catch (fetchError) {
        console.error("Error fetching conversations:", fetchError);
        setError("Failed to load conversations.");
      } finally {
        console.log(
          "Finished fetching conversations, setting loadingConversations to false."
        );
        setLoadingConversations(false);
      }
    };

    fetchConversations();
  }, [profile?.id]); // Removed selectedConversation dependency for clarity

  // 3. Fetch messages when selectedConversation changes - UPDATED FOR INDEXEDDB + Rehydration
  useEffect(() => {
    if (!selectedConversation?.id || !currentUser?.id) {
      setMessages([]); // Clear messages if no conversation selected
      return;
    }

    let isMounted = true; // Flag to prevent state updates on unmounted component
    setLoadingMessages(true);
    setError(null);
    console.log(
      `[Effect 3 - Combined] Loading messages for convo ${selectedConversation.id}`
    );

    // Helper to format messages loaded from IndexedDB
    const formatLocalMessage = (localMsg) => ({
      id: localMsg.id,
      senderId: localMsg.senderId,
      senderName: localMsg.senderName,
      senderAvatar: localMsg.senderAvatar,
      content: localMsg.content, // Content is already plaintext
      timestamp: new Date(localMsg.timestamp).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }), // Format timestamp for display
      isSelf: localMsg.senderId === currentUser.id, // Re-calculate isSelf based on current user
    });

    const loadAndRehydrateMessages = async () => {
      try {
        // --- Step 1: Load existing messages from IndexedDB ---
        let localMessages = await db.messages
          .where("conversationId")
          .equals(selectedConversation.id)
          .toArray();

        // Purge any that are empty *or* the initial-session placeholder
        localMessages = await Promise.all(
          localMessages.map(async (m) => {
            const shouldPurge =
              !m.content.trim() || m.content === "(initial session packet)";
            if (shouldPurge) {
              await db.messages.delete(m.id);
              console.log(`Purged message ${m.id} from IndexedDB`);
              return null;
            }
            return m;
          })
        ).then((arr) => arr.filter(Boolean));

        // Sort by timestamp
        localMessages.sort(
          (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
        );

        if (!isMounted) return;

        console.log(
          `[Effect 3 - DB] Using ${localMessages.length} clean messages locally.`
        );
        setMessages(localMessages.map(formatLocalMessage));

        // --- Step 2: Fetch ALL messages from Supabase to find missing ones ---
        console.log(
          `[Effect 3 - Supa] Fetching all messages from Supabase for potential rehydration.`
        );
        const { data: supabaseMessages, error: messagesError } = await supabase
          .from("messages")
          .select(
            `
            id,
            conversation_id,
            content,
            created_at,
            profile_id,
            is_encrypted,
            encryption_header,
            profiles ( id, full_name, username, avatar_url )
          `
          )
          .eq("conversation_id", selectedConversation.id)
          .order("created_at", { ascending: true });

        if (messagesError) throw messagesError;
        if (!isMounted) return;

        console.log(
          `[Effect 3 - Supa] Fetched ${supabaseMessages.length} raw messages from Supabase.`
        );

        // --- Step 3: Identify and decrypt messages NOT already in IndexedDB ---
        const localIds = new Set(localMessages.map((m) => m.id));
        const messagesToProcess = supabaseMessages.filter(
          (supaMsg) =>
            supaMsg.profile_id !== currentUser.id && // from someone else
            !localIds.has(supaMsg.id) // not already stored
        );

        console.log(
          `[Effect 3 - Decrypt] Found ${messagesToProcess.length} missing/undecrypted messages.`
        );

        if (messagesToProcess.length === 0) {
          console.log("No messages to process.");
          return;
        }

        if (messagesToProcess.length > 0) {
          for (const msg of messagesToProcess) {
            let plaintext = msg.content;

            // *only* decrypt if it's still marked encrypted
            if (msg.is_encrypted) {
              try {
                const { plaintext: p } = await post("/messages/decrypt", {
                  recipient_id: currentUser.id,
                  sender_id: msg.profile_id,
                  header_b64: msg.encryption_header,
                  ciphertext_b64: msg.content,
                });
                plaintext = p;
              } catch (err) {
                console.warn(`Failed to decrypt ${msg.id}, skipping:`, err);
                continue; // or set plaintext = "[decryption error]" if you prefer
              }
            }
            if (!plaintext.trim()) {
              console.log(`Skipping empty/handshake message ${msg.id}`);
              continue;
            }
            const toStore = {
              id: msg.id,
              conversationId: msg.conversation_id,
              senderId: msg.profile_id,
              senderName:
                msg.profiles?.full_name || msg.profiles?.username || "Unknown",
              senderAvatar: msg.profiles?.avatar_url,
              content: plaintext,
              timestamp: new Date(msg.created_at).toISOString(),
            };

            await db.messages.put(toStore);

            if (!isMounted) break;

            setMessages((prev) => {
              const formatted = {
                id: toStore.id,
                senderId: toStore.senderId,
                senderName: toStore.senderName,
                senderAvatar: toStore.senderAvatar,
                content: toStore.content,
                timestamp: new Date(toStore.timestamp).toLocaleTimeString([], {
                  hour: "2-digit",
                  minute: "2-digit",
                }),
                isSelf: toStore.senderId === currentUser.id,
              };
              return [...prev, formatted].sort(
                (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
              );
            });
          }
        }
      } catch (err) {
        console.error("[Effect 3] Error loading messages:", err);
        if (isMounted) setError("Failed to load messages.");
      } finally {
        if (isMounted) {
          setLoadingMessages(false);
          console.log("[Effect 3] Finished loading messages.");
        }
      }
    };

    loadAndRehydrateMessages();

    // Cleanup function
    return () => {
      isMounted = false;
      console.log("[Effect 3 - Combined] Unmounting/cleanup.");
    };

    // Dependency array: Fetch when conversation or user changes
  }, [selectedConversation?.id, currentUser?.id]);

  // 4. Scroll to bottom when messages change
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // 5. Realtime subscription for new messages
  useEffect(() => {
    if (!selectedConversation?.id || !currentUser?.id) {
      // If no conversation selected, remove any existing subscription
      if (messageSubscription) {
        supabase.removeChannel(messageSubscription);
        setMessageSubscription(null);
      }
      return;
    }

    // Create a new channel for the selected conversation
    const channel = supabase
      .channel(`messages:${selectedConversation.id}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
          filter: `conversation_id=eq.${selectedConversation.id}`, // Filter for current conversation
        },
        // Modified handler to include decryption
        async (payload) => {
          console.log("[Realtime] handleNewMessage triggered:", payload);

          const newMessageData = payload.new;

          // --- BEGIN FIX: Ignore own messages from realtime insert ---
          if (newMessageData.profile_id === currentUser.id) {
            console.log(
              "[Realtime] Ignoring own message insert notification (already handled by local echo)."
            );
            return;
          }
          // --- END FIX ---

          // Check if it belongs to the current conversation (extra safety)
          if (newMessageData.conversation_id !== selectedConversation.id) {
            console.log(
              "[Realtime] Message is for a different conversation, skipping."
            );
            return;
          }

          // Avoid adding duplicates if message already exists (e.g., from initial fetch)
          if (messages.some((msg) => msg.id === newMessageData.id)) {
            console.log("[Realtime] Duplicate message detected, skipping.");
            return;
          }

          // Fetch sender profile for the new message
          const { data: senderProfile, error: profileError } = await supabase
            .from("profiles")
            .select("id, full_name, username, avatar_url")
            .eq("id", newMessageData.profile_id)
            .single();

          if (profileError) {
            console.error(
              "[Realtime] Error fetching profile for new message:",
              profileError
            );
            return;
          }
          console.log("[Realtime] Fetched sender profile:", senderProfile);

          let contentToFormat = { ...newMessageData, profiles: senderProfile };

          // Check if message is encrypted and needs decryption
          if (
            newMessageData.is_encrypted &&
            newMessageData.profile_id !== currentUser.id
            // Removed check for content/header here, rely on is_encrypted
          ) {
            console.log(
              `[Realtime] Encrypted message ${newMessageData.id} received, needs decryption.`
            );
            try {
              console.log(
                `[Realtime] Calling backend decrypt for msg ${newMessageData.id}...`
              );
              // Use post helper for decryption
              const decryptResult = await post("/messages/decrypt", {
                recipient_id: currentUser.id,
                sender_id: newMessageData.profile_id,
                header_b64: newMessageData.encryption_header,
                ciphertext_b64: newMessageData.content,
              });

              // Only need plaintext now, already_decrypted check happens via !localIds.has()
              const { plaintext } = decryptResult;

              console.log(
                `[Realtime] Decryption successful for msg ${newMessageData.id}.`
              );

              // Update contentToFormat with decrypted data
              contentToFormat.content = plaintext;
              contentToFormat.is_encrypted = false; // Mark as plaintext for formatting
              contentToFormat.encryption_header = null; // Conceptually nullify header
            } catch (decryptionError) {
              console.error(
                `[Realtime] Error during decryption call for msg ${newMessageData.id}:`,
                decryptionError
              );
              contentToFormat.content = "[Decryption Error]"; // Update content to show error
              contentToFormat.is_encrypted = true; // Keep flag true as decryption failed
            }
          } else {
            // Message is plaintext or self-sent
            console.log(
              `[Realtime] Message ${newMessageData.id} is plaintext or self-sent.`
            );
            // Ensure contentToFormat reflects this if necessary (it should already have the correct content/flags from payload)
          }

          // *** NEW: skip both empty and handshake packets ***
          if (
            !contentToFormat.content.trim() ||
            contentToFormat.content === "(initial session packet)"
          ) {
            console.log(
              `Skipping realtime handshake/empty msg ${newMessageData.id}`
            );
            return;
          }

          // Format the message for the UI (using potentially decrypted content)
          const formatted = formatMessage(contentToFormat);
          if (formatted) {
            const toStore = {
              id: contentToFormat.id,
              conversationId: contentToFormat.conversation_id,
              senderId: contentToFormat.profile_id,
              senderName: senderProfile.full_name || senderProfile.username,
              senderAvatar: senderProfile.avatar_url,
              content: contentToFormat.content,
              timestamp: new Date(payload.new.created_at).toISOString(),
            };
            try {
              await db.messages.put(toStore);
            } catch (err) {
              console.error("Failed to persist incoming msg:", err);
            }
            console.log(
              "[Realtime] Adding formatted message to state:",
              formatted
            );
            setMessages((prevMessages) => [...prevMessages, formatted]);
          } else {
            console.warn(
              "[Realtime] Failed to format message payload:",
              payload.new
            );
          }
        }
      )
      .subscribe((status, err) => {
        if (status === "SUBSCRIBED") {
          console.log(
            `Subscribed to messages for conversation ${selectedConversation.id}`
          );
        } else if (status === "CHANNEL_ERROR") {
          console.error("Realtime channel error:", err);
          setError("Realtime connection error. Please refresh.");
        } else if (status === "TIMED_OUT") {
          console.warn("Realtime connection timed out.");
        }
      });

    setMessageSubscription(channel); // Store the channel

    // Cleanup function: Remove the channel subscription when conversation changes or component unmounts
    return () => {
      if (channel) {
        console.log(
          `Unsubscribing from messages for conversation ${selectedConversation.id}`
        );
        supabase.removeChannel(channel);
        setMessageSubscription(null);
      }
    };
  }, [selectedConversation?.id, currentUser?.id]); // Re-subscribe ONLY if conversation or user changes

  // Filter conversations based on search query
  const filteredConversations = conversations.filter((conv) =>
    conv.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleSendMessage = async () => {
    if (!newMessage.trim() || !selectedConversation || !profile?.id) return;

    const recipientProfile = selectedConversation.participants.find(
      (p) => p.id !== profile.id
    );

    if (!recipientProfile) {
      console.error(
        "Could not find recipient profile in selected conversation."
      );
      setError("Error sending message: Recipient not found.");
      return;
    }

    const recipientId = recipientProfile.id;
    const plaintextMessage = newMessage.trim();
    setNewMessage(""); // Clear input immediately
    console.log(`[SendMessage] Preparing to encrypt: "${plaintextMessage}"`);
    let insertedMessages = null; // Declare insertedMessages here

    try {
      // --- Step 0: Ensure Session is Initiated ---
      console.log(
        `[SendMessage] Ensuring session initiated for ${profile.id} -> ${recipientId}...`
      );
      // Use post helper to initiate session
      const initiateResult = await post("/sessions/initiate", {
        sender_id: profile.id,
        recipient_id: recipientId,
      });

      console.log(
        "[SendMessage] Session initiation check completed:",
        initiateResult.message // Use message from post result
      );
      // Step 0b: If there's an initial handshake packet, store it
      if (initiateResult.initial_packet_header_b64) {
        console.log("[SendMessage] Storing handshake packet…");
        const { error: hsError } = await supabase.from("messages").insert({
          conversation_id: selectedConversation.id,
          profile_id: profile.id,
          content: initiateResult.initial_packet_ciphertext_b64,
          is_encrypted: true,
          encryption_header: initiateResult.initial_packet_header_b64,
        });
        if (hsError) {
          console.error("Failed to store handshake packet:", hsError);
          throw new Error("Handshake storage failed");
        }
        console.log("[SendMessage] Handshake packet stored.");
      }
      // --- Step 1: Call Backend Encryption API ---
      console.log(
        `[SendMessage] Calling backend encrypt for recipient ${recipientId}...`
      );
      // Use post helper to encrypt
      const { header_b64, ciphertext_b64 } = await post(
        "/messages/encrypt",
        {
          sender_id: profile.id,
          recipient_id: recipientId,
          plaintext: plaintextMessage,
        }
      );

      console.log(
        `[SendMessage] Encryption successful. Header and Ciphertext received.`
      );

      // --- Step 2: Store Encrypted Message in Supabase ---
      console.log(`[SendMessage] Storing encrypted message to Supabase...`);
      const { data: supabaseData, error: insertError } = await supabase
        .from("messages")
        .insert({
          conversation_id: selectedConversation.id,
          profile_id: profile.id,
          content: ciphertext_b64,
          is_encrypted: true,
          encryption_header: header_b64,
        })
        .select("id") // Select the ID of the inserted row
        .single(); // Expecting a single row back

      if (insertError) {
        console.error(
          "[SendMessage] Error inserting message into Supabase:",
          insertError
        );
        throw new Error(
          `Database Error: ${insertError.message || "Failed to save message"}`
        );
      }
      insertedMessages = supabaseData; // Assign to the outer scoped variable
    } catch (err) {
      console.error("[SendMessage] Error encrypting or saving message:", err);
      setError(`Error sending message: ${err.message}`);
      return; // bail out—don't try to send files or update UI
    }

    // now you're outside the first try/catch, safe to do file‐attachment and optimistic UI
    if (
      !selectedConversation ||
      !currentUser ||
      (!newMessage.trim() && !selectedFile)
    )
      return;

    const conversationId = selectedConversation.id;
    const profileId = currentUser.id;

    try {
      if (newMessage.trim()) {
        await supabase.from("messages").insert({
          conversation_id: conversationId,
          profile_id: profileId,
          content: newMessage.trim(),
        });
      }

      if (selectedFile) {
        await supabase.from("messages").insert({
          conversation_id: conversationId,
          profile_id: profileId,
          content: `[File] ${selectedFile.name}`,
        });
      }

      console.log("[SendMessage] Message stored successfully in Supabase.");

      // --- Step 3: Store Plaintext Locally in IndexedDB ---
      if (!insertedMessages?.id) {
        console.error(
          "[SendMessage] Failed to get ID of inserted message from Supabase. Cannot store locally."
        );
      } else {
        const messageId = insertedMessages.id;
        const messageForDb = {
          id: messageId, // Use the REAL ID from Supabase
          conversationId: selectedConversation.id,
          senderId: profile.id,
          senderName: profile.full_name || profile.username,
          senderAvatar: profile.avatar_url,
          content: plaintextMessage, // Store PLAINTEXT
          timestamp: new Date().toISOString(), // Store ISO string for consistent sorting
        };
        try {
          await db.messages.put(messageForDb);
          console.log(
            `[SendMessage] Stored outgoing plaintext message locally with ID: ${messageId}`
          );
        } catch (dbError) {
          console.error(
            "[SendMessage] Error storing outgoing message locally in IndexedDB:",
            dbError
          );
          // Consider how to handle this failure - the message IS sent.
        }
      }

      // --- Step 4: Optimistic UI Update ---
      // Keep this for immediate feedback. Reloads will use the data stored in DB.
      setMessages((prev) => [
        ...prev,
        {
          id: crypto.randomUUID(), // Use a temporary ID for the optimistic UI update
          senderId: profile.id,
          senderName: profile.full_name || profile.username,
          senderAvatar: profile.avatar_url,
          content: plaintextMessage, // <-- clear-text
          timestamp: new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }),
          isSelf: true,
          isEncrypted: false, // UI shows plaintext
        },
      ]);
    } catch (err) {
      console.error("[SendMessage] Error during message sending process:", err);
      setError(`Error sending message: ${err.message}`);
      // Restore the input field content if sending fails?
      setNewMessage(plaintextMessage); // Put message back on error
    } finally {
      // setLoadingMessages(false); // Maybe not needed here as insert is quick?
    }

    setNewMessage("");
    setSelectedFile(null);
  };

  const handleFileSelect = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const maxSizeMB = 10;
    if (file.size > maxSizeMB * 1024 * 1024) {
      alert(`File size exceeds ${maxSizeMB}MB limit.`);
      return;
    }

    setSelectedFile(file);
  };

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error("Error logging out:", error);
    } else {
      navigate("/login");
    }
  };

  const handleUserSelect = async (selectedUser) => {
    console.log("Selected user to start chat with:", selectedUser);
    if (!currentUser || !profile) {
      console.error("Current user or profile not loaded.");
      return;
    }
    if (selectedUser.id === currentUser.id) {
      console.warn("Cannot start chat with self.");
      return;
    }

    setIsNewChatModalOpen(false); // Close modal immediately

    try {
      // 1. Check if a conversation already exists
      const existingConversation = conversations.find((conv) => {
        // Check if participants array exists and has exactly 2 participants (for 1-on-1 chat)
        // Adjust this logic if group chats need different handling
        if (!conv.participants || conv.participants.length !== 2) return false;
        // Check if both currentUser and selectedUser are participants
        const hasCurrentUser = conv.participants.some(
          (p) => p.id === currentUser.id
        );
        const hasSelectedUser = conv.participants.some(
          (p) => p.id === selectedUser.id
        );
        return hasCurrentUser && hasSelectedUser;
      });

      if (existingConversation) {
        console.log("Found existing conversation:", existingConversation);
        setSelectedConversation(existingConversation);
      } else {
        console.log("No existing conversation found, creating new one...");
        // 2. Create New Conversation
        const { data: newConvData, error: convInsertError } = await supabase
          .from("conversations")
          .insert({})
          .select()
          .single();

        if (convInsertError) throw convInsertError;
        const newConversationId = newConvData.id;
        console.log("Created new conversation with ID:", newConversationId);

        // 3. Add Participants
        const { error: participantInsertError } = await supabase
          .from("conversation_participants")
          .insert([
            { conversation_id: newConversationId, profile_id: currentUser.id },
            { conversation_id: newConversationId, profile_id: selectedUser.id },
          ]);

        if (participantInsertError) throw participantInsertError;
        console.log("Added participants to new conversation.");

        // 4. Construct new conversation object for UI state
        const newConversationForState = {
          id: newConversationId,
          name: selectedUser.full_name || selectedUser.username, // Use selected user's name for 1-on-1
          lastMessage: "", // No messages yet
          time: "",
          unread: 0,
          avatar: selectedUser.avatar_url, // Use selected user's avatar
          participants: [
            {
              // Current user's profile
              id: profile.id,
              username: profile.username,
              full_name: profile.full_name,
              avatar_url: profile.avatar_url,
              status: profile.status,
            },
            {
              // Selected user's profile (from modal data)
              id: selectedUser.id,
              username: selectedUser.username,
              full_name: selectedUser.full_name,
              avatar_url: selectedUser.avatar_url,
              status: "offline", // Assume offline initially, status updates needed separately
            },
          ],
        };

        // 5. Update State
        setConversations((prev) => [newConversationForState, ...prev]); // Add to beginning
        setSelectedConversation(newConversationForState);
        console.log(
          "Set new conversation as selected:",
          newConversationForState
        );
      }
    } catch (err) {
      console.error("Error starting chat:", err);
      setError("Failed to start chat. " + err.message);
    }
  };

  if (loadingConversations && !profile) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-white">
        Loading...
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-red-400">
        Error: {error}
      </div>
    );
  }

  return (
    <div className="flex h-screen bg-slate-900">
      {/* Sidebar - Chat List */}
      {!isMobile || isMobileMenuOpen ? (
        <AnimatePresence>
          <div
            className={`${
              isMobile ? "absolute z-10 w-full max-w-xs" : "w-80"
            } h-full bg-slate-800 border-r border-slate-700 flex flex-col`}
          >
            {/* Header */}
            <div className="p-4 border-b border-slate-700 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <MessageSquare className="h-5 w-5 text-emerald-400" />
                <h1 className="font-bold text-white">Messages</h1>
              </div>
              <div className="flex gap-2">
                <Dialog
                  open={isNewChatModalOpen}
                  onOpenChange={setIsNewChatModalOpen}
                >
                  <DialogTrigger asChild>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="text-slate-400 hover:text-white"
                    >
                      <Plus className="h-5 w-5" />
                    </Button>
                  </DialogTrigger>
                  <NewChatModal
                    currentUser={currentUser}
                    onUserSelect={handleUserSelect}
                  />
                </Dialog>
                {isMobile && (
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                    onClick={() => setIsMobileMenuOpen(false)}
                  >
                    <ArrowLeft className="h-5 w-5" />
                  </Button>
                )}
              </div>
            </div>

            {/* Search */}
            <div className="p-4 border-b border-slate-700">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                <Input
                  placeholder="Search conversations..."
                  className="pl-9 bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
            </div>

            {/* Chat List Area */}
            <ScrollArea className="flex-1">
              <div className="p-2">
                {filteredConversations.map((conv) => (
                  <div
                    key={conv.id}
                    className={`p-3 rounded-lg cursor-pointer mb-1 hover:bg-slate-700/50 ${
                      selectedConversation?.id === conv.id ? "bg-slate-700" : ""
                    }`}
                    onClick={() => {
                      setSelectedConversation(conv);
                      if (isMobile) setIsMobileMenuOpen(false);
                    }}
                  >
                    <div className="flex items-center gap-3">
                      <Avatar>
                        <AvatarImage
                          src={conv.avatar || "/placeholder.svg"}
                          alt={conv.name}
                        />
                        <AvatarFallback className="bg-emerald-500 text-white">
                          {conv.name
                            ?.split(" ")
                            .map((n) => n[0])
                            .join("") || "??"}
                        </AvatarFallback>
                      </Avatar>
                      <div className="flex-1 min-w-0">
                        <div className="flex justify-between items-center">
                          <h3 className="font-medium text-white truncate">
                            {conv.name}
                          </h3>
                          <span className="text-xs text-slate-400">
                            {conv.time}
                          </span>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-sm text-slate-400 truncate">
                            {conv.lastMessage}
                          </p>
                          {conv.unread > 0 && (
                            <span className="bg-emerald-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                              {conv.unread}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>

            {/* Footer Profile Section */}
            <div className="p-4 border-t border-slate-700 flex items-center justify-between">
              <Link to="/profile" className="flex items-center gap-3">
                <Avatar>
                  <AvatarImage
                    src={
                      profile?.avatar_url ||
                      "/placeholder.svg?height=40&width=40"
                    }
                    alt="Your Avatar"
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {(profile?.full_name || profile?.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="font-medium text-white">
                    {profile?.full_name || profile?.username || "Loading..."}
                  </p>
                  <p className="text-xs text-slate-400">
                    {profile?.status || "Offline"}
                  </p>
                </div>
              </Link>
              <div className="flex gap-1">
                <Link to="/settings">
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                  >
                    <Settings className="h-5 w-5" />
                  </Button>
                </Link>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-slate-400 hover:text-white"
                  onClick={handleLogout}
                >
                  <LogOut className="h-5 w-5" />
                </Button>
              </div>
            </div>
          </div>
        </AnimatePresence>
      ) : null}

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col h-full">
        {/* Chat Header */}
        <div className="p-4 border-b border-slate-700 flex items-center justify-between bg-slate-800">
          <div className="flex items-center gap-3">
            {isMobile && (
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white"
                onClick={() => setIsMobileMenuOpen(true)}
              >
                <Menu className="h-5 w-5" />
              </Button>
            )}

            {selectedConversation && (
              <>
                <Avatar>
                  <AvatarImage
                    src={selectedConversation.avatar || "/placeholder.svg"}
                    alt={selectedConversation.name}
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {selectedConversation.name
                      ?.split(" ")
                      .map((n) => n[0])
                      .join("") || "??"}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <h2 className="font-medium text-white">
                    {selectedConversation.name}
                  </h2>
                  <p className="text-xs text-slate-400">Online</p>
                </div>
              </>
            )}
            {!selectedConversation && !loadingConversations && (
              <div className="text-slate-400">
                Select a conversation to start chatting
              </div>
            )}
          </div>

          {/* More Options Sheet */}
          <Sheet>
            <SheetTrigger asChild disabled={!selectedConversation}>
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white disabled:opacity-50"
              >
                <MoreVertical className="h-5 w-5" />
              </Button>
            </SheetTrigger>
            <SheetContent className="bg-slate-800 border-slate-700 text-white">
              <div className="space-y-4 py-4">
                <div className="flex flex-col items-center gap-2 pb-4 border-b border-slate-700">
                  <Avatar className="h-20 w-20">
                    <AvatarImage
                      src={selectedConversation?.avatar || "/placeholder.svg"}
                      alt={selectedConversation?.name}
                    />
                    <AvatarFallback className="bg-emerald-500 text-white text-xl">
                      {selectedConversation?.name
                        ?.split(" ")
                        .map((n) => n[0])
                        .join("") || "??"}
                    </AvatarFallback>
                  </Avatar>
                  <h3 className="text-xl font-bold">
                    {selectedConversation?.name}
                  </h3>
                  <p className="text-sm text-slate-400">Online</p>
                </div>

                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-slate-400">
                    Options
                  </h4>
                  <div className="space-y-1">
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-white"
                    >
                      <User className="mr-2 h-4 w-4" />
                      View Profile
                    </Button>
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-white"
                    >
                      <MessageSquare className="mr-2 h-4 w-4" />
                      Search in Conversation
                    </Button>
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-red-400 hover:text-red-300 hover:bg-red-900/20"
                    >
                      <LogOut className="mr-2 h-4 w-4" />
                      Delete Conversation
                    </Button>
                  </div>
                </div>
              </div>
            </SheetContent>
          </Sheet>
        </div>

        {/* Messages Area */}
        <ScrollArea className="flex-1 p-4 bg-gradient-to-b from-slate-900 to-slate-800">
          <div className="space-y-4">
            {loadingMessages && (
              <div className="text-center text-slate-400 py-4">
                Loading messages...
              </div>
            )}
            {!loadingMessages &&
              messages.map((message) => (
                <div
                  key={message.id}
                  className={`flex ${
                    message.isSelf ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] ${
                      message.isSelf ? "order-2" : "order-1"
                    }`}
                  >
                    {!message.isSelf && (
                      <div className="flex items-center gap-2 mb-1">
                        <Avatar className="h-6 w-6">
                          <AvatarImage
                            src={message.senderAvatar || "/placeholder.svg"}
                            alt={message.senderName}
                          />
                          <AvatarFallback className="bg-emerald-500 text-white text-xs">
                            {message.senderName
                              ?.split(" ")
                              .map((n) => n[0])
                              .join("") || "??"}
                          </AvatarFallback>
                        </Avatar>
                        <span className="text-xs text-slate-400">
                          {message.senderName}
                        </span>
                      </div>
                    )}
                    <div
                      className={`rounded-lg p-3 ${
                        message.isSelf
                          ? "bg-emerald-500 text-white rounded-tr-none"
                          : "bg-slate-700 text-white rounded-tl-none"
                      }`}
                    >
                      <p>
                        {message.content.startsWith("[File](") ? (
                          // Format: [File](url) filename
                          (() => {
                            const match = message.content.match(
                              /\[File\]\((.*?)\)\s*(.*)/
                            );
                            const url = match?.[1];
                            const name = match?.[2] || "Download File";
                            return (
                              <a
                                href={url}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="underline text-blue-400"
                              >
                                📎 {name}
                              </a>
                            );
                          })()
                        ) : message.content.startsWith("[File] ") ? (
                          // Format: [File] filename (no URL yet — fallback)
                          <span className="text-slate-300">
                            📎 {message.content.slice(7)}
                          </span>
                        ) : (
                          message.content
                        )}
                      </p>
                    </div>
                    <p className="text-xs text-slate-400 mt-1 ${message.isSelf ? 'text-left' : 'text-right'}">
                      {message.timestamp}
                    </p>
                  </div>
                </div>
              ))}
            {!loadingMessages &&
              messages.length === 0 &&
              selectedConversation && (
                <div className="text-center text-slate-500 pt-10">
                  No messages yet. Start the conversation!
                </div>
              )}
            <div ref={messagesEndRef} />
          </div>
          {!selectedConversation && !loadingConversations && (
            <div className="text-center text-slate-500 pt-10">
              Select a conversation to view messages.
            </div>
          )}
        </ScrollArea>

        {/* Message Input */}
        <div className="p-4 border-t border-slate-700 bg-slate-800 relative">
          <form
            onSubmit={(e) => {
              e.preventDefault();
              handleSendMessage();
            }}
            className="flex items-center gap-2"
          >
            <Button
              type="button"
              variant="ghost"
              className="text-slate-400 hover:text-white"
              onClick={() => fileInputRef.current.click()}
            >
              📎
            </Button>

            <input
              type="file"
              ref={fileInputRef}
              style={{ display: "none" }}
              onChange={handleFileSelect}
            />

            <Input
              placeholder="Type a message..."
              className="bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
              value={newMessage}
              onChange={(e) => {
                console.log("Input Disabled Status:", {
                  hasSelected: !!selectedConversation,
                  isLoading: loadingConversations,
                });
                setNewMessage(e.target.value);
              }}
              disabled={!selectedConversation || loadingConversations}
            />
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={() => setShowEmojiPicker((prev) => !prev)}
            >
              😀
            </Button>
            <Button
              type="submit"
              size="icon"
              className="bg-emerald-500 hover:bg-emerald-600 text-white"
              disabled={
                (!newMessage.trim() && !selectedFile) ||
                !selectedConversation ||
                loadingConversations
              }
            >
              <Send className="h-5 w-5" />
            </Button>
          </form>
          {/* --- Emoji Picker Feature --- */}
          {showEmojiPicker && (
            <div className="absolute bottom-24 right-8 z-50">
              <EmojiPicker
                onEmojiClick={(emojiData) => {
                  setNewMessage((prev) => prev + emojiData.emoji);
                }}
              />
            </div>
          )}

          {selectedFile && (
            <div className="text-slate-400 text-xs mt-2 ml-2">
              Attached: {selectedFile.name}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/pages/ProfilePage.jsx
================
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ArrowLeft, Camera } from "lucide-react";
import { motion } from "framer-motion";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Switch } from "@/components/ui/switch";

export default function ProfilePage() {
  const [name, setName] = useState("Your Name");
  const [email, setEmail] = useState("your.email@example.com");
  const [bio, setBio] = useState(
    "I'm a software developer interested in secure communications and privacy."
  );
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  const handleSave = async () => {
    setIsSaving(true);

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));

    setIsEditing(false);
    setIsSaving(false);
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/chat"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Chat
        </Link>
      </header>

      <main className="flex-1 container mx-auto px-4 py-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="max-w-2xl mx-auto"
        >
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="pb-4">
              <div className="flex flex-col sm:flex-row items-center gap-4 sm:gap-6">
                <div className="relative">
                  <Avatar className="h-24 w-24">
                    <AvatarImage
                      src="/placeholder.svg?height=96&width=96"
                      alt="Your Avatar"
                    />
                    <AvatarFallback className="bg-emerald-500 text-white text-2xl">
                      {name
                        .split(" ")
                        .map((n) => n[0])
                        .join("")}
                    </AvatarFallback>
                  </Avatar>
                  <Button
                    size="icon"
                    className="absolute bottom-0 right-0 h-8 w-8 rounded-full bg-emerald-500 hover:bg-emerald-600 text-white"
                  >
                    <Camera className="h-4 w-4" />
                  </Button>
                </div>
                <div className="text-center sm:text-left">
                  <CardTitle className="text-2xl text-white">{name}</CardTitle>
                  <CardDescription className="text-slate-400">
                    {email}
                  </CardDescription>
                </div>
              </div>
            </CardHeader>

            <Tabs defaultValue="profile" className="w-full">
              <TabsList className="grid grid-cols-2 mx-4 bg-slate-700">
                <TabsTrigger
                  value="profile"
                  className="data-[state=active]:bg-slate-600"
                >
                  Profile
                </TabsTrigger>
                <TabsTrigger
                  value="security"
                  className="data-[state=active]:bg-slate-600"
                >
                  Security
                </TabsTrigger>
              </TabsList>

              <TabsContent value="profile" className="p-0">
                <CardContent className="p-6">
                  {isEditing ? (
                    <form className="space-y-4">
                      <div className="space-y-2">
                        <Label htmlFor="name" className="text-slate-200">
                          Full Name
                        </Label>
                        <Input
                          id="name"
                          value={name}
                          onChange={(e) => setName(e.target.value)}
                          className="bg-slate-900/50 border-slate-700 text-slate-200"
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor="email" className="text-slate-200">
                          Email
                        </Label>
                        <Input
                          id="email"
                          type="email"
                          value={email}
                          onChange={(e) => setEmail(e.target.value)}
                          className="bg-slate-900/50 border-slate-700 text-slate-200"
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor="bio" className="text-slate-200">
                          Bio
                        </Label>
                        <textarea
                          id="bio"
                          value={bio}
                          onChange={(e) => setBio(e.target.value)}
                          rows={4}
                          className="w-full rounded-md bg-slate-900/50 border border-slate-700 text-slate-200 p-2"
                        />
                      </div>
                    </form>
                  ) : (
                    <div className="space-y-4">
                      <div>
                        <h3 className="text-sm font-medium text-slate-400 mb-1">
                          Full Name
                        </h3>
                        <p className="text-white">{name}</p>
                      </div>

                      <div>
                        <h3 className="text-sm font-medium text-slate-400 mb-1">
                          Email
                        </h3>
                        <p className="text-white">{email}</p>
                      </div>

                      <div>
                        <h3 className="text-sm font-medium text-slate-400 mb-1">
                          Bio
                        </h3>
                        <p className="text-white">{bio}</p>
                      </div>
                    </div>
                  )}
                </CardContent>

                <CardFooter className="flex justify-end gap-2 p-6 pt-0">
                  {isEditing ? (
                    <>
                      <Button
                        variant="outline"
                        className="border-slate-600 text-slate-200 hover:bg-slate-700"
                        onClick={() => setIsEditing(false)}
                        disabled={isSaving}
                      >
                        Cancel
                      </Button>
                      <Button
                        className="bg-emerald-500 hover:bg-emerald-600 text-white"
                        onClick={handleSave}
                        disabled={isSaving}
                      >
                        {isSaving ? "Saving..." : "Save Changes"}
                      </Button>
                    </>
                  ) : (
                    <Button
                      className="bg-emerald-500 hover:bg-emerald-600 text-white"
                      onClick={() => setIsEditing(true)}
                    >
                      Edit Profile
                    </Button>
                  )}
                </CardFooter>
              </TabsContent>

              <TabsContent value="security" className="p-0">
                <CardContent className="p-6 space-y-6">
                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">Password</h3>
                    <Button
                      variant="outline"
                      className="border-slate-600 text-slate-200 hover:bg-slate-700"
                    >
                      Change Password
                    </Button>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">
                      Two-Factor Authentication
                    </h3>
                    <div className="flex items-center justify-between">
                      <div>
                        <p className="text-slate-200">
                          Protect your account with 2FA
                        </p>
                        <p className="text-sm text-slate-400">
                          Add an extra layer of security
                        </p>
                      </div>
                      <Switch />
                    </div>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">
                      Session Management
                    </h3>
                    <Button
                      variant="outline"
                      className="border-slate-600 text-slate-200 hover:bg-slate-700"
                    >
                      Sign Out All Devices
                    </Button>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">
                      Account Deletion
                    </h3>
                    <Button
                      variant="destructive"
                      className="bg-red-900/20 hover:bg-red-900/40 text-red-400"
                    >
                      Delete Account
                    </Button>
                  </div>
                </CardContent>
              </TabsContent>
            </Tabs>
          </Card>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/SettingsPage.jsx
================
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  ArrowLeft,
  Bell,
  Globe,
  Lock,
  Moon,
  Shield,
  Sun,
  Volume2,
} from "lucide-react";
// eslint-disable-next-line
import { motion } from "framer-motion";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";

export default function SettingsPage() {
  const [darkMode, setDarkMode] = useState(true);
  const [notifications, setNotifications] = useState(true);
  const [sounds, setSounds] = useState(true);
  const [readReceipts, setReadReceipts] = useState(true);
  const [language, setLanguage] = useState("english");
  const [volume, setVolume] = useState([70]);

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/chat"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Chat
        </Link>
      </header>

      <main className="flex-1 container mx-auto px-4 py-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="max-w-2xl mx-auto"
        >
          <h1 className="text-3xl font-bold text-white mb-6">Settings</h1>

          <div className="space-y-6">
            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Sun className="h-5 w-5 text-emerald-400" />
                  Appearance
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Customize how SecureChat looks
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Dark Mode</Label>
                    <p className="text-sm text-slate-400">
                      Toggle between light and dark themes
                    </p>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Sun className="h-4 w-4 text-slate-400" />
                    <Switch checked={darkMode} onCheckedChange={setDarkMode} />
                    <Moon className="h-4 w-4 text-slate-400" />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label className="text-slate-200">Language</Label>
                  <Select value={language} onValueChange={setLanguage}>
                    <SelectTrigger className="bg-slate-900/50 border-slate-700 text-slate-200">
                      <SelectValue placeholder="Select language" />
                    </SelectTrigger>
                    <SelectContent className="bg-slate-800 border-slate-700 text-slate-200">
                      <SelectItem value="english">English</SelectItem>
                      <SelectItem value="spanish">Spanish</SelectItem>
                      <SelectItem value="french">French</SelectItem>
                      <SelectItem value="german">German</SelectItem>
                      <SelectItem value="japanese">Japanese</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </CardContent>
            </Card>

            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Bell className="h-5 w-5 text-emerald-400" />
                  Notifications
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Manage how you receive notifications
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Push Notifications</Label>
                    <p className="text-sm text-slate-400">
                      Receive notifications when you're not active
                    </p>
                  </div>
                  <Switch
                    checked={notifications}
                    onCheckedChange={setNotifications}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Sound Effects</Label>
                    <p className="text-sm text-slate-400">
                      Play sounds for new messages and calls
                    </p>
                  </div>
                  <Switch checked={sounds} onCheckedChange={setSounds} />
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <Label className="text-slate-200">
                      Notification Volume
                    </Label>
                    <span className="text-sm text-slate-400">{volume[0]}%</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <Volume2 className="h-4 w-4 text-slate-400" />
                    <Slider
                      value={volume}
                      onValueChange={setVolume}
                      max={100}
                      step={1}
                      className="flex-1"
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Shield className="h-5 w-5 text-emerald-400" />
                  Privacy & Security
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Manage your privacy and security settings
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Read Receipts</Label>
                    <p className="text-sm text-slate-400">
                      Let others know when you've read their messages
                    </p>
                  </div>
                  <Switch
                    checked={readReceipts}
                    onCheckedChange={setReadReceipts}
                  />
                </div>

                <div className="space-y-0.5">
                  <Label className="text-slate-200">Encryption Key</Label>
                  <div className="flex items-center gap-2">
                    <div className="bg-slate-900/50 border border-slate-700 rounded-md p-2 text-slate-400 text-sm font-mono flex-1 truncate">
                      a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      className="border-slate-600 text-slate-200 hover:bg-slate-700"
                    >
                      Rotate
                    </Button>
                  </div>
                  <p className="text-xs text-slate-400 mt-1">
                    Your encryption key is stored locally and never sent to our
                    servers
                  </p>
                </div>

                <Button
                  variant="outline"
                  className="w-full border-slate-600 text-slate-200 hover:bg-slate-700"
                >
                  <Lock className="mr-2 h-4 w-4" />
                  Advanced Security Settings
                </Button>
              </CardContent>
            </Card>

            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Globe className="h-5 w-5 text-emerald-400" />
                  About
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Information about SecureChat
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-1">
                    Version
                  </h3>
                  <p className="text-white">1.0.0</p>
                </div>

                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-1">
                    Terms of Service
                  </h3>
                  <Link
                    to="/terms"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Read our Terms of Service
                  </Link>
                </div>

                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-1">
                    Privacy Policy
                  </h3>
                  <Link
                    to="/privacy"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Read our Privacy Policy
                  </Link>
                </div>
              </CardContent>
            </Card>
          </div>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/SignupPage.jsx
================
import { useState } from "react";
import { useNavigate, Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { AlertCircle, ArrowLeft, Lock, Shield } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { supabase } from "../lib/supabaseClient";

export default function SignupPage() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!name || !email || !password || !confirmPassword) {
      setError("All fields are required");
      return;
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    if (password.length < 8) {
      setError("Password must be at least 8 characters long");
      return;
    }

    setIsLoading(true);

    try {
      const { data: signUpData, error: signUpError } =
        await supabase.auth.signUp({
          email: email,
          password: password,
        });

      if (signUpError) {
        if (signUpError.message.includes("User already registered")) {
          setError("This email is already registered. Please try logging in.");
        } else {
          setError(signUpError.message);
        }
        setIsLoading(false);
        return;
      }

      if (!signUpData.user) {
        throw new Error("Signup process did not return user data.");
      }

      const newUser = signUpData.user;
      console.log("Signup successful, user:", newUser);

      console.log(`Upserting profile for user ${newUser.id}...`);
      const { error: profileError } = await supabase.from("profiles").upsert(
        {
          id: newUser.id,
          full_name: name,
          username: email,
        },
        { onConflict: "id" }
      );

      if (profileError) {
        console.error("Error upserting profile:", profileError);
        throw new Error(
          `Failed to create/update user profile: ${profileError.message}`
        );
      }
      console.log(`Profile upserted successfully for user ${newUser.id}.`);

      console.log(`Checking for existing key bundle for user ${newUser.id}...`);
      const { data: existingKeys, error: keyCheckError } = await supabase
        .from("prekey_bundles")
        .select("user_id")
        .eq("user_id", newUser.id)
        .maybeSingle();

      if (keyCheckError) {
        console.error("Error checking for existing keys:", keyCheckError);
        throw new Error(
          `Failed to check for existing encryption keys: ${keyCheckError.message}`
        );
      }

      if (!existingKeys) {
        console.log(
          `No existing keys found. User ${newUser.id} will register keys via SignalProvider on chat page load.`
        );

        // Check if user needs email confirmation
        if (
          signUpData.session &&
          signUpData.session.user.email_confirmed_at === null
        ) {
          setError(
            "Account created! Please check your email to confirm your account before logging in."
          );
          // Optionally sign the user out until confirmed
          // await supabase.auth.signOut();
        } else if (signUpData.user) {
          // User might be auto-confirmed or already confirmed
          console.log("Navigating to chat...");
          navigate("/chat");
        } else {
          // Should not happen if signup succeeded, but handle defensively
          setError(
            "Signup seems complete, but login state is unclear. Please try logging in or check your email."
          );
        }
      } else {
        // This block handles the case where keys *already* exist
        console.log(
          `Encryption keys already exist for user ${newUser.id}. Skipping generation.`
        );
        // If keys exist, the user should be okay to proceed
        console.log("Existing keys found. Navigating to chat...");
        navigate("/chat");
      }
    } catch (err) {
      // This outer catch handles errors from Supabase signup or profile upsert primarily
      console.error("Error during sign up process (before key gen):", err);
      if (!error) {
        // Avoid overwriting specific errors like 'email exists'
        setError(`Signup failed: ${err.message || "Please try again."}`);
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Home
        </Link>
      </header>

      <main className="flex-1 flex items-center justify-center p-4">
        <div className="w-full max-w-md">
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-2">
                <div className="relative">
                  <Lock className="h-8 w-8 text-emerald-400" />
                  <div className="absolute -top-1 -right-1 bg-emerald-400 rounded-full p-1">
                    <Shield className="h-3 w-3 text-slate-900" />
                  </div>
                </div>
              </div>
              <CardTitle className="text-2xl text-center text-white">
                Create an account
              </CardTitle>
              <CardDescription className="text-center text-slate-400">
                Enter your details to get started with SecureChat
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <Alert
                  variant="destructive"
                  className="mb-4 bg-red-900/20 border-red-800 text-red-300"
                >
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              <form onSubmit={handleSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="name" className="text-slate-200">
                    Full Name
                  </Label>
                  <Input
                    id="name"
                    placeholder="John Doe"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="email" className="text-slate-200">
                    Email
                  </Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="name@example.com"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="password" className="text-slate-200">
                    Password
                  </Label>
                  <Input
                    id="password"
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="confirmPassword" className="text-slate-200">
                    Confirm Password
                  </Label>
                  <Input
                    id="confirmPassword"
                    type="password"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="text-xs text-slate-400">
                  By creating an account, you agree to our{" "}
                  <Link
                    to="/terms"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Terms of Service
                  </Link>{" "}
                  and{" "}
                  <Link
                    to="/privacy"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Privacy Policy
                  </Link>
                </div>

                <Button
                  type="submit"
                  className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
                  disabled={isLoading}
                >
                  {isLoading ? "Creating account..." : "Create account"}
                </Button>
              </form>
            </CardContent>
            <CardFooter className="flex justify-center">
              <p className="text-sm text-slate-400">
                Already have an account?{" "}
                <Link
                  to="/login"
                  className="text-emerald-400 hover:text-emerald-300"
                >
                  Sign in
                </Link>
              </p>
            </CardFooter>
          </Card>
        </div>
      </main>
    </div>
  );
}

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    // ...
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
    // ...
  }
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

================
File: vite.config.js
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "path";
import { fileURLToPath } from "url";

// Get the directory name in an ES module context
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
