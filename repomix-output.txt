This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-09T08:51:00.965Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
.vite/deps/_metadata.json
.vite/deps/package.json
api.js
api/_supabase.js
api/device/[deviceId].js
api/device/register.js
api/index.js
api/signal/bundles/[userId].js
components.json
eslint.config.js
index.html
lib/cors.js
package.json
public/vite.svg
README.md
src/App.jsx
src/assets/react.svg
src/components/NewChatModal.jsx
src/components/ui/alert.tsx
src/components/ui/avatar.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/dialog.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/sheet.tsx
src/components/ui/slider.tsx
src/components/ui/switch.tsx
src/components/ui/tabs.tsx
src/hooks/use-mobile.js
src/index.css
src/lib/backend.js
src/lib/db.js
src/lib/localDb.js
src/lib/signalContext.jsx
src/lib/signalCrypto.js
src/lib/signalUtils.js
src/lib/supabaseClient.js
src/lib/utils.ts
src/main.jsx
src/pages/AboutPage.jsx
src/pages/ChatPage.jsx
src/pages/CryptoTestPage.jsx
src/pages/ForgotPasswordPage.jsx
src/pages/HomePage.jsx
src/pages/LoginPage.jsx
src/pages/nehahelp.jsx
src/pages/ProfilePage.jsx
src/pages/SettingsPage.jsx
src/pages/SignupPage.jsx
tsconfig.app.json
tsconfig.json
vite.config.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

/frontend/.env
.env

.cursor

repomix-output.txt
.vercel

================
File: .vite/deps/_metadata.json
================
{
  "hash": "f9adf7a4",
  "configHash": "e6e6f40b",
  "lockfileHash": "1a8da3de",
  "browserHash": "2a038793",
  "optimized": {},
  "chunks": {}
}

================
File: .vite/deps/package.json
================
{
  "type": "module"
}

================
File: api.js
================
// api.js -----------------------------------------------------------
const API = "http://localhost:3001";

async function post(path, payload) {
  const res = await fetch(`${API}${path}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const text = await res.text(); // easier to read error
    throw new Error(`HTTP ${res.status}: ${text}`);
  }
  return res.json();
}

// exported high-level helpers
export const api = {
  genKeys: (user_id) => post("/api/keys/generate", { user_id }),
  initSess: (sender_id, recipient_id) =>
    post("/api/sessions/initiate", { sender_id, recipient_id }),
  encrypt: (sender_id, recipient_id, plaintext) =>
    post("/api/messages/encrypt", { sender_id, recipient_id, plaintext }),
  decrypt: (recipient_id, sender_id, header_b64, ciphertext_b64) =>
    post("/api/messages/decrypt", {
      recipient_id,
      sender_id,
      header_b64,
      ciphertext_b64,
    }),
};

================
File: api/_supabase.js
================
// api/_supabase.js
import { createClient } from "@supabase/supabase-js";
import "dotenv/config";

// these **must** be set in your Vercel Environment Variables
const URL = process.env.SUPABASE_URL;
const KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
if (!URL || !KEY) {
  throw new Error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY env vars");
}

export const supabaseAdmin = createClient(URL, KEY);

================
File: api/device/[deviceId].js
================
// api/device/[deviceId].js
import { supabaseAdmin } from "../_supabase.js";
import { cors } from "../../lib/cors.js";

export default cors(async function handler(req, res) {
  const { deviceId } = req.query;

  if (req.method !== "DELETE") {
    res.setHeader("Allow", "DELETE");
    return res.status(405).end();
  }

  try {
    // delete bundle first
    let { error: bundleErr } = await supabaseAdmin
      .from("bundles")
      .delete()
      .eq("device_id", deviceId);

    if (bundleErr) throw bundleErr;

    // delete device
    const { error: devErr } = await supabaseAdmin
      .from("devices")
      .delete()
      .eq("device_id", deviceId);

    if (devErr) throw devErr;

    return res.status(204).end();
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: err.message });
  }
});

================
File: api/device/register.js
================
// api/device/register.js
import { supabaseAdmin } from "../_supabase.js";
import { cors } from "../../lib/cors.js";

export default cors(async function handler(req, res) {
  if (req.method !== "POST") {
    res.setHeader("Allow", "POST");
    return res.status(405).end();
  }

  const {
    userId,
    registrationId,
    identityKey,
    signedPreKeyId,
    signedPreKeyPublicKey,
    signedPreKeySignature,
    preKeyId,
    preKeyPublicKey,
  } = req.body;

  try {
    // 1️⃣ Create device row
    const { data: deviceData, error: deviceError } = await supabaseAdmin
      .from("devices")
      .insert({ user_id: userId })
      .select("device_id")
      .single();

    if (deviceError || !deviceData) {
      console.error("Error inserting device:", deviceError);
      throw new Error("Device registration failed");
    }
    const deviceId = deviceData.device_id;

    // 2️⃣ Upsert bundle
    const { error: upsertError } = await supabaseAdmin.from("bundles").upsert(
      {
        device_id: deviceId,
        registration_id: registrationId,
        identity_key_b64: identityKey,
        signed_pre_key_id: signedPreKeyId,
        signed_pre_key_public_b64: signedPreKeyPublicKey,
        signed_pre_key_sig_b64: signedPreKeySignature,
        pre_key_id: preKeyId,
        pre_key_public_b64: preKeyPublicKey,
      },
      { onConflict: "device_id" }
    );

    if (upsertError) {
      console.error("Error upserting bundle:", upsertError);
      throw new Error("Bundle upsert failed");
    }

    return res.status(200).json({ deviceId });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: err.message });
  }
});

================
File: api/index.js
================
// api/index.js
import { cors } from "../lib/cors.js";

async function handler(req, res) {
  res.status(200).json({ message: "Secure Chat Backend (JS)" });
}

export default cors(handler);

================
File: api/signal/bundles/[userId].js
================
// api/signal/bundles/[userId].js
import { supabaseAdmin } from "../../_supabase.js";
import { cors } from "../../../lib/cors.js";

export default cors(async function handler(req, res) {
  const { userId } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", "GET");
    return res.status(405).end();
  }

  try {
    // fetch devices
    const { data: devices, error: devErr } = await supabaseAdmin
      .from("devices")
      .select("device_id")
      .eq("user_id", userId);

    if (devErr) throw devErr;

    const deviceIds = devices.map((d) => d.device_id);
    if (deviceIds.length === 0) {
      return res.status(200).json([]);
    }

    // fetch bundles
    const { data: bundles, error: bundleErr } = await supabaseAdmin
      .from("bundles")
      .select(
        `
        device_id,
        registration_id,
        identity_key_b64,
        signed_pre_key_id,
        signed_pre_key_public_b64,
        signed_pre_key_sig_b64,
        pre_key_id,
        pre_key_public_b64
      `
      )
      .in("device_id", deviceIds);

    if (bundleErr) throw bundleErr;

    // shape response
    const response = bundles.map((b) => ({
      deviceId: b.device_id,
      registrationId: b.registration_id,
      identityKey: b.identity_key_b64,
      signedPreKeyId: b.signed_pre_key_id,
      signedPreKeyPublicKey: b.signed_pre_key_public_b64,
      signedPreKeySignature: b.signed_pre_key_sig_b64,
      preKeyId: b.pre_key_id,
      preKeyPublicKey: b.pre_key_public_b64,
    }));

    return res.status(200).json(response);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: err.message });
  }
});

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: lib/cors.js
================
// lib/cors.js
import Cors from "micro-cors";

export const cors = Cors({
  allowMethods: ["GET", "POST", "DELETE", "OPTIONS"],
  allowHeaders: ["Content-Type", "Authorization"],
  origin: ["http://localhost:5173", "https://dds-secure-chat-web.vercel.app"],
});

================
File: package.json
================
{
  "name": "secure_chat_ruc",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@privacyresearch/libsignal-protocol-typescript": "^0.0.16",
    "@radix-ui/react-avatar": "^1.1.7",
    "@radix-ui/react-dialog": "^1.1.11",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-scroll-area": "^1.2.6",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-slider": "^1.3.2",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.2.2",
    "@radix-ui/react-tabs": "^1.1.9",
    "@signalapp/libsignal-client": "^0.70.1",
    "@supabase/supabase-js": "^2.49.4",
    "@tailwindcss/vite": "^4.1.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dexie": "^4.0.11",
    "dotenv": "^16.5.0",
    "emoji-picker-react": "^4.12.2",
    "framer-motion": "^12.9.1",
    "from": "^0.1.7",
    "idb-keyval": "^6.2.1",
    "import": "^0.0.6",
    "lucide-react": "^0.503.0",
    "micro-cors": "^0.1.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.5.2",
    "signal": "^7.0.6",
    "tailwind-merge": "^3.2.0",
    "tailwindcss": "^4.1.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@types/node": "^22.14.1",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "tw-animate-css": "^1.2.8",
    "vite": "^6.3.1"
  }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

================
File: src/App.jsx
================
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { useState, useEffect } from "react";
import "./index.css";
import HomePage from "./pages/HomePage"; // Import the HomePage
import SignupPage from "./pages/SignupPage"; // Import the SignupPage
import SettingsPage from "./pages/SettingsPage"; // Import the SettingsPage
import ProfilePage from "./pages/ProfilePage"; // Import the ProfilePage
import LoginPage from "./pages/LoginPage"; // Import the LoginPage
import ForgotPasswordPage from "./pages/ForgotPasswordPage"; // Import the ForgotPasswordPage
import ChatPage from "./pages/ChatPage"; // Import the ChatPage
import CryptoTestPage from "./pages/CryptoTestPage"; // Import the CryptoTestPage
import AboutPage from "./pages/AboutPage"; // Import the AboutPage
import { supabase } from "./lib/supabaseClient"; // Assuming client is exported as supabase
import { SignalProvider } from "./lib/signalContext";

function App() {
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setLoading(false);
    });

    // Listen for auth state changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
    });

    // Cleanup subscription on unmount
    return () => subscription.unsubscribe();
  }, []);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-white">
        Loading Session...
      </div>
    );
  }

  return (
    <SignalProvider userId={session?.user?.id}>
      <Router>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/crypto-test" element={<CryptoTestPage />} />
          {/* <Route path="/signup" element={<SignupPage />} /> No need for signup if logged in */}
          <Route path="/settings" element={<SettingsPage />} />
          <Route path="/profile" element={<ProfilePage />} />
          {/* <Route path="/login" element={<LoginPage />} /> No need for login if logged in */}
          {/* <Route path="/forgot-password" element={<ForgotPasswordPage />} /> No need if logged in */}
          <Route path="/chat" element={<ChatPage />} />
          <Route path="/signup" element={<SignupPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/about" element={<AboutPage />} />
        </Routes>
      </Router>
    </SignalProvider>
  );
}

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/NewChatModal.jsx
================
import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { supabase } from "../lib/supabaseClient";
import { Button } from "./ui/button";

export default function NewChatModal({ currentUser, onUserSelect }) {
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const handler = setTimeout(() => {
      if (searchQuery.trim().length > 1) {
        performSearch();
      } else {
        setSearchResults([]);
      }
    }, 500);

    return () => {
      clearTimeout(handler);
    };
  }, [searchQuery, currentUser]);

  const performSearch = async () => {
    if (!currentUser || !searchQuery.trim()) return;

    setLoading(true);
    setError(null);
    try {
      const searchTerm = `%${searchQuery.trim()}%`;
      const { data, error: searchError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url")
        .or(`username.ilike.${searchTerm},full_name.ilike.${searchTerm}`)
        .neq("id", currentUser.id)
        .limit(10);

      if (searchError) throw searchError;

      setSearchResults(data || []);
    } catch (err) {
      console.error("Error searching users:", err);
      setError("Failed to search users.");
      setSearchResults([]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <DialogContent className="bg-slate-800 border-slate-700 text-white sm:max-w-[425px]">
      <DialogHeader>
        <DialogTitle>Start New Chat</DialogTitle>
        <DialogDescription>
          Search for users by username or full name.
        </DialogDescription>
      </DialogHeader>
      <div className="p-0">
        <Input
          placeholder="Search users..."
          className="mb-4 bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
        />
        <ScrollArea className="h-[300px]">
          {loading && (
            <p className="text-center text-slate-400">Searching...</p>
          )}
          {error && <p className="text-center text-red-400">{error}</p>}
          {!loading &&
            searchResults.length === 0 &&
            searchQuery.trim().length > 1 && (
              <p className="text-center text-slate-400">No users found.</p>
            )}
          {!loading &&
            searchResults.map((user) => (
              <div
                key={user.id}
                className="flex items-center gap-3 p-2 mb-1 rounded-md hover:bg-slate-700 cursor-pointer"
                onClick={() => onUserSelect(user)}
              >
                <Avatar className="h-9 w-9">
                  <AvatarImage
                    src={user.avatar_url || "/placeholder.svg"}
                    alt={user.username}
                  />
                  <AvatarFallback className="bg-emerald-600">
                    {(user.full_name || user.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")
                      .toUpperCase()}
                  </AvatarFallback>
                </Avatar>
                <div className="flex-1 min-w-0">
                  <p className="font-medium truncate">
                    {user.full_name || user.username}
                  </p>
                  {user.full_name && user.username && (
                    <p className="text-sm text-slate-400 truncate">
                      @{user.username}
                    </p>
                  )}
                </div>
              </div>
            ))}
        </ScrollArea>
      </div>
    </DialogContent>
  );
}

================
File: src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

================
File: src/components/ui/avatar.tsx
================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

================
File: src/components/ui/dialog.tsx
================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

================
File: src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: src/components/ui/label.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: src/components/ui/scroll-area.tsx
================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

================
File: src/components/ui/select.tsx
================
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

================
File: src/components/ui/sheet.tsx
================
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: src/components/ui/slider.tsx
================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }

================
File: src/components/ui/switch.tsx
================
import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }

================
File: src/components/ui/tabs.tsx
================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: src/hooks/use-mobile.js
================
import { useState, useEffect } from "react";

export const useMobile = () => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth < 768); // Adjust breakpoint as needed
    };

    // Set initial value
    handleResize();

    // Listen for window resize events
    window.addEventListener("resize", handleResize);

    // Clean up event listener on unmount
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  return isMobile;
};

================
File: src/index.css
================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/lib/backend.js
================
const API = import.meta.env.VITE_BACKEND_URL;

/** POST helper that automatically JSON-encodes the body */
export async function post(path, payload) {
  const res = await fetch(`${API}${path}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    // try to surface backend error message
    let msg = `HTTP ${res.status}`;
    try {
      const errorData = await res.json();
      if (errorData && errorData.message) {
        msg += ": " + errorData.message;
      }
    } catch {
      /* ignore JSON parsing error if response is not JSON */
    }
    throw new Error(msg);
  }
  return res.json();
}

/** GET helper */
export async function get(path) {
  const res = await fetch(`${API}${path}`);
  if (!res.ok) {
    // try to surface backend error message
    let msg = `HTTP ${res.status}`;
    // Add specific handling for 404 (bundle not found)
    if (res.status === 404) {
      msg = `Not found: ${path}`;
      try {
        const errorData = await res.json();
        if (errorData && errorData.detail) {
          msg += `: ${errorData.detail}`;
        }
      } catch {
        /* ignore JSON parsing error */
      }
      // Throw a specific error type or just the message
      // For simplicity, just throwing the message
    } else {
      // Generic error handling for other statuses
      try {
        const errorData = await res.json();
        if (errorData && errorData.detail) {
          // Use detail if available from FastAPI
          msg += `: ${errorData.detail}`;
        } else if (errorData && errorData.message) {
          msg += ": " + errorData.message;
        }
      } catch {
        /* ignore JSON parsing error if response is not JSON */
      }
    }
    throw new Error(msg);
  }
  return res.json();
}

/** wrapper used by signup / login to make sure keys exist */
//export const ensureKeys = (user_id) => post("/api/keys/generate", { user_id });

================
File: src/lib/db.js
================
// src/lib/db.js
import Dexie from "dexie";

export const db = new Dexie("secureChatDatabase");

// Increment version number for schema change
db.version(2)
  .stores({
    // Keep existing indexes, ensure 'id' is primary key (auto-handled if first field without '++')
    // Add 'content' field to store plaintext for sent messages
    messages: "id, conversationId, timestamp, content", // Add 'content'
  })
  .upgrade(() => {
    // No specific migration needed for just adding a field if Dexie handles it,
    // but keep the upgrade function structure.
    console.log("Upgrading Dexie schema to version 2 (added content field)");
  });

// Example usage (can add helper functions here later if needed)
// export async function addMessage(message) {
//   await db.messages.put(message); // put handles add or update
// }

// export async function getMessagesForConversation(conversationId) {
//   return await db.messages
//     .where('conversationId')
//     .equals(conversationId)
//     .sortBy('timestamp');
// }

// Helper function to add/update message with plaintext
export async function cacheSentMessage(message) {
  // message should contain id, conversationId, timestamp, content, etc.
  // Ensure you pass the PLAINTEXT content here.
  console.log(
    `[Dexie Cache] Caching sent message ${message.id}:`,
    message.content
  );
  try {
    const putKey = await db.messages.put(message);
    console.log(
      `[Dexie Cache] Successfully put message ${message.id} with key:`,
      putKey
    );
  } catch (error) {
    console.error(`[Dexie Cache] Error putting message ${message.id}:`, error);
    // Optionally re-throw or handle as needed
  }
}

// Helper function to get cached message plaintext
export async function getCachedMessageContent(messageId) {
  const cachedMsg = await db.messages.get(messageId);
  console.log(
    `[Dexie Cache] Cache lookup for ${messageId}: ${
      cachedMsg ? "Found" : "Not Found"
    }`
  );
  return cachedMsg?.content; // Return only the content or undefined
}

================
File: src/lib/localDb.js
================
// import * as signal from "@privacyresearch/libsignal-protocol-typescript"; // REMOVED: No longer needed here

const DB_NAME = "SecureChatDB";
const DB_VERSION = 1;
const KEY_STORE_NAME = "signalKeys";
const SESSION_STORE_NAME = "signalSessions";
// Add other stores as needed by the SignalProtocolStore interface
const PREKEY_STORE_NAME = "signalPreKeys";
const SIGNED_PREKEY_STORE_NAME = "signalSignedPreKeys";
const IDENTITY_STORE_NAME = "signalIdentity"; // For identity key pair

let dbPromise = null;

function getDb() {
  if (!dbPromise) {
    dbPromise = new Promise((resolve, reject) => {
      console.log(`Opening IndexedDB: ${DB_NAME} version ${DB_VERSION}`);
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = (event) => {
        console.error("IndexedDB error:", event.target.error);
        reject(`IndexedDB error: ${event.target.error}`);
      };

      request.onsuccess = (event) => {
        console.log("IndexedDB opened successfully.");
        const db = event.target.result; // Get the DB instance

        // --- Add event listeners to the DB connection itself --- START ---
        db.onclose = () => {
          console.warn("IndexedDB connection closed unexpectedly.");
          dbPromise = null; // Reset promise so it reopens on next call
        };
        db.onerror = (event) => {
          // Log errors that occur on the connection after it's opened
          console.error(
            "Unhandled IndexedDB database error:",
            event.target.error
          );
          // Optionally close and reset
          dbPromise = null;
        };
        db.onversionchange = () => {
          // Handle requests to upgrade the DB from other tabs/windows
          console.warn(
            "IndexedDB version change requested. Closing old connection..."
          );
          db.close(); // Close the current connection to allow the upgrade
          dbPromise = null; // Reset promise
        };
        // --- Add event listeners to the DB connection itself --- END ---

        resolve(db); // Resolve the promise with the db instance
      };

      // This event only executes if the version number changes
      // or the database is created for the first time.
      request.onupgradeneeded = (event) => {
        console.log("IndexedDB upgrade needed.");
        const db = event.target.result;
        if (!db.objectStoreNames.contains(KEY_STORE_NAME)) {
          console.log(`Creating object store: ${KEY_STORE_NAME}`);
          // Simple key-value store for general keys/data
          db.createObjectStore(KEY_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(SESSION_STORE_NAME)) {
          console.log(`Creating object store: ${SESSION_STORE_NAME}`);
          // Store sessions by address (recipientId.deviceId)
          db.createObjectStore(SESSION_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(PREKEY_STORE_NAME)) {
          console.log(`Creating object store: ${PREKEY_STORE_NAME}`);
          // Store preKeys by keyId
          db.createObjectStore(PREKEY_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(SIGNED_PREKEY_STORE_NAME)) {
          console.log(`Creating object store: ${SIGNED_PREKEY_STORE_NAME}`);
          // Store signedPreKeys by keyId
          db.createObjectStore(SIGNED_PREKEY_STORE_NAME);
        }
        if (!db.objectStoreNames.contains(IDENTITY_STORE_NAME)) {
          console.log(`Creating object store: ${IDENTITY_STORE_NAME}`);
          // Store identity key pair (only one entry expected)
          db.createObjectStore(IDENTITY_STORE_NAME);
        }
        console.log("IndexedDB upgrade complete.");
      };
    });
  }
  return dbPromise;
}

// --- Helper function to perform DB operations ---
async function performDbOperation(storeName, mode, operation) {
  const db = await getDb();
  return new Promise((resolve, reject) => {
    let requestResult = undefined; // Variable to store result from request.onsuccess

    // --- Wrap transaction creation in try-catch --- START ---
    try {
      const transaction = db.transaction(storeName, mode);
      const store = transaction.objectStore(storeName);

      // Add logging for transaction aborts
      transaction.onabort = (event) => {
        console.error(
          `IndexedDB transaction ABORTED on ${storeName} (Mode: ${mode}):`,
          event.target.error
        );
        reject(
          event.target.error || new Error(`Transaction aborted on ${storeName}`)
        );
      };

      const request = operation(store);

      request.onsuccess = (event) => {
        // Store the result for read operations or if needed
        requestResult = event.target.result;
        // For read operations, we could resolve here, but waiting for
        // transaction complete is safer even for reads if subsequent
        // operations depend on this read finishing *within its transaction*.
        // Let's simplify and always resolve on transaction complete/error.
      };
      request.onerror = (event) => {
        console.error(
          `IndexedDB request error on ${storeName} (Mode: ${mode}):`,
          event.target.error
        );
        // Don't reject here, let transaction.onerror handle it to ensure
        // the transaction error bubbles up properly.
      };

      transaction.oncomplete = () => {
        // Transaction succeeded, resolve with the stored result
        console.debug(
          `IndexedDB transaction complete on ${storeName}. Mode: ${mode}.`
        );
        resolve(requestResult);
      };
      transaction.onerror = (event) => {
        console.error(
          `IndexedDB transaction error on ${storeName} (Mode: ${mode}):`,
          event.target.error
        );
        reject(event.target.error); // Reject promise on transaction error
      };
    } catch (err) {
      console.error(
        `Error initiating transaction on ${storeName} (Mode: ${mode}):`,
        err
      );
      // Check if the error is the specific connection closing error
      if (err instanceof DOMException && err.name === "InvalidStateError") {
        console.warn(
          "Database connection was closed when trying to start transaction. Resetting promise..."
        );
        // Reset dbPromise to force re-initialization on next call
        dbPromise = null;
        // Reject with a specific error message
        reject(
          new Error(
            "Database connection was closed. Please retry the operation."
          )
        );
      } else {
        reject(err); // Re-throw other errors
      }
    }
    // --- Wrap transaction creation in try-catch --- END ---
  });
}

// --- Base64 Helpers ---
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function base64ToArrayBuffer(base64) {
  const binary_string = atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }
  return bytes.buffer;
}

// --- Serialization Helpers using Base64 ---
function serializeBuffers(obj) {
  if (!obj) return obj;
  if (obj instanceof ArrayBuffer) {
    return {
      __type: "ArrayBuffer",
      // Use standard Base64 encoding
      data: arrayBufferToBase64(obj),
    };
  }
  if (typeof obj === "object") {
    const newObj = Array.isArray(obj) ? [] : {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = serializeBuffers(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
}

function deserializeBuffers(obj) {
  if (!obj) return obj;
  if (
    typeof obj === "object" &&
    obj.__type === "ArrayBuffer" &&
    typeof obj.data === "string"
  ) {
    // Use standard Base64 decoding
    return base64ToArrayBuffer(obj.data);
  }
  if (typeof obj === "object") {
    const newObj = Array.isArray(obj) ? [] : {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = deserializeBuffers(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
}

// --- SignalProtocolStore Implementation (Partial) ---

export class IndexedDBStore {
  // Remove constructor dependency injection
  constructor() {
    console.log("IndexedDBStore initialized (standard).");
    getDb();
  }

  // --- Getters ---
  async getIdentityKeyPair() {
    console.log("IndexedDBStore: getIdentityKeyPair");
    const kp = await performDbOperation(
      IDENTITY_STORE_NAME,
      "readonly",
      (store) => store.get("identityKey")
    );
    // Use standard deserializer
    return kp ? deserializeBuffers(kp) : undefined;
  }
  // ... other getters using deserializeBuffers will now use standard Base64 ...
  async getLocalRegistrationId() {
    console.log("IndexedDBStore: getLocalRegistrationId");
    return performDbOperation(KEY_STORE_NAME, "readonly", (store) =>
      store.get("registrationId")
    );
  }
  async isTrustedIdentity(identifier, identityKey /*, direction */) {
    console.log(`IndexedDBStore: isTrustedIdentity for ${identifier}`);
    const trusted = await this.loadIdentityKey(identifier);
    if (!trusted) {
      await this.saveIdentity(identifier, identityKey);
      return true;
    }
    // Comparison still needs ArrayBuffers, rely on deserializeBuffers
    // Convert identityKey to ArrayBuffer if it isn't already?
    // Let's assume loadIdentityKey returns ArrayBuffer correctly via deserializeBuffers
    // We need a way to compare ArrayBuffers. Standard === won't work.
    // For now, let's serialize back to Base64 for comparison (less efficient but simple)
    const trustedB64 = arrayBufferToBase64(trusted);
    const identityKeyB64 = arrayBufferToBase64(identityKey);
    return trustedB64 === identityKeyB64;
  }
  async loadPreKey(keyId) {
    console.log(
      `[DB Store] loadPreKey called for key ID: ${keyId} (Type: ${typeof keyId})`
    ); // Log key + type
    const requestedKeyId = Number(keyId); // Ensure we query with number
    console.log(
      `[DB Store] loadPreKey requesting numeric key: ${requestedKeyId}`
    );
    const keyPair = await performDbOperation(
      PREKEY_STORE_NAME,
      "readonly",
      (store) => store.get(requestedKeyId) // Use numeric key
    );
    console.log(
      `[DB Store] loadPreKey Raw result for ${requestedKeyId}:`,
      keyPair
    ); // Log raw result
    if (!keyPair) {
      console.warn(
        `[DB Store] loadPreKey: Key ID ${requestedKeyId} not found.`
      );
    } else {
      console.log(`[DB Store] loadPreKey: Found key for ID ${requestedKeyId}.`);
    }
    return keyPair ? deserializeBuffers(keyPair) : undefined;
  }
  async loadSession(identifier) {
    console.log(`IndexedDBStore: loadSession for ${identifier}`);
    if (!identifier) {
      throw new Error("Cannot load session with invalid identifier");
    }
    const session = await performDbOperation(
      SESSION_STORE_NAME,
      "readonly",
      (store) => store.get(identifier)
    );
    console.log(
      `[DB Store] loadSession(${identifier}) result: ${
        session ? "Found" : "Not Found"
      }`,
      session // Log the raw session object
    );
    return session ? deserializeBuffers(session) : undefined; // Re-enable deserialization
  }
  async loadSignedPreKey(keyId) {
    console.log(
      `[DB Store] loadSignedPreKey called for key ID: ${keyId} (Type: ${typeof keyId})`
    ); // Log key + type
    const requestedKeyId = Number(keyId); // Ensure we query with number
    console.log(
      `[DB Store] loadSignedPreKey requesting numeric key: ${requestedKeyId}`
    );
    const keyPair = await performDbOperation(
      SIGNED_PREKEY_STORE_NAME,
      "readonly",
      (store) => store.get(requestedKeyId) // Retrieve using Number(keyId)
    );
    console.log(
      `[DB Store] loadSignedPreKey Raw result for ${requestedKeyId}:`,
      keyPair
    ); // Log raw result
    if (!keyPair) {
      console.warn(
        `[DB Store] loadSignedPreKey: Key ID ${requestedKeyId} not found.`
      );
    } else {
      console.log(
        `[DB Store] loadSignedPreKey: Found key for ID ${requestedKeyId}.`
      );
    }
    return keyPair ? deserializeBuffers(keyPair) : undefined;
  }
  async loadIdentityKey(identifier) {
    console.log(`IndexedDBStore: loadIdentityKey for ${identifier}`);
    const key = await performDbOperation(
      IDENTITY_STORE_NAME,
      "readonly",
      (store) => store.get(`identity_${identifier}`)
    );
    return key ? deserializeBuffers(key) : undefined;
  }

  // --- Setters ---
  async storeIdentityKeyPair(identityKeyPair) {
    console.log("IndexedDBStore: storeIdentityKeyPair");
    // Use standard serializer
    const serializableKP = serializeBuffers(identityKeyPair);
    return performDbOperation(IDENTITY_STORE_NAME, "readwrite", (store) =>
      store.put(serializableKP, "identityKey")
    );
  }
  // ... other setters using serializeBuffers will now use standard Base64 ...
  async storeLocalRegistrationId(registrationId) {
    console.log("IndexedDBStore: storeLocalRegistrationId");
    return performDbOperation(KEY_STORE_NAME, "readwrite", (store) =>
      store.put(registrationId, "registrationId")
    );
  }
  async storePreKey(keyId, preKey) {
    console.log(`IndexedDBStore: storePreKey for ${keyId}`);
    return performDbOperation(PREKEY_STORE_NAME, "readwrite", (store) =>
      store.put(serializeBuffers(preKey), Number(keyId))
    );
  }
  async storeSession(identifier, session) {
    console.log(`IndexedDBStore: storeSession for ${identifier}`);
    if (!identifier) {
      throw new Error("Cannot store session with invalid identifier");
    }
    console.log(
      `[DB Store] storeSession(${identifier}) data:`,
      serializeBuffers(session)
    );
    return performDbOperation(SESSION_STORE_NAME, "readwrite", (store) =>
      store.put(serializeBuffers(session), identifier)
    );
  }
  async storeSignedPreKey(keyId, signedPreKey) {
    console.log(`IndexedDBStore: storeSignedPreKey for ${keyId}`);
    const serializableKey = serializeBuffers(signedPreKey);
    return performDbOperation(SIGNED_PREKEY_STORE_NAME, "readwrite", (store) =>
      store.put(serializableKey, Number(keyId))
    );
  }
  async saveIdentity(identifier, identityKey) {
    console.log(`IndexedDBStore: saveIdentity for ${identifier}`);
    const serializableKey = serializeBuffers(identityKey);
    return performDbOperation(IDENTITY_STORE_NAME, "readwrite", (store) =>
      store.put(serializableKey, `identity_${identifier}`)
    );
  }

  // --- Removers ---
  async removePreKey(keyId) {
    console.warn(
      `[DB Store] NO-OP: removePreKey called for ${keyId}, but deletion is disabled.`
    );
    if (keyId === undefined || keyId === null) {
      throw new Error("Cannot remove PreKey with invalid keyId");
    }
    // Do nothing - keep the key
    return Promise.resolve(); // Return resolved promise to satisfy libsignal
    /* Original implementation:
    return performDbOperation(PREKEY_STORE_NAME, "readwrite", (store) =>
      store.delete(Number(keyId))
    );
    */
  }

  async removeSession(identifier) {
    console.warn(`IndexedDBStore: removeSession for ${identifier}`);
    if (!identifier) {
      throw new Error("Cannot remove session with invalid identifier");
    }
    return performDbOperation(SESSION_STORE_NAME, "readwrite", (store) =>
      store.delete(identifier)
    );
  }

  async removeSignedPreKey(keyId) {
    console.warn(`IndexedDBStore: removeSignedPreKey for ${keyId}`);
    if (keyId === undefined || keyId === null) {
      throw new Error("Cannot remove SignedPreKey with invalid keyId");
    }
    return performDbOperation(SIGNED_PREKEY_STORE_NAME, "readwrite", (store) =>
      store.delete(keyId)
    );
  }

  async removeAllSessions(identifier) {
    console.warn(`IndexedDBStore: removeAllSessions for ${identifier}`);
    // This is more complex - it implies removing all sessions associated
    // with a recipient identifier (e.g., "recipientId" part without deviceId).
    // For simplicity with deviceId=1, this might be the same as removeSession.
    // If multiple devices were supported, you'd need to iterate and delete.
    if (!identifier) {
      throw new Error("Cannot remove sessions with invalid identifier base");
    }
    // Assuming identifier might be just the recipientId for this method
    // We need to delete "recipientId.1", "recipientId.2" etc.
    // For now, just implement for the default deviceId 1
    const fullIdentifier = `${identifier}.1`;
    return this.removeSession(fullIdentifier);
  }

  /**
   * Delete the cached identity-public-key for a peer.
   * @param {string} identifier – full "recipientId.deviceId" string,
   *                              e.g. "2a2d1c4c-7336-41e9-a6d5-cfb980162071.1"
   */
  async removeIdentity(identifier) {
    console.warn(`IndexedDBStore: removeIdentity for ${identifier}`);
    if (!identifier) {
      throw new Error("Cannot remove identity with invalid identifier");
    }
    // Note: The key in the store is prefixed with 'identity_'
    return performDbOperation(IDENTITY_STORE_NAME, "readwrite", (store) =>
      store.delete(`identity_${identifier}`)
    );
  }

  // --- Misc ---

  // --- Add missing methods --- START ---
  async containsSession(identifier) {
    console.log(`IndexedDBStore: containsSession for ${identifier}`);
    if (!identifier) {
      console.warn("[DB Store] containsSession called with invalid identifier");
      return false; // Or throw? Let's return false for boolean check.
    }
    // Check if a session exists by attempting to get it (returns undefined if not found)
    const session = await performDbOperation(
      SESSION_STORE_NAME,
      "readonly",
      (store) => store.get(identifier) // Use get instead of loadSession to avoid deserialization cost
    );
    const exists = session !== undefined; // Check if *any* value was retrieved
    console.log(`[DB Store] containsSession(${identifier}) result: ${exists}`);
    return exists;
  }

  // libsignal older builds might call sessionExists, alias for compatibility
  // Although current error is for containsSession, this is safe to include
  sessionExists(identifier) {
    return this.containsSession(identifier);
  }

  // libsignal expects deleteSession
  async deleteSession(identifier) {
    console.log(`IndexedDBStore: deleteSession for ${identifier}`);
    // Delegate to the existing removeSession logic
    return this.removeSession(identifier);
  }

  // libsignal expects deleteAllSessions
  async deleteAllSessions(identifierBase) {
    console.log(`IndexedDBStore: deleteAllSessions for ${identifierBase}`);
    // Delegate to the existing removeAllSessions logic
    // Note: The current removeAllSessions only handles deviceId 1.
    // Needs refinement if multiple devices are supported.
    return this.removeAllSessions(identifierBase);
  }
  // --- Add missing methods --- END ---

  /**
   * Clears the entire IndexedDB database used by the store.
   * USE WITH CAUTION - This deletes all keys and sessions.
   */
  async clearAllData() {
    console.warn("Clearing all data from SecureChatDB...");
    // Close the connection if open
    if (dbPromise) {
      const db = await dbPromise;
      db.close();
      dbPromise = null; // Reset the promise
    }
    return new Promise((resolve, reject) => {
      const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
      deleteRequest.onsuccess = () => {
        console.log("SecureChatDB deleted successfully.");
        resolve();
      };
      deleteRequest.onerror = (event) => {
        console.error("Error deleting database:", event.target.error);
        reject("Error deleting database");
      };
      deleteRequest.onblocked = () => {
        console.warn(
          "Database deletion blocked. Ensure all connections are closed."
        );
        reject("Database deletion blocked");
      };
    });
  }

  // The libsignal library might expect a Direction enum or similar
  // We can define it here if needed, or adjust isTrustedIdentity if the library passes it
  // static Direction = { SENDING: 1, RECEIVING: 2 };
}

// RE-INSTATE instance creation and export from here
export const signalStore = new IndexedDBStore();

// Optional: Export db functions if needed directly elsewhere
// export { dbSet, dbGet, dbRemove };

================
File: src/lib/signalContext.jsx
================
// SignalContext.jsx
import { createContext, useContext, useEffect, useState } from "react";
import { IndexedDBStore } from "../lib/localDb";
import { post } from "../lib/backend";
import { initializeSignalProtocol } from "../lib/signalUtils";

const SignalCtx = createContext(null);
export const useSignal = () => useContext(SignalCtx);

export function SignalProvider({ children, userId }) {
  const [store] = useState(() => new IndexedDBStore());
  const [deviceId, setDeviceId] = useState(null);
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!userId || !store) return;

    let didCancel = false;
    setIsReady(false);
    setError(null);

    (async () => {
      const localStorageKey = `deviceId_${userId}`;
      let localKey = localStorage.getItem(localStorageKey);
      let currentDeviceId = localKey ? Number(localKey) : null;
      let keysExist = false;

      try {
        const identityKeyPair = await store.getIdentityKeyPair();
        keysExist = !!identityKeyPair;
        console.log(`[SignalContext] Local keys exist? ${keysExist}`);

        if (!keysExist && currentDeviceId) {
          console.warn(
            `[SignalContext] Local keys missing but found old deviceId ${currentDeviceId} in localStorage. Clearing localStorage to force re-registration.`
          );
          localStorage.removeItem(localStorageKey);
          currentDeviceId = null;
        }

        if (!keysExist || !currentDeviceId) {
          console.log(
            `[SignalContext] Keys missing (${!keysExist}) or no saved Device ID (${!currentDeviceId}). Initializing/Registering...`
          );

          const bundle = await initializeSignalProtocol(store, userId);
          console.log(
            "[SignalContext] initializeSignalProtocol complete. Bundle generated."
          );

          console.log("[SignalContext] Registering bundle with server...");
          const response = await post("/api/device/register", bundle);
          const newDeviceId = response?.deviceId;

          if (newDeviceId === undefined || newDeviceId === null) {
            throw new Error(
              "Device registration failed: No deviceId in response."
            );
          }

          currentDeviceId = Number(newDeviceId);
          localStorage.setItem(localStorageKey, String(currentDeviceId));
          console.log(
            `[SignalContext] Device registration successful. Device ID: ${currentDeviceId}`
          );
        } else {
          console.log(
            `[SignalContext] Found existing keys and saved deviceId ${currentDeviceId}. Assuming ready.`
          );
        }

        if (!didCancel) {
          setDeviceId(currentDeviceId);
          setIsReady(true);
          console.log("[SignalContext] Provider is ready.");
        }
      } catch (err) {
        console.error(
          "[SignalContext] Initialization/Registration error:",
          err
        );
        if (!didCancel) {
          setError(err.message || "Initialization failed");
          setIsReady(false);
        }
      }
    })();

    return () => {
      didCancel = true;
    };
  }, [userId, store]);

  return (
    <SignalCtx.Provider
      value={{
        isReady,
        signalStore: isReady ? store : null,
        deviceId: isReady ? deviceId : null,
        initializationError: error,
      }}
    >
      {children}
    </SignalCtx.Provider>
  );
}

================
File: src/lib/signalCrypto.js
================
import { get, set } from 'idb-keyval';

const { subtle } = crypto;

// Generate an ECDH key pair
async function generateKeyPair() {
  try {
    return await subtle.generateKey(
      {
        name: 'ECDH',
        namedCurve: 'P-256',
      },
      true,
      ['deriveKey', 'deriveBits']
    );
  } catch (error) {
    throw new Error(`Failed to generate key pair: ${error.message}`);
  }
}

// Initialize keys for a user
async function initializeKeys(userId) {
  try {
    const identityKeyPair = await generateKeyPair();
    const preKeyPair = await generateKeyPair();

    await set(`${userId}:identityKey`, {
      publicKey: await subtle.exportKey('jwk', identityKeyPair.publicKey),
      privateKey: await subtle.exportKey('jwk', identityKeyPair.privateKey),
    });
    await set(`${userId}:preKey`, {
      publicKey: await subtle.exportKey('jwk', preKeyPair.publicKey),
      privateKey: await subtle.exportKey('jwk', preKeyPair.privateKey),
    });

    return {
      identityKey: await subtle.exportKey('spki', identityKeyPair.publicKey),
      preKey: await subtle.exportKey('spki', preKeyPair.publicKey),
    };
  } catch (error) {
    throw new Error(`Failed to initialize keys for ${userId}: ${error.message}`);
  }
}

// Retrieve stored keys
async function getKeys(userId) {
  try {
    const identityKeyData = await get(`${userId}:identityKey`);
    const preKeyData = await get(`${userId}:preKey`);

    if (!identityKeyData || !preKeyData) {
      throw new Error('Keys not found in storage');
    }

    const identityKeyPair = {
      publicKey: await subtle.importKey(
        'jwk',
        identityKeyData.publicKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        false,
        []
      ),
      privateKey: await subtle.importKey(
        'jwk',
        identityKeyData.privateKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveKey', 'deriveBits']
      ),
    };
    const preKeyPair = {
      publicKey: await subtle.importKey(
        'jwk',
        preKeyData.publicKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        false,
        []
      ),
      privateKey: await subtle.importKey(
        'jwk',
        preKeyData.privateKey,
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveKey', 'deriveBits']
      ),
    };

    return { identityKeyPair, preKeyPair };
  } catch (error) {
    throw new Error(`Failed to retrieve keys for ${userId}: ${error.message}`);
  }
}

// Perform X3DH key agreement
async function initiateX3DH(ourUserId, theirUserId, theirPublicKeys) {
  try {
    const { identityKeyPair, preKeyPair } = await getKeys(ourUserId);

    // Import their public identity key
    const theirIdentityKey = await subtle.importKey(
      'spki',
      theirPublicKeys.identityKey,
      { name: 'ECDH', namedCurve: 'P-256' },
      false,
      []
    );

    // Derive shared secret using our identity private key and their identity public key
    const sharedSecret = await subtle.deriveBits(
      {
        name: 'ECDH',
        public: theirIdentityKey,
      },
      identityKeyPair.privateKey,
      256
    );

    // Log shared secret for debugging
    const sharedSecretHex = Array.from(new Uint8Array(sharedSecret))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    console.log(`Shared secret for ${ourUserId} -> ${theirUserId}: ${sharedSecretHex}`);

    // Convert to AES-GCM key
    const derivedKey = await subtle.importKey(
      'raw',
      sharedSecret,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );

    await set(`${ourUserId}:sharedKey:${theirUserId}`, derivedKey);
    return derivedKey;
  } catch (error) {
    throw new Error(`X3DH failed for ${ourUserId} -> ${theirUserId}: ${error.message}`);
  }
}

// Encrypt a message
async function encryptMessage(userId, recipientId, message) {
  try {
    const sharedKey = await get(`${userId}:sharedKey:${recipientId}`);
    if (!sharedKey) throw new Error('Shared key not found');

    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const ciphertext = await subtle.encrypt(
      {
        name: 'AES-GCM',
        iv,
      },
      sharedKey,
      data
    );

    return {
      iv: iv.buffer,
      ciphertext,
    };
  } catch (error) {
    throw new Error(`Encryption failed for ${userId} -> ${recipientId}: ${error.message}`);
  }
}

// Decrypt a message
async function decryptMessage(userId, senderId, { iv, ciphertext }) {
  try {
    const sharedKey = await get(`${userId}:sharedKey:${senderId}`);
    if (!sharedKey) throw new Error('Shared key not found');

    const ivArray = new Uint8Array(iv);

    const plaintext = await subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: ivArray,
      },
      sharedKey,
      ciphertext
    );

    const decoder = new TextDecoder();
    return decoder.decode(plaintext);
  } catch (error) {
    throw new Error(`Decryption failed for ${userId} <- ${senderId}: ${error.message}`);
  }
}

export { initializeKeys, getKeys, initiateX3DH, encryptMessage, decryptMessage };

================
File: src/lib/signalUtils.js
================
"use strict";

import {
  KeyHelper,
  SignalProtocolAddress,
  SessionBuilder,
  SessionCipher,
  //setLogger,
} from "@privacyresearch/libsignal-protocol-typescript";
// import { get } from "./backend"; // Assuming backend.js is in the same directory or adjust path - REMOVED

// --- Enable Signal Library Debug Logging ---
// Uncomment the line below to see detailed logs from the Signal library itself
//setLogger(console.log);
// ---

/**
 * Represents the public key bundle needed to establish a session.
 * @typedef {import('@privacyresearch/libsignal-protocol-typescript').PreKeyBundleType<ArrayBuffer>} PreKeyBundleType
 */

/**
 * Represents the Signal Protocol store interface.
 * You must provide an object conforming to this interface.
 * @typedef {import('@privacyresearch/libsignal-protocol-typescript').SignalProtocolStore} SignalProtocolStore
 */

/**
 * Represents the encrypted message structure.
 * @typedef {import('@privacyresearch/libsignal-protocol-typescript').MessageType} MessageType
 */

// --- Add bufToB64 helper ---
function bufToB64(buf) {
  // Ensure buf is ArrayBuffer
  if (!(buf instanceof ArrayBuffer)) {
    console.error("[bufToB64] Input is not ArrayBuffer:", buf);
    if (buf === null || buf === undefined) return null; // Handle null/undefined gracefully if they sneak in
    throw new Error("bufToB64: Expected ArrayBuffer input.");
  }
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
// --- End bufToB64 helper ---

/**
 * Initializes the Signal protocol state for the current device.
 * Generates identity keys, registration ID, a signed pre-key, and a one-time pre-key,
 * storing them in the provided store.
 * It then returns a bundle formatted for server registration with Base64 encoded keys.
 * @param {import('@privacyresearch/libsignal-protocol-typescript').SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} userId - The user's identifier, to be included in the returned bundle.
 * @returns {Promise<{
 *   userId: string,
 *   registrationId: number,
 *   identityKey: string, // Base64 encoded
 *   signedPreKeyId: number,
 *   signedPreKeyPublicKey: string, // Base64 encoded
 *   signedPreKeySignature: string, // Base64 encoded
 *   preKeyId: number,
 *   preKeyPublicKey: string // Base64 encoded
 * }>} An object containing the user ID, registration ID, and Base64 encoded public identity key,
 *      signed pre-key components, and one-time pre-key components, formatted for the server.
 */
export const initializeSignalProtocol = async (store, userId) => {
  if (!userId || typeof userId !== "string" || userId.trim() === "") {
    console.error(
      "[initializeSignalProtocol] Invalid or missing userId:",
      userId
    );
    throw new Error("userId must be a non-empty string.");
  }
  // Basic check for store
  if (
    !store ||
    typeof store.storeIdentityKeyPair !== "function" ||
    typeof store.storeLocalRegistrationId !== "function" ||
    typeof store.storeSignedPreKey !== "function" ||
    typeof store.storePreKey !== "function"
  ) {
    console.error(
      "[initializeSignalProtocol] Invalid store object provided:",
      store
    );
    throw new Error("Invalid or incomplete store object provided.");
  }

  // ❶ identity & registration
  const identity = await KeyHelper.generateIdentityKeyPair();
  const registrationId = KeyHelper.generateRegistrationId();

  await store.storeIdentityKeyPair(identity);
  await store.storeLocalRegistrationId(registrationId);

  // ❷ signed-pre-key
  // Use a seed for the ID; the library returns the actual ID in the generated object.
  // Max value for signedPreKeyId is 2147483647 (2^31 - 1).
  const signedPreKeyIdSeed = Math.floor(Math.random() * (2 ** 31 - 2)) + 1; // Range: 1 to 2^31 - 2
  const signedPreKey = await KeyHelper.generateSignedPreKey(
    identity,
    signedPreKeyIdSeed
  );
  // signedPreKey is { keyId: number, keyPair: KeyPairType, signature: ArrayBuffer }
  // Store using the keyId from the signedPreKey object and its keyPair.
  console.log(`[SignalUtils] Storing SignedPreKey ID: ${signedPreKey.keyId}`);
  await store.storeSignedPreKey(signedPreKey.keyId, signedPreKey.keyPair);
  console.log(`[SignalUtils] Stored SignedPreKey ID: ${signedPreKey.keyId}`);

  // ❸ first one-time pre-key
  // Max value for preKeyId for libsignal-protocol-typescript is 16777215 (0xFFFFFF).
  const preKeyIdSeed = Math.floor(Math.random() * 16777214) + 1; // Range: 1 to 2^24 - 2
  const preKey = await KeyHelper.generatePreKey(preKeyIdSeed);
  // preKey is { keyId: number, keyPair: KeyPairType }
  // Store using the keyId from the preKey object (as a string) and its keyPair.
  console.log(`[SignalUtils] Storing PreKey ID: ${preKey.keyId}`);
  await store.storePreKey(preKey.keyId, preKey.keyPair);
  console.log(`[SignalUtils] Stored PreKey ID: ${preKey.keyId}`);

  console.log(
    `[SignalUtils] Initialized Signal protocol for user ${userId}. RegID: ${registrationId}, SignedPKID: ${signedPreKey.keyId}, PreKeyID: ${preKey.keyId}`
  );

  // ❹ build bundle in **Base-64**
  const bundle = {
    userId,
    registrationId,
    identityKey: bufToB64(identity.pubKey),
    signedPreKeyId: signedPreKey.keyId, // Use the keyId from the generated object
    signedPreKeyPublicKey: bufToB64(signedPreKey.keyPair.pubKey),
    signedPreKeySignature: bufToB64(signedPreKey.signature),
    preKeyId: preKey.keyId, // Use the keyId from the generated object
    preKeyPublicKey: bufToB64(preKey.keyPair.pubKey),
  };

  // console.log("[SignalUtils] Generated bundle for server:", JSON.stringify(bundle, (k,v) => typeof v === 'string' && v.length > 30 ? v.substring(0,30) + '...' : v, 2));
  return bundle;
};

/**
 * Builds a Signal session with a recipient using their PreKeyBundle.
 * @param {SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} recipientId - The recipient's identifier.
 * @param {number} deviceId - The recipient's device ID.
 * @param {PreKeyBundleType} preKeyBundle - The recipient's pre-key bundle fetched from the server.
 * @returns {Promise<void>}
A promise that resolves when the session is built and stored, or rejects on identity key mismatch.
 */
export const buildSession = async (
  store,
  recipientId,
  deviceId,
  preKeyBundle
) => {
  const recipientAddress = new SignalProtocolAddress(recipientId, deviceId);
  const sessionBuilder = new SessionBuilder(store, recipientAddress);

  console.log(`Building session with ${recipientId}:${deviceId}`);
  try {
    await sessionBuilder.processPreKey(preKeyBundle);
    console.log(`Session built with ${recipientId}:${deviceId}`);
  } catch (error) {
    console.error("Error processing pre-key bundle:", error);
    throw error; // Re-throw for handling upstream
  }
};

/**
 * Encrypts a message for a recipient.
 * Establishes a session if one doesn't exist (via PreKeyWhisperMessage).
 * @param {SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} recipientId - The recipient's identifier.
 * @param {number} deviceId - The recipient's device ID.
 * @param {ArrayBuffer} plaintextBuffer - The message content to encrypt as an ArrayBuffer.
 * @returns {Promise<MessageType>} The encrypted message object (contains type and body).
 */
export const encryptMessage = async (
  store,
  recipientId,
  deviceId,
  plaintextBuffer
) => {
  const recipientAddress = new SignalProtocolAddress(recipientId, deviceId);
  const sessionCipher = new SessionCipher(store, recipientAddress);

  try {
    const session = await store.loadSession(recipientAddress.toString());
    console.log(
      `[encryptMessage] Session state loaded for ${recipientId}:${deviceId} before encrypt:`,
      session
    );
  } catch (e) {
    console.warn(
      `[encryptMessage] Could not load session for logging before encrypt`,
      e
    );
  }

  console.log(`Encrypting message for ${recipientId}:${deviceId}`);
  try {
    const ciphertext = await sessionCipher.encrypt(plaintextBuffer);
    console.log(
      `Message encrypted (type ${ciphertext.type}) for ${recipientId}:${deviceId}`
    );

    if (ciphertext.type === 3) {
      try {
        const raw = Uint8Array.from(ciphertext.body, (c) => c.charCodeAt(0));
        console.log(
          `[DBG-TX] type=${ciphertext.type}  len=${raw.byteLength}`,
          `sha256=${await crypto.subtle
            .digest("SHA-256", raw)
            .then((buf) =>
              [...new Uint8Array(buf)]
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("")
            )}`
        );
      } catch (dbgError) {
        console.error("[DBG-TX] Error logging debug info:", dbgError);
      }
    }
    return ciphertext;
  } catch (error) {
    console.error("Error encrypting message:", error);
    throw error;
  }
};

/**
 * Decrypts an incoming message.
 * Handles both PreKeyWhisperMessages (establishing a session) and WhisperMessages.
 * @param {SignalProtocolStore} store - The Signal protocol store implementation.
 * @param {string} recipientId - The ID of the user receiving the message (current user).
 * @param {string} senderId - The sender's identifier.
 * @param {number} senderDeviceId - The sender's device ID.
 * @param {MessageType} ciphertext - The incoming encrypted message object (body is expected to be a *Uint8Array*).
 * @returns {Promise<ArrayBuffer | null>} A promise resolving to the decrypted plaintext ArrayBuffer, or null if decryption fails.
 */
export const decryptMessage = async (
  store,
  recipientId,
  senderId,
  senderDeviceId,
  ciphertext
) => {
  const senderAddress = new SignalProtocolAddress(senderId, senderDeviceId);
  const sessionCipher = new SessionCipher(store, senderAddress);
  const senderAddressString = senderAddress.toString();
  const recipientAddressString = new SignalProtocolAddress(
    recipientId,
    1 // TODO: This recipient device ID might need to come from context if store is keyed by full address
  ).toString();

  console.log(
    `Attempting decryption of message type ${ciphertext.type} from ${senderAddressString} to ${recipientAddressString}`
  );

  const bodyUint8Array = ciphertext.body;
  if (!(bodyUint8Array instanceof Uint8Array)) {
    console.error(
      `[decryptMessage] Expected ciphertext.body to be a Uint8Array, but got: ${typeof bodyUint8Array}`
    );
    return null;
  }

  try {
    let plaintextBuffer = null;

    if (ciphertext.type === 3) {
      console.log(`Processing PreKeyWhisperMessage (Type 3)...`);
      plaintextBuffer = await sessionCipher
        .decryptPreKeyWhisperMessage(bodyUint8Array.buffer, "binary")
        .catch(async (err) => {
          if (err instanceof Error && err.message?.includes("Bad MAC")) {
            console.warn(
              `Bad MAC error on PreKeyWhisperMessage from ${senderAddressString}. Session likely stale. Wiping session and retrying...`
            );
            await store.removeSession(senderAddressString);
            const freshCipher = new SessionCipher(store, senderAddress);
            return freshCipher.decryptPreKeyWhisperMessage(
              bodyUint8Array.buffer,
              "binary"
            );
          } else {
            console.error(
              `Non-MAC decryption error (PreKeyWhisperMessage) from ${senderAddressString}:`,
              err
            );
            throw err;
          }
        });
      console.log(
        plaintextBuffer
          ? `Successfully processed PreKeyWhisperMessage from ${senderAddressString}`
          : `Failed to process PreKeyWhisperMessage from ${senderAddressString} after potential retry.`
      );
    } else if (ciphertext.type === 1) {
      console.log(
        `Decrypting WhisperMessage (Type 1) from ${senderAddressString}...`
      );
      try {
        plaintextBuffer = await sessionCipher.decryptWhisperMessage(
          bodyUint8Array.buffer,
          "binary"
        );
        console.log(
          `Successfully decrypted WhisperMessage from ${senderAddressString}`
        );
      } catch (e) {
        if (e instanceof Error && e.message?.includes("Bad MAC")) {
          console.error(
            `🛑 Bad MAC error decrypting WhisperMessage (Type 1) from ${senderAddressString}. This could be due to out-of-order messages or session state mismatch. No automatic retry. Raw error:`,
            e
          );
          plaintextBuffer = null;
        } else {
          console.error(
            `Non-MAC decryption error (WhisperMessage) from ${senderAddressString}:`,
            e
          );
          throw e;
        }
      }
    } else {
      console.warn(
        `Received message with unknown type: ${ciphertext.type} from ${senderAddressString}`
      );
      throw new Error(`Unknown message type: ${ciphertext.type}`);
    }

    if (plaintextBuffer) {
      try {
        console.log(
          `📩 Decrypted content from ${senderAddressString}: "`,
          arrayBufferToString(plaintextBuffer).substring(0, 50) + "...",
          `"`
        );
      } catch (logError) {
        console.warn(
          "Could not log decrypted plaintext (decoding error?)",
          logError
        );
      }
    }
    return plaintextBuffer;
  } catch (error) {
    console.error(
      `Decryption failed catastrophically for message from ${senderAddressString}:`,
      error
    );
    return null;
  }
};

/**
 * Helper to convert ArrayBuffer to Base64 string.
 * Useful for transmitting binary data (like keys or ciphertexts) as strings.
 * @param {ArrayBuffer} buffer
 * @returns {string}
 */
export function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}

/**
 * Helper to convert Base64 string back to ArrayBuffer.
 * @param {string} base64
 * @returns {ArrayBuffer | null} Null if input is invalid or conversion fails.
 */
export function base64ToArrayBuffer(base64) {
  if (!base64 || typeof base64 !== "string") {
    console.warn("[base64ToArrayBuffer] Received invalid input:", base64);
    return null;
  }
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
  } catch (error) {
    console.error("Error converting Base64 to ArrayBuffer:", base64, error);
    return null;
  }
}

/**
 * Helper to convert string to ArrayBuffer.
 * @param {string} str
 * @returns {ArrayBuffer}
 */
export function stringToArrayBuffer(str) {
  return new TextEncoder().encode(str).buffer;
}

/**
 * Helper to convert ArrayBuffer to string.
 * @param {ArrayBuffer} buffer
 * @returns {string}
 */
export function arrayBufferToString(buffer) {
  return new TextDecoder().decode(new Uint8Array(buffer));
}

/**
 * Helper function to convert an ArrayBuffer or Uint8Array to a plain hexadecimal string.
 * @param {ArrayBuffer | Uint8Array} buffer The data to convert.
 * @returns {string} The hexadecimal string representation (e.g., "a1b2c3d4").
 */
export function buf2hex(buffer) {
  const byteArray =
    buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
  return [...byteArray].map((x) => x.toString(16).padStart(2, "0")).join("");
}

/**
 * Helper function to convert PostgreSQL bytea hex escape format ('\\x...') to a Uint8Array.
 * @param {string | null | undefined} hexString The '\\x...' formatted string.
 * @returns {Uint8Array} The resulting Uint8Array.
 * @throws {Error} If the input format is invalid.
 */
export function hexToUint8Array(hexString) {
  if (
    !hexString ||
    typeof hexString !== "string" ||
    !hexString.startsWith("\\x")
  ) {
    throw new Error(
      `[hexToUint8Array] Invalid or non-hex string format received: ${hexString}`
    );
  }
  const hex = hexString.substring(2);

  if (hex.length % 2 !== 0) {
    throw new Error(
      `[hexToUint8Array] Hex string (after prefix removal) must have an even number of digits: ${hex}`
    );
  }

  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    const byte = parseInt(hex.substring(i, i + 2), 16);
    if (isNaN(byte)) {
      throw new Error(
        `[hexToUint8Array] Invalid hex character pair found: ${hex.substring(
          i,
          i + 2
        )}`
      );
    }
    byteArray[i / 2] = byte;
  }
  return byteArray;
}

// --- Add ensureIdentity --- START ---
import { signalStore } from "./localDb"; // Import the store instance
// Removed: import { post } from "./backend"; // No longer posting from here

/**
 * Ensures that the local Signal identity keys exist in the store.
 * If keys don't exist, it initializes them and stores them using the provided userId for context.
 * This function NO LONGER posts to the backend; that's handled by SignalContext.
 * @param {string} userId The user's ID, used for context if needed by initializeSignalProtocol.
 * @returns {Promise<import('@privacyresearch/libsignal-protocol-typescript').KeyPairType | undefined>}
 *          The identity key pair, or undefined if initialization failed.
 */
export async function ensureIdentity(userId) {
  // userId is now passed
  console.log(
    "[ensureIdentity] Checking for existing identity keys for user:",
    userId
  );
  const existingKeyPair = await signalStore.getIdentityKeyPair();
  const existingRegId = await signalStore.getLocalRegistrationId();

  if (existingKeyPair && existingRegId) {
    console.log("[ensureIdentity] Identity keys and Reg ID found.");
    console.log(
      "[ensureIdentity] Existing Identity PubKey (first 10 bytes):",
      existingKeyPair.pubKey
        ? buf2hex(existingKeyPair.pubKey.slice(0, 10))
        : "N/A"
    );
    console.log("[ensureIdentity] Existing Registration ID:", existingRegId);
    return existingKeyPair;
  }

  console.warn(
    "[ensureIdentity] No local identity/regId found. Generating fresh keys for user:",
    userId
  );
  try {
    // Call initializeSignalProtocol, which now takes userId and returns the bundle for the server
    // However, ensureIdentity itself doesn't need the bundle, just ensures keys are in store.
    // initializeSignalProtocol already stores the keys.
    await initializeSignalProtocol(signalStore, userId);
    console.log(
      "[ensureIdentity] New keys generated and stored by initializeSignalProtocol for user:",
      userId
    );

    const newKeyPair = await signalStore.getIdentityKeyPair(); // Verify they are stored
    const newRegId = await signalStore.getLocalRegistrationId();
    console.log(
      "[ensureIdentity] New Identity PubKey (first 10 bytes):",
      newKeyPair?.pubKey ? buf2hex(newKeyPair.pubKey.slice(0, 10)) : "N/A"
    );
    console.log("[ensureIdentity] New Registration ID:", newRegId);

    // Removed backend posting from here. SignalContext will handle it.
    return newKeyPair;
  } catch (error) {
    console.error("[ensureIdentity] Failed to initialize keys:", error);
    return undefined;
  }
}
// --- Add ensureIdentity --- END ---

/**
 * Converts an array of pre-key bundle objects from the backend into a Map.
 * @param {Array<object>} arr - Array of bundle objects from /api/signal/bundles/:userId.
 * Each object is expected to have deviceId, registrationId, identityKey (Base64),
 * signedPreKeyId, signedPreKeyPublicKey (Base64), signedPreKeySignature (Base64),
 * preKeyId, preKeyPublicKey (Base64).
 * @returns {Map<number, PreKeyBundleType>} A map of deviceId to PreKeyBundle.
 */
export function bundlesToMap(arr) {
  const map = new Map();
  if (!Array.isArray(arr)) {
    console.error("[bundlesToMap] Input is not an array:", arr);
    return map; // Return empty map
  }
  for (const b of arr) {
    // Validate basic structure of b
    if (b && typeof b.deviceId === "number" && b.identityKey) {
      // Basic check
      const identityKeyBuffer = base64ToArrayBuffer(b.identityKey);
      const signedPreKeyPublicKeyBuffer = base64ToArrayBuffer(
        b.signedPreKeyPublicKey
      );
      const signedPreKeySignatureBuffer = base64ToArrayBuffer(
        b.signedPreKeySignature
      );
      const preKeyPublicKeyBuffer = base64ToArrayBuffer(b.preKeyPublicKey);

      // Check for nulls from base64ToArrayBuffer which indicates conversion failure
      if (
        !identityKeyBuffer ||
        !signedPreKeyPublicKeyBuffer ||
        !signedPreKeySignatureBuffer ||
        !preKeyPublicKeyBuffer
      ) {
        console.warn(
          "[bundlesToMap] Failed to convert one or more keys from Base64 for deviceId:",
          b.deviceId,
          "Bundle data:",
          b
        );
        continue; // Skip this bundle if any key conversion fails
      }

      map.set(b.deviceId, {
        registrationId: b.registrationId,
        identityKey: identityKeyBuffer,
        signedPreKey: {
          keyId: b.signedPreKeyId,
          publicKey: signedPreKeyPublicKeyBuffer,
          signature: signedPreKeySignatureBuffer,
        },
        preKey: {
          keyId: b.preKeyId,
          publicKey: preKeyPublicKeyBuffer,
        },
      });
    } else {
      console.warn("[bundlesToMap] Skipping invalid bundle object:", b);
    }
  }
  return map;
}

================
File: src/lib/supabaseClient.js
================
import { createClient } from "@supabase/supabase-js";

// Read environment variables
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Check if variables are set
if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error(
    "Supabase URL and Anon Key must be provided in .env file with VITE_ prefix"
  );
}

// Create and export the Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/main.jsx
================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);

================
File: src/pages/AboutPage.jsx
================
import { Link } from "react-router-dom";
import React from 'react';
import { AlertCircle, ArrowLeft, Lock, Shield } from "lucide-react";


const About = () => {
  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
    <header className="container mx-auto p-4">
      <Link
        to="/"
        className="inline-flex items-center text-slate-300 hover:text-white"
      >
        <ArrowLeft className="h-4 w-4 mr-2" />
        Back to Home
      </Link>
    </header>

      <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col py-10">
      <div className="max-w-4xl mx-auto bg-gradient-to-b p-8 rounded-lg shadow-md">
        <h1 className="text-3xl font-bold text-center text-white mb-6">About the project</h1>
        <p className="text-white mb-8">
          Welcome to our About page! Here you can learn more about our company, our mission, and our team.
          Welcome to our About page! Here you can learn more about our project.
        </p>

        <section className="mb-8">
          <h2 className="text-2xl font-semibold text-white mb-4">Our Mission</h2>
          <h2 className="text-2xl font-semibold text-white mb-4">Our project</h2>
          <p className="text-white">
            Our mission is to provide high-quality services and products to our customers. We strive to exceed expectations and deliver exceptional value.
            The project is based on end to end message encryption. It is a web application that allows users to send and receive encrypted messages securely.
            The application uses the double ratchet algorithm to ensure that messages are encrypted and decrypted securely. 
          </p>
        </section>
        

       <section className="mb-8">
          <h2 className="text-2xl font-semibold text-gray-800 mb-4">Meet the Team</h2>
          <h2 className="text-2xl font-semibold text-white mb-4">The group:</h2>
          <div className="space-y-4">

            <div className="team-member">
              <h3 className="text-xl font-semibold text-white">Abul Kasem Mohammed Omar Sharif</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-white">Mads Holt Jensen</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-gray-800">John Doe</h3>
              <p className="text-gray-600">CEO & Founder</p>
              <h3 className="text-xl font-semibold text-white">Neha Sharma</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-gray-800">Jane Smith</h3>
              <p className="text-gray-600">CTO</p>
              <h3 className="text-xl font-semibold text-white">Ivan Mezinov</h3>
              </div>

              <div className="team-member">
              <h3 className="text-xl font-semibold text-white">Victor Wejergang Petersen</h3>
            </div>

            <div className="team-member">
              <h3 className="text-xl font-semibold text-gray-800">Emily Johnson</h3>
              <p className="text-gray-600">Marketing Director</p>
              <h3 className="text-xl font-semibold text-white">Morten Allan Jensen</h3>
            </div>


          </div>
        </section>

        @todo: Add more sections as needed
        @todo add back button 
        @todo Write about the project and members
        </div>
        </div>
      </div>

  );
};

export default About;

================
File: src/pages/ChatPage.jsx
================
import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import EmojiPicker from "emoji-picker-react";

import {
  ArrowLeft,
  LogOut,
  Menu,
  MessageSquare,
  MoreVertical,
  Plus,
  Search,
  Send,
  Settings,
  User,
} from "lucide-react";
import { Link, useNavigate } from "react-router-dom";
import { AnimatePresence } from "framer-motion";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useMobile } from "../hooks/use-mobile";
import { supabase } from "../lib/supabaseClient";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import NewChatModal from "../components/NewChatModal";
import { useSignal } from "../lib/signalContext.jsx";
import {
  encryptMessage,
  decryptMessage,
  arrayBufferToString,
  buildSession,
  buf2hex,
  hexToUint8Array,
  bundlesToMap,
} from "../lib/signalUtils";
import {
  SignalProtocolAddress,
  SessionBuilder,
} from "@privacyresearch/libsignal-protocol-typescript";
import { get } from "../lib/backend";
import { cacheSentMessage, getCachedMessageContent } from "../lib/db";

// Helper function to convert PostgreSQL bytea hex escape format ('\\x...') to ArrayBuffer
/* REMOVED - Use hexToUint8Array from signalUtils instead
function hexStringToArrayBuffer(hexString) {
  // Check if the string starts with the literal '\x'
  if (!hexString || !hexString.startsWith("\\x")) {
    // Note: In JS string literals, '\\x' represents the two characters \ and x
    console.warn(
      "[hexStringToArrayBuffer] Invalid or non-hex string format received:",
      hexString
    );
    return null;
  }
  // Remove the leading '\x' prefix (2 characters)
  const hex = hexString.substring(2);

  // Validate remaining hex string length
  if (hex.length % 2 !== 0) {
    console.error(
      "[hexStringToArrayBuffer] Hex string (after prefix removal) must have an even number of digits:",
      hex
    );
    return null;
  }

  // Convert hex pairs to bytes
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    const byte = parseInt(hex.substring(i, i + 2), 16);
    if (isNaN(byte)) {
      // Add check for invalid hex characters
      console.error(
        `[hexStringToArrayBuffer] Invalid hex character pair found: ${hex.substring(
          i,
          i + 2
        )}`
      );
      return null;
    }
    byteArray[i / 2] = byte;
  }
  return byteArray.buffer; // Return the underlying ArrayBuffer
}
*/

// Helper function to convert ArrayBuffer or ArrayBufferView to PostgreSQL bytea hex format ('\\x...')
/* REMOVED - Use binaryStringToHex from signalUtils instead
function arrayBufferToHex(input) {
  console.log("[arrayBufferToHex] Received input:", input);

  // Accept both kinds transparently
  // 🔧 NEW – accept the raw binary string returned by SessionCipher.encrypt
  let view;
  if (typeof input === "string") {
    // Each charCode is already 0-255, so this is loss-less
    console.log(
      "[arrayBufferToHex] Input is string, attempting charCode conversion."
    );
    view = Uint8Array.from(input, (ch) => ch.charCodeAt(0));
  } else if (input instanceof ArrayBuffer) {
    console.log("[arrayBufferToHex] Input is ArrayBuffer.");
    view = new Uint8Array(input);
  } else if (ArrayBuffer.isView(input)) {
    console.log("[arrayBufferToHex] Input is ArrayBufferView.");
    view = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
  } else {
    console.error("[arrayBufferToHex] Unsupported input:", input);
    return null;
  }

  if (!view) {
    // This case should technically not be reachable if the checks above are exhaustive
    console.error(
      "[arrayBufferToHex] Failed to create Uint8Array view from input.",
      input
    );
    return null;
  }

  if (!view.byteLength) {
    console.warn("[arrayBufferToHex] Received empty buffer/view.");
    return "\\x";
  }

  try {
    // More modern/concise hex conversion
    const hex = [...view].map((b) => b.toString(16).padStart(2, "0")).join("");
    console.log("[arrayBufferToHex] Joined hex string (no prefix):", hex);

    const finalHexString = "\\x" + hex;
    console.log(
      "[arrayBufferToHex] Final hex string with prefix:",
      finalHexString
    );
    return finalHexString;
  } catch (error) {
    console.error(
      "[arrayBufferToHex] Error during conversion:",
      error,
      "Input:",
      input
    );
    return null; // Return null on error
  }
}
*/

// Helper function to convert ArrayBuffer to Base64 string
// eslint-disable-next-line no-unused-vars
function arrayBufferToBase64(buffer) {
  if (!buffer) {
    console.warn("[arrayBufferToBase64] Received null input.");
    return null;
  }
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}

// --- NEW HELPER FUNCTION --- START ---
/**
 * Try to build a Signal session, and if we get "Identity key changed",
 * reset that peer's session+identity and then build again.
 */
async function safeBuildSession(store, userId, deviceId, preKeyBundle) {
  const addr = `${userId}.${deviceId}`;
  try {
    await buildSession(store, userId, deviceId, preKeyBundle);
  } catch (err) {
    if (err.message?.includes("Identity key changed")) {
      console.warn(
        `[safeBuildSession] Identity key changed for ${addr}. Resetting and rebuilding.`
      );
      await store.removeSession(addr);
      await store.removeIdentity(addr);
      try {
        await buildSession(store, userId, deviceId, preKeyBundle);
        console.log(
          `[safeBuildSession] Second buildSession successful for ${addr} after reset.`
        );
      } catch (err2) {
        console.warn(
          `[safeBuildSession] Second buildSession failed for ${addr} after reset: ${err2.message}. Swallowing error to allow further processing.`
        );
        // SWALLOW err2 to allow SessionBuilder.processPreKey or encryptMessage to proceed
      }
    } else {
      console.error(
        `[safeBuildSession] Error building session for ${addr} (not identity change):`,
        err
      );
      throw err;
    }
  }
}
// --- NEW HELPER FUNCTION --- END ---

export default function ChatPage() {
  console.log("--- ChatPage Component Rendering ---");

  const [currentUser, setCurrentUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [conversations, setConversations] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [loadingConversations, setLoadingConversations] = useState(true);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [error, setError] = useState(null);
  const [messageSubscription, setMessageSubscription] = useState(null);
  const [isNewChatModalOpen, setIsNewChatModalOpen] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const fileInputRef = useRef();

  const isMobile = useMobile();
  const navigate = useNavigate();
  const messagesEndRef = useRef(null);
  const sig = useSignal();
  const { isReady, signalStore, deviceId, initializationError } = sig || {};
  const currentUserRef = useRef(currentUser);
  const selectedConversationRef = useRef(selectedConversation);

  console.log("[render] messages state length =", messages.length, messages);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // 1. Get current user and profile
  useEffect(() => {
    if (!sig) {
      console.log("[Effect 1] Signal context hook not ready, deferring.");
      return;
    }
    const fetchUserAndProfile = async () => {
      console.log("[Effect 1] Running fetchUserAndProfile...");
      setLoadingConversations(true);
      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession();
      if (sessionError) {
        console.error("Error getting session:", sessionError);
        setError("Failed to load user session.");
        setLoadingConversations(false);
        return;
      }
      if (!session?.user) {
        console.log("No user session found, redirecting to login.");
        navigate("/login");
        return;
      }
      setCurrentUser(session.user);
      if (session?.user && signalStore) {
        try {
          console.log(
            "[Effect 1] Initializing Signal protocol via context store for",
            session.user.id
          );
        } catch (initError) {
          console.error(
            "[Effect 1] Failed to initialize Signal protocol:",
            initError
          );
          setError(
            `Failed to initialize secure session keys: ${initError.message}`
          );
          setLoadingConversations(false);
          return;
        }
      }
      const { data: profileData, error: profileError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url, status")
        .eq("id", session.user.id)
        .single();
      if (profileError && profileError.code !== "PGRST116") {
        console.error("Error fetching profile:", profileError);
        setError(`Failed to load user profile: ${profileError.message}`);
      } else if (!profileData) {
        console.warn("[Effect 1] Profile not found for user:", session.user.id);
        setError("User profile not found. Please complete profile setup.");
      } else {
        setProfile(profileData);
        setError(null);
      }
    };
    fetchUserAndProfile();
  }, [navigate, sig]);

  useEffect(() => {
    currentUserRef.current = currentUser;
  }, [currentUser]);

  useEffect(() => {
    selectedConversationRef.current = selectedConversation;
  }, [selectedConversation]);

  // 2. Fetch conversations once user profile is loaded
  useEffect(() => {
    if (!profile?.id) {
      if (!loadingConversations && !profile) setLoadingConversations(false);
      return;
    }
    const fetchConversations = async () => {
      setLoadingConversations(true);
      try {
        const { data: participantData, error: participantError } =
          await supabase
            .from("conversation_participants")
            .select("conversation_id")
            .eq("profile_id", profile.id);
        if (participantError) throw participantError;
        const conversationIds = participantData.map((p) => p.conversation_id);
        if (conversationIds.length === 0) {
          setConversations([]);
          setLoadingConversations(false);
          return;
        }
        const { data: convData, error: convError } = await supabase
          .from("conversations")
          .select(
            `id, created_at, conversation_participants(profile_id, profiles(id, username, full_name, avatar_url, status))`
          )
          .in("id", conversationIds);
        if (convError) throw convError;
        const formattedConversations = convData.map((conv) => {
          const participants = conv.conversation_participants.map(
            (p) => p.profiles
          );
          const otherParticipant =
            participants.find((p) => p.id !== profile.id) || participants[0];
          return {
            id: conv.id,
            name:
              otherParticipant?.full_name ||
              otherParticipant?.username ||
              "Unknown User",
            lastMessage: "...",
            time: "",
            unread: 0,
            avatar: otherParticipant?.avatar_url,
            participants,
          };
        });
        setConversations(formattedConversations);
        if (!selectedConversation && formattedConversations.length > 0) {
          setSelectedConversation(formattedConversations[0]);
        } else if (formattedConversations.length === 0) {
          setSelectedConversation(null);
        }
      } catch (fetchError) {
        console.error("Error fetching conversations:", fetchError);
        setError("Failed to load conversations.");
      } finally {
        setLoadingConversations(false);
      }
    };
    fetchConversations();
  }, [profile?.id, selectedConversation]); // Keep selectedConversation here to re-evaluate if it changes elsewhere

  // 3. Fetch messages when selectedConversation changes
  useEffect(() => {
    if (!isReady) {
      console.log(
        "[Effect 3] Signal context not ready, deferring message fetch."
      );
      setMessages([]);
      return;
    }
    const { signalStore } = sig;
    if (!selectedConversation?.id || !currentUser?.id) {
      setMessages([]);
      return;
    }
    const recipientParticipant = selectedConversation.participants.find(
      (p) => p.id !== currentUser.id
    );
    if (!recipientParticipant) {
      setError("Error identifying recipient.");
      setMessages([]);
      setLoadingMessages(false);
      return;
    }
    const fetchMessagesAndEnsureSession = async () => {
      setLoadingMessages(true);
      setError(null);
      try {
        const { data, error: messagesError } = await supabase
          .from("messages")
          .select(
            `id, body, type, created_at, profile_id, device_id, target_device_id, profiles ( id, full_name, username, avatar_url )`
          )
          .eq("conversation_id", selectedConversation.id)
          .order("created_at", { ascending: true });
        if (messagesError) throw messagesError;
        const decryptedMessages = [];
        for (const msg of data) {
          let processedContent = null;
          const senderProfile = msg.profiles;
          const timestamp = msg.created_at
            ? new Date(msg.created_at).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              })
            : "";
          const isSelfSent = msg.profile_id === currentUser.id;
          const myCurrentDeviceId = deviceId;
          if (
            !isSelfSent &&
            msg.target_device_id !== undefined &&
            msg.target_device_id !== null &&
            msg.target_device_id !== myCurrentDeviceId
          ) {
            continue;
          }
          const cachedContent = await getCachedMessageContent(msg.id);
          if (cachedContent) {
            processedContent = cachedContent;
          } else {
            if (isSelfSent) {
              processedContent = "[Self, Uncached - Error]";
            } else {
              const dbHexString = msg.body;
              let bodyUint8Array;
              try {
                bodyUint8Array = hexToUint8Array(dbHexString);
              } catch (e) {
                console.error(
                  `[Effect 3] Hex conversion error for msg ${msg.id}:`,
                  e
                );
                processedContent = "[DB Body Corrupt]";
                decryptedMessages.push({
                  id: msg.id,
                  senderId: senderProfile?.id || msg.profile_id,
                  senderName:
                    senderProfile?.full_name ||
                    senderProfile?.username ||
                    "Unknown User",
                  senderAvatar: senderProfile?.avatar_url,
                  content: processedContent,
                  timestamp,
                  isSelf: false,
                });
                continue;
              }
              if (bodyUint8Array) {
                try {
                  const senderDeviceId = msg.device_id;
                  const plaintextBuffer = await decryptMessage(
                    signalStore,
                    currentUser.id,
                    msg.profile_id,
                    senderDeviceId || 1,
                    { type: msg.type, body: bodyUint8Array }
                  );
                  if (plaintextBuffer) {
                    processedContent = arrayBufferToString(plaintextBuffer);
                    await cacheSentMessage({
                      id: msg.id,
                      content: processedContent,
                      conversationId: selectedConversation.id,
                      timestamp: msg.created_at,
                    });
                  } else {
                    processedContent = "[Decryption Failed]";
                  }
                } catch (decryptionError) {
                  console.error(
                    `[Effect 3] Decryption error for msg ${msg.id}:`,
                    decryptionError
                  );
                  processedContent = "[Decryption Error]";
                }
              }
            }
          }
          decryptedMessages.push({
            id: msg.id,
            senderId: senderProfile?.id || msg.profile_id,
            senderName:
              senderProfile?.full_name ||
              senderProfile?.username ||
              (isSelfSent ? "Me" : "Unknown User"),
            senderAvatar: senderProfile?.avatar_url,
            content: processedContent,
            timestamp,
            isSelf: isSelfSent,
          });
        }
        setMessages(decryptedMessages);
      } catch (err) {
        setError(`Failed to load messages: ${err.message}`);
        setMessages([]);
      } finally {
        setLoadingMessages(false);
      }
    };
    fetchMessagesAndEnsureSession();
  }, [selectedConversation?.id, currentUser?.id, sig, isReady]);

  // 4. Scroll to bottom
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Define handleNewMessage in the component scope
  const handleNewMessage = async (payload) => {
    // Use refs for currentUser and selectedConversation to get latest values
    const currentUserService = currentUserRef.current;
    const selectedConversationService = selectedConversationRef.current;

    if (!isReady || !sig) {
      console.warn(
        "[Realtime HNM] Context not ready or sig not available. Skipping message."
      );
      return;
    }
    const {
      signalStore: currentSignalStore,
      deviceId: myCurrentDeviceIdFromContext,
    } = sig;
    const currentUserId = currentUserService?.id;

    if (!currentUserId) {
      console.warn(
        "[Realtime HNM] currentUser.id is not available. Skipping message."
      );
      return;
    }

    const { new: newMessageData } = payload;

    if (
      !selectedConversationService ||
      newMessageData.conversation_id !== selectedConversationService.id
    ) {
      console.log(
        "[Realtime HNM] Message for different or no selected conversation. Skipping."
      );
      return;
    }

    if (newMessageData.profile_id === currentUserId) {
      console.log("[Realtime HNM] Message is from self. Skipping.");
      return;
    }

    // Log and compare device IDs, coercing to string for comparison
    console.log(
      `[Realtime HNM] Comparing device IDs: incoming.target_device_id = ${
        newMessageData.target_device_id
      } (type: ${typeof newMessageData.target_device_id}), myCurrentDeviceId = ${myCurrentDeviceIdFromContext} (type: ${typeof myCurrentDeviceIdFromContext})`
    );

    if (
      newMessageData.target_device_id !== undefined &&
      newMessageData.target_device_id !== null && // Keep null check
      String(newMessageData.target_device_id) !==
        String(myCurrentDeviceIdFromContext)
    ) {
      console.log(
        `[Realtime HNM] Message not for this deviceId (Target: ${String(
          newMessageData.target_device_id
        )}, Mine: ${String(myCurrentDeviceIdFromContext)}). Skipping.`
      );
      return;
    }

    if (messages.some((msg) => msg.id === newMessageData.id)) {
      console.log(
        `[Realtime HNM] Message ${newMessageData.id} already exists. Skipping.`
      );
      return;
    }

    const senderAddress = new SignalProtocolAddress(
      newMessageData.profile_id,
      newMessageData.device_id || 1
    );
    const senderAddressString = senderAddress.toString();

    if (newMessageData.type === 3) {
      console.log(
        `[Realtime HNM] Received PreKeyWhisperMessage (Type 3) id: ${newMessageData.id} from ${senderAddressString}`
      );
      const existingSession = await currentSignalStore.loadSession(
        senderAddressString
      );
      if (!existingSession) {
        console.log(
          `[Realtime HNM] No existing session for ${senderAddressString} for Type 3. Attempting to build one.`
        );
        try {
          const peerBundlesData = await get(
            `/api/signal/bundles/${newMessageData.profile_id}`
          );
          if (!peerBundlesData || !Array.isArray(peerBundlesData)) {
            throw new Error(
              `No valid bundles array found for peer ${newMessageData.profile_id}.`
            );
          }
          const peerBundleMap = bundlesToMap(peerBundlesData);
          const specificDeviceBundle = peerBundleMap.get(
            newMessageData.device_id || 1
          );
          if (!specificDeviceBundle) {
            throw new Error(`Bundle not found for ${senderAddressString}`);
          }
          const sessionBuilder = new SessionBuilder(
            currentSignalStore,
            senderAddress
          );
          await sessionBuilder.processPreKey(specificDeviceBundle);
          console.log(
            `[Realtime HNM] SessionBuilder.processPreKey successful for ${senderAddressString}.`
          );
        } catch (buildError) {
          console.error(
            `[Realtime HNM] Error building session for Type 3 from ${senderAddressString}:`,
            buildError
          );
          // Allow decryption to proceed and likely fail, for logging.
        }
      } else {
        console.log(
          `[Realtime HNM] Existing session found for ${senderAddressString} for Type 3.`
        );
      }
    }

    const { data: senderProfile } = await supabase
      .from("profiles")
      .select("id, full_name, username, avatar_url")
      .eq("id", newMessageData.profile_id)
      .single();

    let bodyUint8Array;
    try {
      bodyUint8Array = hexToUint8Array(newMessageData.body);
    } catch (conversionError) {
      console.error(
        `[Realtime HNM] Hex conversion error for msg ${newMessageData.id}:`,
        conversionError
      );
      return;
    }
    if (!bodyUint8Array) {
      console.warn("[Realtime HNM] bodyUint8Array is null after conversion.");
      return;
    }

    const ciphertextForDecryption = {
      type: newMessageData.type,
      body: bodyUint8Array,
    };

    let plaintextBuffer;
    try {
      plaintextBuffer = await decryptMessage(
        currentSignalStore,
        currentUserId, // Pass currentUserId
        newMessageData.profile_id,
        newMessageData.device_id || 1,
        ciphertextForDecryption
      );
    } catch (e) {
      console.error("[Realtime HNM] Decryption error:", e);
      return;
    }
    if (!plaintextBuffer) {
      console.warn("[Realtime HNM] Decryption returned null.");
      return;
    }

    const plaintext = arrayBufferToString(plaintextBuffer);
    // Ensure selectedConversation is still valid before caching
    if (
      selectedConversationService &&
      selectedConversationService.id === newMessageData.conversation_id
    ) {
      await cacheSentMessage({
        id: newMessageData.id,
        content: plaintext,
        conversationId: selectedConversationService.id,
        timestamp: newMessageData.created_at,
      });
    }

    const formatted = {
      id: newMessageData.id,
      senderId: senderProfile?.id || newMessageData.profile_id,
      senderName:
        senderProfile?.full_name || senderProfile?.username || "Unknown",
      senderAvatar: senderProfile?.avatar_url,
      content: plaintext,
      timestamp: new Date(newMessageData.created_at).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
      isSelf: false, // Realtime messages are never from self in this handler
    };
    setMessages((prevMessages) => {
      // Check for duplicates again with prevMessages to be absolutely sure
      if (prevMessages.some((msg) => msg.id === formatted.id)) {
        return prevMessages;
      }
      return [...prevMessages, formatted];
    });
  };

  // 5. Realtime subscription
  useEffect(() => {
    if (!isReady || !selectedConversation?.id) {
      return;
    }

    if (messageSubscription) {
      console.log(
        `[Realtime Effect] Explicitly unsubscribing existing messageSubscription (topic: ${messageSubscription.topic}) before creating new one for conv ${selectedConversation.id}.`
      );
      messageSubscription.unsubscribe();
    }

    console.log(
      `[Realtime Effect] Setting up subscription for conversation: ${selectedConversation.id}`
    );
    const chan = supabase
      .channel(`messages:${selectedConversation.id}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
          filter: `conversation_id=eq.${selectedConversation.id}`,
        },
        handleNewMessage // Now correctly references the function in component scope
      )
      .subscribe((status, err) => {
        if (err) {
          console.error(
            `[Realtime] SUBSCRIBE ERROR for conv ${selectedConversation.id}:`,
            err
          );
        } else {
          console.log(
            `[Realtime] Subscription status for conv ${selectedConversation.id}: ${status}`
          );
        }
      });

    setMessageSubscription(chan);

    return () => {
      console.log(
        `[Realtime Effect Cleanup] Unsubscribing channel for conv ${selectedConversation?.id} (channel topic: ${chan.topic})`
      );
      chan.unsubscribe();
    };
  }, [selectedConversation?.id, isReady]);

  const handleSendMessage = async () => {
    if (!isReady) {
      setError("Secure session not ready.");
      return;
    }
    if (
      (!newMessage.trim() && !selectedFile) ||
      !selectedConversation ||
      !currentUser ||
      deviceId === null
    )
      return;

    const { signalStore, deviceId: myDeviceId } = sig;
    const conversationId = selectedConversation.id;
    const profileId = currentUser.id;
    const originalNewMessage = newMessage;

    let contentToProcess = newMessage.trim();
    if (selectedFile) {
      const fileMarker = `[File] ${selectedFile.name}`;
      if (contentToProcess) {
        contentToProcess = `${contentToProcess} ${fileMarker}`;
      } else {
        contentToProcess = fileMarker;
      }
    }

    try {
      const peer = selectedConversation.participants.find(
        (p) => p.id !== profileId
      );
      if (!peer) throw new Error("Could not find peer.");
      const peerBundlesData = await get(`/api/signal/bundles/${peer.id}`);
      if (!peerBundlesData || !Array.isArray(peerBundlesData))
        throw new Error(`No key bundles for peer ${peer.id}.`);
      const bundleMap = bundlesToMap(peerBundlesData);
      if (bundleMap.size === 0)
        throw new Error(
          `No pre-key bundle published for ${
            selectedConversation.name || peer.id
          }.`
        );
      const plaintextBytes = new TextEncoder().encode(contentToProcess);
      let lastInsertedMessageData = null;

      for (const [peerDeviceId, preKeyBundleForDevice] of bundleMap) {
        const addr = new SignalProtocolAddress(peer.id, peerDeviceId);
        const addrStr = addr.toString();

        try {
          if (!(await signalStore.containsSession(addrStr))) {
            console.log(
              `[SendMessage] No session for ${addrStr}, attempting initial safeBuildSession...`
            );
            await safeBuildSession(
              signalStore,
              peer.id,
              peerDeviceId,
              preKeyBundleForDevice
            );
            console.log(
              `[SendMessage] Initial safeBuildSession completed for ${addrStr}.`
            );
          }
        } catch (buildErr) {
          console.warn(
            `[SendMessage] Error during initial safeBuildSession for ${addrStr}, continuing to next step or device: `,
            buildErr.message || buildErr
          );
          // Continue to the explicit SessionBuilder.processPreKey attempt or next device
        }

        // --- force the PreKey handshake on sender side (USER'S DIFF) ---
        try {
          console.log(
            `[SendMessage] Attempting direct SessionBuilder.processPreKey for ${addrStr} before encryption.`
          );
          const builder = new SessionBuilder(signalStore, addr);
          await builder.processPreKey(preKeyBundleForDevice);
          console.log(
            `[SendMessage] Direct SessionBuilder.processPreKey successful for ${addrStr}.`
          );
        } catch (processPreKeyError) {
          console.warn(
            `[SendMessage] Error during direct SessionBuilder.processPreKey for ${addrStr}: ${processPreKeyError.message}. Encryption will still be attempted.`,
            processPreKeyError
          );
        }

        // Now, attempt encryption and DB insert
        try {
          console.log(`[SendMessage] Attempting encryption for ${addrStr}...`);
          const ct = await encryptMessage(
            signalStore,
            peer.id,
            peerDeviceId,
            plaintextBytes.buffer
          );
          const bodyUint8Array = Uint8Array.from(ct.body, (c) =>
            c.charCodeAt(0)
          );
          const pgByteaLiteral = `\\x${buf2hex(bodyUint8Array)}`;
          console.log(`[SendMessage] Attempting DB insert for ${addrStr}...`);
          const { data: insertedData, error: insertError } = await supabase
            .from("messages")
            .insert({
              conversation_id: conversationId,
              profile_id: profileId,
              type: ct.type,
              body: pgByteaLiteral,
              device_id: myDeviceId,
              target_device_id: peerDeviceId,
            })
            .select();
          if (insertError) {
            console.error(`DB insert failed for ${addrStr}:`, insertError);
            continue;
          }
          if (insertedData && insertedData.length > 0) {
            lastInsertedMessageData = insertedData[0];
            console.log(
              `[SendMessage] Successfully sent to ${addrStr}. Continuing to next device if any.`
            );
          }
        } catch (encryptErr) {
          if (
            encryptErr instanceof Error &&
            encryptErr.message?.includes("Identity key changed")
          ) {
            console.warn(
              `[SendMessage] Identity key changed during encrypt/send for ${addrStr}. Retrying build and send...`
            );
            await signalStore.removeSession(addrStr);
            await signalStore.removeIdentity(addrStr);
            try {
              await safeBuildSession(
                signalStore,
                peer.id,
                peerDeviceId,
                preKeyBundleForDevice
              );
              console.log(
                `[SendMessage] safeBuildSession successful for ${addrStr} after identity change during encrypt.`
              );
              // Retry encrypt + insert
              const ctRetry = await encryptMessage(
                signalStore,
                peer.id,
                peerDeviceId,
                plaintextBytes.buffer
              );
              const bodyRetry = Uint8Array.from(ctRetry.body, (c) =>
                c.charCodeAt(0)
              );
              const pgByteaRetry = `\\x${buf2hex(bodyRetry)}`;
              const { data: insertedDataRetry, error: insertErrRetry } =
                await supabase
                  .from("messages")
                  .insert({
                    conversation_id: conversationId,
                    profile_id: profileId,
                    type: ctRetry.type,
                    body: pgByteaRetry,
                    device_id: myDeviceId,
                    target_device_id: peerDeviceId,
                  })
                  .select();

              if (insertErrRetry) {
                console.error(
                  `[SendMessage] DB insert failed for ${addrStr} on retry:`,
                  insertErrRetry
                );
                continue;
              }
              if (insertedDataRetry && insertedDataRetry.length > 0) {
                lastInsertedMessageData = insertedDataRetry[0];
                console.log(
                  `[SendMessage] Successfully sent to ${addrStr} after retry. Continuing to next device if any.`
                );
              }
            } catch (retryBuildErr) {
              console.error(
                `[SendMessage] Failed to rebuild session or resend for ${addrStr} after identity change: ${retryBuildErr.message}. Skipping device.`,
                retryBuildErr
              );
              continue;
            }
          } else {
            console.error(
              `[SendMessage] Non-identity error during encrypt/send for ${addrStr}:`,
              encryptErr
            );
            continue;
          }
        }
      } // End for...of loop
      if (lastInsertedMessageData) {
        setError(null);
        const newMessageForUI = {
          id: lastInsertedMessageData.id,
          senderId: profileId,
          senderName: profile?.full_name || profile?.username || "Me",
          senderAvatar: profile?.avatar_url,
          content: contentToProcess,
          timestamp: new Date(
            lastInsertedMessageData.created_at
          ).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
          isSelf: true,
        };
        setMessages((prevMessages) => [...prevMessages, newMessageForUI]);
        await cacheSentMessage({ ...newMessageForUI, conversationId });
        setNewMessage("");
        setSelectedFile(null);
      } else if (bundleMap.size > 0) {
        setError("Failed to send message to any peer device.");
        setNewMessage(originalNewMessage);
      } else {
        setError("No key bundles for recipient.");
        setNewMessage(originalNewMessage);
      }
    } catch (err) {
      setError(`Failed to send message: ${err.message}`);
      setNewMessage(originalNewMessage);
    }
  };

  const handleFileSelect = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const maxSizeMB = 10;
    if (file.size > maxSizeMB * 1024 * 1024) {
      alert(`File size exceeds ${maxSizeMB}MB limit.`);
      return;
    }

    setSelectedFile(file);
  };

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error("Error logging out:", error);
    } else {
      navigate("/login");
    }
  };

  const handleUserSelect = async (selectedUser) => {
    console.log("Selected user to start chat with:", selectedUser);
    if (!currentUser || !profile) {
      console.error("Current user or profile not loaded.");
      return;
    }
    if (selectedUser.id === currentUser.id) {
      console.warn("Cannot start chat with self.");
      return;
    }

    setIsNewChatModalOpen(false); // Close modal immediately

    try {
      // 1. Check if a conversation already exists
      const existingConversation = conversations.find((conv) => {
        // Check if participants array exists and has exactly 2 participants (for 1-on-1 chat)
        // Adjust this logic if group chats need different handling
        if (!conv.participants || conv.participants.length !== 2) return false;
        // Check if both currentUser and selectedUser are participants
        const hasCurrentUser = conv.participants.some(
          (p) => p.id === currentUser.id
        );
        const hasSelectedUser = conv.participants.some(
          (p) => p.id === selectedUser.id
        );
        return hasCurrentUser && hasSelectedUser;
      });

      if (existingConversation) {
        console.log("Found existing conversation:", existingConversation);
        setSelectedConversation(existingConversation);
      } else {
        console.log("No existing conversation found, creating new one...");
        // 2. Create New Conversation
        const { data: newConvData, error: convInsertError } = await supabase
          .from("conversations")
          .insert({})
          .select()
          .single();

        if (convInsertError) throw convInsertError;
        const newConversationId = newConvData.id;
        console.log("Created new conversation with ID:", newConversationId);

        // 3. Add Participants
        const { error: participantInsertError } = await supabase
          .from("conversation_participants")
          .insert([
            { conversation_id: newConversationId, profile_id: currentUser.id },
            { conversation_id: newConversationId, profile_id: selectedUser.id },
          ]);

        if (participantInsertError) throw participantInsertError;
        console.log("Added participants to new conversation.");

        // 4. Construct new conversation object for UI state
        const newConversationForState = {
          id: newConversationId,
          name: selectedUser.full_name || selectedUser.username, // Use selected user's name for 1-on-1
          lastMessage: "", // No messages yet
          time: "",
          unread: 0,
          avatar: selectedUser.avatar_url, // Use selected user's avatar
          participants: [
            {
              // Current user's profile
              id: profile.id,
              username: profile.username,
              full_name: profile.full_name,
              avatar_url: profile.avatar_url,
              status: profile.status,
            },
            {
              // Selected user's profile (from modal data)
              id: selectedUser.id,
              username: selectedUser.username,
              full_name: selectedUser.full_name,
              avatar_url: selectedUser.avatar_url,
              status: "offline", // Assume offline initially, status updates needed separately
            },
          ],
        };

        // 5. Update State
        setConversations((prev) => [newConversationForState, ...prev]); // Add to beginning
        setSelectedConversation(newConversationForState);
        console.log(
          "Set new conversation as selected:",
          newConversationForState
        );
      }
    } catch (err) {
      console.error("Error starting chat:", err);
      setError("Failed to start chat. " + err.message);
    }
  };

  // --- Conditional Return for loading Signal context OR other states ---
  if (initializationError) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-red-400">
        Error initializing secure session: {initializationError}
      </div>
    );
  }
  if (!isReady) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-white">
        Initializing secure session...
      </div>
    );
  }
  if (error && !initializationError) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-red-400">
        Error: {error}
      </div>
    );
  }

  // Main component JSX, ensure sig.deviceId is used where myDeviceIdForJSX was used
  return (
    <div className="flex h-screen bg-slate-900">
      {/* Sidebar - Chat List */}
      {(!isMobile || isMobileMenuOpen) && (
        <AnimatePresence>
          <div
            className={`${
              isMobile ? "absolute z-10 w-full max-w-xs" : "w-80"
            } h-full bg-slate-800 border-r border-slate-700 flex flex-col`}
          >
            {/* Header */}
            <div className="p-4 border-b border-slate-700 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <MessageSquare className="h-5 w-5 text-emerald-400" />
                <h1 className="font-bold text-white">Messages</h1>
              </div>
              <div className="flex gap-2">
                <Dialog
                  open={isNewChatModalOpen}
                  onOpenChange={setIsNewChatModalOpen}
                >
                  <DialogTrigger asChild>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="text-slate-400 hover:text-white"
                    >
                      <Plus className="h-5 w-5" />
                    </Button>
                  </DialogTrigger>
                  <NewChatModal
                    currentUser={currentUser}
                    onUserSelect={handleUserSelect}
                  />
                </Dialog>
                {isMobile && (
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                    onClick={() => setIsMobileMenuOpen(false)}
                  >
                    <ArrowLeft className="h-5 w-5" />
                  </Button>
                )}
              </div>
            </div>

            {/* Search */}
            <div className="p-4 border-b border-slate-700">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                <Input
                  placeholder="Search conversations..."
                  className="pl-9 bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
            </div>

            {/* Chat List Area */}
            <ScrollArea className="flex-1">
              <div className="p-2">
                {conversations.map((conv) => (
                  <div
                    key={conv.id}
                    className={`p-3 rounded-lg cursor-pointer mb-1 hover:bg-slate-700/50 ${
                      selectedConversation?.id === conv.id ? "bg-slate-700" : ""
                    }`}
                    onClick={() => {
                      setSelectedConversation(conv);
                      if (isMobile) setIsMobileMenuOpen(false);
                    }}
                  >
                    <div className="flex items-center gap-3">
                      <Avatar>
                        <AvatarImage
                          src={conv.avatar || "/placeholder.svg"}
                          alt={conv.name}
                        />
                        <AvatarFallback className="bg-emerald-500 text-white">
                          {conv.name
                            ?.split(" ")
                            .map((n) => n[0])
                            .join("") || "??"}
                        </AvatarFallback>
                      </Avatar>
                      <div className="flex-1 min-w-0">
                        <div className="flex justify-between items-center">
                          <h3 className="font-medium text-white truncate">
                            {conv.name}
                          </h3>
                          <span className="text-xs text-slate-400">
                            {conv.time}
                          </span>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-sm text-slate-400 truncate">
                            {conv.lastMessage}
                          </p>
                          {conv.unread > 0 && (
                            <span className="bg-emerald-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                              {conv.unread}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>

            {/* Footer Profile Section */}
            <div className="p-4 border-t border-slate-700 flex items-center justify-between">
              <Link to="/profile" className="flex items-center gap-3">
                <Avatar>
                  <AvatarImage
                    src={
                      profile?.avatar_url ||
                      "/placeholder.svg?height=40&width=40"
                    }
                    alt="Your Avatar"
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {(profile?.full_name || profile?.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="font-medium text-white">
                    {profile?.full_name || profile?.username || "Loading..."}
                  </p>
                  <p className="text-xs text-slate-400">
                    {profile?.status || "Offline"}
                  </p>
                </div>
              </Link>
              <div className="flex gap-1">
                <Link to="/settings">
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                  >
                    <Settings className="h-5 w-5" />
                  </Button>
                </Link>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-slate-400 hover:text-white"
                  onClick={handleLogout}
                >
                  <LogOut className="h-5 w-5" />
                </Button>
              </div>
            </div>
          </div>
        </AnimatePresence>
      )}

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col h-full">
        {/* Chat Header */}
        <div className="p-4 border-b border-slate-700 flex items-center justify-between bg-slate-800">
          <div className="flex items-center gap-3">
            {isMobile && (
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white"
                onClick={() => setIsMobileMenuOpen(true)}
              >
                <Menu className="h-5 w-5" />
              </Button>
            )}

            {selectedConversation && (
              <>
                <Avatar>
                  <AvatarImage
                    src={selectedConversation.avatar || "/placeholder.svg"}
                    alt={selectedConversation.name}
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {selectedConversation.name
                      ?.split(" ")
                      .map((n) => n[0])
                      .join("") || "??"}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <h2 className="font-medium text-white">
                    {selectedConversation.name}
                  </h2>
                  <p className="text-xs text-slate-400">Online</p>
                </div>
              </>
            )}
            {!selectedConversation && !loadingConversations && (
              <div className="text-slate-400">
                Select a conversation to start chatting
              </div>
            )}
          </div>

          {/* More Options Sheet */}
          <Sheet>
            <SheetTrigger asChild disabled={!selectedConversation}>
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white disabled:opacity-50"
              >
                <MoreVertical className="h-5 w-5" />
              </Button>
            </SheetTrigger>
            <SheetContent className="bg-slate-800 border-slate-700 text-white">
              <div className="space-y-4 py-4">
                <div className="flex flex-col items-center gap-2 pb-4 border-b border-slate-700">
                  <Avatar className="h-20 w-20">
                    <AvatarImage
                      src={selectedConversation?.avatar || "/placeholder.svg"}
                      alt={selectedConversation?.name}
                    />
                    <AvatarFallback className="bg-emerald-500 text-white text-xl">
                      {selectedConversation?.name
                        ?.split(" ")
                        .map((n) => n[0])
                        .join("") || "??"}
                    </AvatarFallback>
                  </Avatar>
                  <h3 className="text-xl font-bold">
                    {selectedConversation?.name}
                  </h3>
                  <p className="text-sm text-slate-400">Online</p>
                </div>

                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-slate-400">
                    Options
                  </h4>
                  <div className="space-y-1">
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-white"
                    >
                      <User className="mr-2 h-4 w-4" />
                      View Profile
                    </Button>
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-white"
                    >
                      <MessageSquare className="mr-2 h-4 w-4" />
                      Search in Conversation
                    </Button>
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-red-400 hover:text-red-300 hover:bg-red-900/20"
                    >
                      <LogOut className="mr-2 h-4 w-4" />
                      Delete Conversation
                    </Button>
                  </div>
                </div>
              </div>
            </SheetContent>
          </Sheet>
        </div>

        {/* Messages Area */}
        <ScrollArea className="flex-1 p-4 bg-gradient-to-b from-slate-900 to-slate-800">
          <div className="space-y-4">
            {loadingMessages && (
              <div className="text-center text-slate-400 py-4">
                Loading messages...
              </div>
            )}
            {!loadingMessages &&
              messages.map((message) => (
                <div
                  key={message.id}
                  className={`flex ${
                    message.isSelf ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] ${
                      message.isSelf ? "order-2" : "order-1"
                    }`}
                  >
                    {!message.isSelf && (
                      <div className="flex items-center gap-2 mb-1">
                        <Avatar className="h-6 w-6">
                          <AvatarImage
                            src={message.senderAvatar || "/placeholder.svg"}
                            alt={message.senderName}
                          />
                          <AvatarFallback className="bg-emerald-500 text-white text-xs">
                            {message.senderName
                              ?.split(" ")
                              .map((n) => n[0])
                              .join("") || "??"}
                          </AvatarFallback>
                        </Avatar>
                        <span className="text-xs text-slate-400">
                          {message.senderName}
                        </span>
                      </div>
                    )}
                    <div
                      className={`rounded-lg p-3 ${
                        message.isSelf
                          ? "bg-emerald-500 text-white rounded-tr-none"
                          : "bg-slate-700 text-white rounded-tl-none"
                      }`}
                    >
                      <p>
                        {message.content.startsWith("[File](") ? (
                          // Format: [File](url) filename
                          (() => {
                            const match = message.content.match(
                              /\[File\]\((.*?)\)\s*(.*)/
                            );
                            const url = match?.[1];
                            const name = match?.[2] || "Download File";
                            return (
                              <a
                                href={url}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="underline text-blue-400"
                              >
                                📎 {name}
                              </a>
                            );
                          })()
                        ) : message.content.startsWith("[File] ") ? (
                          // Format: [File] filename (no URL yet — fallback)
                          <span className="text-slate-300">
                            📎 {message.content.slice(7)}
                          </span>
                        ) : (
                          message.content
                        )}
                      </p>
                    </div>
                    <p className="text-xs text-slate-400 mt-1 ${message.isSelf ? 'text-left' : 'text-right'}">
                      {message.timestamp}
                    </p>
                  </div>
                </div>
              ))}
            {!loadingMessages &&
              messages.length === 0 &&
              selectedConversation && (
                <div className="text-center text-slate-500 pt-10">
                  No messages yet. Start the conversation!
                </div>
              )}
            <div ref={messagesEndRef} />
          </div>
          {!selectedConversation && !loadingConversations && (
            <div className="text-center text-slate-500 pt-10">
              Select a conversation to view messages.
            </div>
          )}
        </ScrollArea>

        {/* Message Input */}
        <div className="p-4 border-t border-slate-700 bg-slate-800 relative">
          <form
            onSubmit={(e) => {
              e.preventDefault();
              handleSendMessage();
            }}
            className="flex items-center gap-2"
          >
            <Button
              type="button"
              variant="ghost"
              className="text-slate-400 hover:text-white"
              onClick={() => fileInputRef.current.click()}
            >
              📎
            </Button>

            <input
              type="file"
              ref={fileInputRef}
              style={{ display: "none" }}
              onChange={handleFileSelect}
            />

            <Input
              placeholder="Type a message..."
              className="bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
              value={newMessage}
              onChange={(e) => setNewMessage(e.target.value)}
              disabled={
                !selectedConversation || loadingConversations || !isReady
              }
            />
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={() => setShowEmojiPicker((prev) => !prev)}
            >
              😀
            </Button>

            <Button
              type="submit"
              size="icon"
              className="bg-emerald-500 hover:bg-emerald-600 text-white"
              disabled={
                (!newMessage.trim() && !selectedFile) ||
                !selectedConversation ||
                loadingConversations ||
                !isReady
              }
            >
              <Send className="h-5 w-5" />
            </Button>
          </form>
          {showEmojiPicker && (
            <div className="absolute bottom-24 right-8 z-50">
              <EmojiPicker
                onEmojiClick={(emojiData) =>
                  setNewMessage((prev) => prev + emojiData.emoji)
                }
              />
            </div>
          )}

          {selectedFile && (
            <div className="text-slate-400 text-xs mt-2 ml-2">
              Attached: {selectedFile.name}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/pages/CryptoTestPage.jsx
================
import { useState } from 'react';
import { clear, get, set } from 'idb-keyval';
import { initializeKeys, initiateX3DH, encryptMessage, decryptMessage } from '../lib/signalCrypto';

function CryptoTestPage() {
  const [result, setResult] = useState('');

  async function runTest() {
    try {
      console.log('Starting test...');

      // Clear idb-keyval to ensure clean state
      await clear();
      console.log('idb-keyval cleared');

      // Initialize keys for Alice and Bob
      console.log('Initializing Alice keys...');
      const aliceKeys = await initializeKeys('alice');
      console.log('Alice keys:', aliceKeys);

      console.log('Initializing Bob keys...');
      const bobKeys = await initializeKeys('bob');
      console.log('Bob keys:', bobKeys);

      // Perform X3DH key agreement
      console.log('Alice initiating X3DH with Bob...');
      const aliceSharedKey = await initiateX3DH('alice', 'bob', bobKeys);
      console.log('Alice shared key:', !!aliceSharedKey);

      console.log('Bob initiating X3DH with Alice...');
      const bobSharedKey = await initiateX3DH('bob', 'alice', aliceKeys);
      console.log('Bob shared key:', !!bobSharedKey);

      // Test encryption and decryption
      const message = 'Hello, Bob!';
      console.log('Encrypting message:', message);
      const encrypted = await encryptMessage('alice', 'bob', message);
      console.log('Encrypted:', encrypted);

      console.log('Decrypting message...');
      const decrypted = await decryptMessage('bob', 'alice', encrypted);
      console.log('Decrypted:', decrypted);

      if (decrypted === message) {
        console.log('✅ Message decrypted correctly');
        setResult('Test passed: Message decrypted correctly');
      } else {
        console.error('❌ Decryption failed: mismatch');
        setResult('Test failed: Decryption mismatch');
      }
    } catch (error) {
      console.error('Test failed:', error);
      setResult(`Test failed: ${error.message}`);
    }
  }

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold">Crypto Test</h1>
      <button
        onClick={runTest}
        className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
      >
        Run Test
      </button>
      <p className="mt-4">{result}</p>
    </div>
  );
}

export default CryptoTestPage;

================
File: src/pages/ForgotPasswordPage.jsx
================
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { AlertCircle, ArrowLeft, Mail } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
// eslint-disable-next-line
import { motion } from "framer-motion";

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!email) {
      setError("Please enter your email address");
      return;
    }

    setIsLoading(true);

    // Simulate API call
    try {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      setIsSubmitted(true);
    } catch (err) {
      setError("Failed to send reset email. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/login"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Login
        </Link>
      </header>

      <main className="flex-1 flex items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="w-full max-w-md"
        >
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-2">
                <Mail className="h-8 w-8 text-emerald-400" />
              </div>
              <CardTitle className="text-2xl text-center text-white">
                Reset your password
              </CardTitle>
              <CardDescription className="text-center text-slate-400">
                Enter your email address and we'll send you a link to reset your
                password
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <Alert
                  variant="destructive"
                  className="mb-4 bg-red-900/20 border-red-800 text-red-300"
                >
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              {isSubmitted ? (
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  className="text-center space-y-4"
                >
                  <div className="bg-emerald-900/20 border border-emerald-800 text-emerald-300 p-4 rounded-md">
                    <p>Reset link sent! Check your email for instructions.</p>
                  </div>
                  <p className="text-slate-400 text-sm">
                    Didn't receive an email? Check your spam folder or{" "}
                    <button
                      onClick={() => setIsSubmitted(false)}
                      className="text-emerald-400 hover:text-emerald-300"
                    >
                      try again
                    </button>
                  </p>
                </motion.div>
              ) : (
                <form onSubmit={handleSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="email" className="text-slate-200">
                      Email
                    </Label>
                    <Input
                      id="email"
                      type="email"
                      placeholder="name@example.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      className="bg-slate-900/50 border-slate-700 text-slate-200"
                    />
                  </div>

                  <Button
                    type="submit"
                    className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
                    disabled={isLoading}
                  >
                    {isLoading ? "Sending..." : "Send reset link"}
                  </Button>
                </form>
              )}
            </CardContent>
            <CardFooter className="flex justify-center">
              <p className="text-sm text-slate-400">
                Remember your password?{" "}
                <Link
                  to="/login"
                  className="text-emerald-400 hover:text-emerald-300"
                >
                  Sign in
                </Link>
              </p>
            </CardFooter>
          </Card>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/HomePage.jsx
================
import { Button } from "@/components/ui/button";
import { ArrowRight, Lock, MessageSquare, Shield, Zap } from "lucide-react";
import { Link } from "react-router-dom";
//eslint-disable-next-line
import { motion, AnimatePresence } from "framer-motion";
import { useEffect, useState } from "react";

export default function HomePage() {
  //Phrases to be displayed on right side of page
  const phrases = [
    "In a world of leaks and hacks, your conversations deserve absolute confidentiality.",
    "Share moments, ideas, and secrets — with complete peace of mind.",
    "No ads. No trackers. Just secure communication.",
    "Your messages are for you — and only you.",
    "Privacy isn't a feature. It's our foundation.",
  ];

  const [currentPhrase, setCurrentPhrase] = useState(0);
  const [randomPosition, setRandomPosition] = useState({ top: "50%", left: "50%" });

  useEffect(() => { 
      const interval = setInterval(() => {
      setCurrentPhrase((prev) => (prev + 1) % phrases.length);
  
      const top = Math.floor(Math.random() * 30) + 30;  // between 30% and 70%
      const left = Math.floor(Math.random() * 5) + 50; // between 60% and 75%           
      setRandomPosition({ top: `${top}%`, left: `${left}%` });
    }, 5000); // 5 seconds
  
    return () => clearInterval(interval);
  }, []);  

  return (
    <div className="flex flex-col min-h-screen bg-gradient-to-b from-slate-900 to-slate-800">
      {/* Header */}
      <header className="container mx-auto p-4 flex justify-between items-center">
        <div className="flex items-center gap-2">
          <Lock className="h-8 w-8 text-emerald-500" />
          <span className="font-bold text-white text-2xl">SecureChat</span>
        </div>
      </header>

       {/* Main Section */}
      <main className="flex-1 container mx-auto px-4 py-12 flex flex-col md:flex-row items-center justify-center text-center gap-8">

        {/* Left Side Content */}
        <div className="hidden 2xl:flex flex-1">
          <div className="flex flex-col">
            <img
              src="/images/green_text.png"
              alt="Chat bubble green"
              className="w-60 ml-0"
            />
            <img
              src="/images/blue_text.png"
              alt="Chat bubble blue"
              className="w-60 ml-30"
            />
          </div>
        </div>


        {/* Center Content */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="flex-1 max-w-md"
        >
          <div className="mb-6 flex justify-center">
            <div className="relative drop-shadow-lg">
              <Lock className="h-20 w-20 text-emerald-500" />
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                transition={{ delay: 0.3, duration: 0.5 }}
                className="absolute -top-1 -right-1 bg-blue-400 rounded-full p-1 shadow-md"
              >
                <Shield className="h-6 w-6 text-slate-900" />
              </motion.div>
            </div>
          </div>

          
          <h1 className="text-3xl md:text-5xl font-bold text-white mb-4 tracking-wide">
            Secure. Private. Encrypted.
          </h1>

          <p className="text-slate-300 mb-8">
            End-to-end encrypted messaging that keeps your conversations private
            and secure.
          </p>
          
          <div className="grid gap-4 mb-8">
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.2, duration: 0.5 }}
              className="flex items-center gap-3 bg-slate-800/50 p-3 rounded-lg text-left border border-slate-700 hover:bg-slate-700 transition"
            >
              <Shield className="h-5 w-5 text-emerald-400 flex-shrink-0" />
              <span className="text-slate-200 text-sm">
                End-to-end encryption for all messages
              </span>
            </motion.div>

            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.3, duration: 0.5 }}
              className="flex items-center gap-3 bg-slate-800/50 p-3 rounded-lg text-left border border-slate-700 hover:bg-slate-700 transition"
            >
              <Zap className="h-5 w-5 text-emerald-400 flex-shrink-0" />
              <span className="text-slate-200 text-sm">
                Fast, reliable messaging on any device
              </span>
            </motion.div>

            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.4, duration: 0.5 }}
              className="flex items-center gap-3 bg-slate-800/50 p-3 rounded-lg text-left border border-slate-700 hover:bg-slate-700 transition"
            >
              <MessageSquare className="h-5 w-5 text-emerald-400 flex-shrink-0" />
              <span className="text-slate-200 text-sm">
                Group chats with the same level of security
              </span>
            </motion.div>
          </div>
            
          <div className="flex flex-col sm:flex-row gap-5">
            <Link to="/login" className="w-full">
              <Button className="w-full bg-emerald-500 hover:bg-emerald-600 text-white">  
                Login
              </Button>
            </Link>  
          </div>

          <div className="flex flex-col sm:flex-row gap-22 mt-4">
            <span className="text-slate-200 text-sm">
                Don't have an account?
            </span>
            <span className="text-slate-200 text-sm">
                Want to learn more?
            </span>
          </div>

          <div className="flex flex-col sm:flex-row gap-4 mt-1">
            <Link to="/signup" className="w-full">
              <Button className="w-full bg-blue-400 hover:bg-blue-600 text-white">
                Get Started <ArrowRight className="ml-2 h-4 w-4" />
              </Button>
            </Link>
            <Link to="/about" className="w-full">
              <Button
                variant="outline"
                className="w-full border-slate-700 text-slate-600 hover:bg-slate-700"
              >
                Learn More
              </Button>
            </Link>
          </div>
        </motion.div>
      

          {/* Right Side */}
          <div className="hidden 2xl:flex flex-1 relative overflow-hidden min-h-[500px]">
            <AnimatePresence mode="wait">
              <motion.div
                key={currentPhrase}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.6 }}
                style={{
                  position: "absolute",
                  top: randomPosition.top,
                  left: randomPosition.left,
                  transform: "translate(-50%, -50%)",
                  maxWidth: "250px",
                }}
                className="bg-slate-800/50 p-4 rounded-lg border border-slate-700 text-slate-200 text-center italic text-xl leading-relaxed"
              >
                “{phrases[currentPhrase]}”
              </motion.div>
            </AnimatePresence>
          </div>

        </main>

      {/* Footer */}
      <footer className="container mx-auto p-4 text-center text-slate-400 text-sm">
        <p>© {new Date().getFullYear()} SecureChat. All rights reserved.</p>
      </footer>
    </div>
  );
}

================
File: src/pages/LoginPage.jsx
================
import { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { AlertCircle, ArrowLeft, Lock, Eye, EyeOff } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
// eslint-disable-next-line
import { motion } from "framer-motion";
import { supabase } from "../lib/supabaseClient";

export default function LoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!email || !password) {
      setError("Please enter both email and password");
      return;
    }

    setIsLoading(true);

    try {
      const { data, error: signInError } =
        await supabase.auth.signInWithPassword({
          email: email,
          password: password,
        });

      if (signInError) {
        setError(signInError.message);
      } else if (data.session) {
        console.log("Login successful, user:", data.session.user);
        console.log("Navigating to chat...");
        navigate("/chat");
      } else {
        console.error("Login response did not include a session");
        setError("An unexpected error occurred. Please try again.");
      }
    } catch (err) {
      console.error("Unexpected error during login:", err);
      setError("An unexpected error occurred. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  //show password
  const handleState = () => {
    setShowPassword((showState) => !showState);
  };


  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Home
        </Link>
      </header>

      <main className="flex-1 flex items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="w-full max-w-md"
        >
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-2">
                <Lock className="h-8 w-8 text-emerald-400" />
              </div>
              <CardTitle className="text-2xl text-center text-white">
                Welcome back
              </CardTitle>
              <CardDescription className="text-center text-slate-400">
                Enter your credentials to access your account
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <Alert
                  variant="destructive"
                  className="mb-4 bg-red-900/20 border-red-800 text-red-300"
                >
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              <form onSubmit={handleSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="email" className="text-slate-200">
                    Email
                  </Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="name@example.com"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <Label htmlFor="password" className="text-slate-200">
                      Password
                    </Label>
                    <Link
                      to="/forgot-password"
                      className="text-xs text-emerald-400 hover:text-emerald-300"
                    >
                      Forgot password?
                    </Link>
                  </div>

                  <div className="relative">
                    <Input
                      id="password"
                      type={showPassword ? "text" : "password"}
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      className="bg-slate-900/50 border-slate-700 text-slate-200"
                    />
                    <button
                      type="button"
                      onClick={handleState}
                      className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-slate-200"
                    >
                      {showPassword ? <Eye size={20} /> : <EyeOff size={20} />}
                    </button>
                  </div>

                </div>

                <Button
                  type="submit"
                  className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
                  disabled={isLoading}
                >
                  {isLoading ? "Signing in..." : "Sign in"}
                </Button>
              </form>
            </CardContent>
            <CardFooter className="flex justify-center">
              <p className="text-sm text-slate-400">
                Don't have an account?
                <Link
                  to="/signup"
                  className="text-emerald-400 hover:text-emerald-300"
                >
                  Sign up
                </Link>
              </p>
            </CardFooter>
          </Card>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/nehahelp.jsx
================
import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import EmojiPicker from "emoji-picker-react";
import {
  ArrowLeft,
  LogOut,
  Menu,
  MessageSquare,
  MoreVertical,
  Plus,
  Search,
  Send,
  Settings,
  User,
} from "lucide-react";
import { Link, useNavigate } from "react-router-dom";
import { AnimatePresence } from "framer-motion";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useMobile } from "../hooks/use-mobile";
import { supabase } from "../lib/supabaseClient";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import NewChatModal from "../components/NewChatModal";
import { post } from "../lib/backend"; // <-- Import post helper
import { db } from "../lib/db"; // <-- Import Dexie db instance

export default function ChatPage() {
  console.log("--- ChatPage Component Rendering ---");
  // --- State Variables ---
  const [currentUser, setCurrentUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [conversations, setConversations] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [loadingConversations, setLoadingConversations] = useState(true);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [error, setError] = useState(null);
  const [messageSubscription, setMessageSubscription] = useState(null);
  const [isNewChatModalOpen, setIsNewChatModalOpen] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const fileInputRef = useRef();

  const isMobile = useMobile();
  const navigate = useNavigate();
  const messagesEndRef = useRef(null);

  // --- Helper Functions ---
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // Format Supabase message to UI structure
  const formatMessage = (msg) => {
    if (!msg || !msg.profiles) {
      console.warn("Attempted to format invalid message:", msg);
      return null; // Or return a default structure
    }
    const senderProfile = msg.profiles;
    const timestamp = msg.created_at
      ? new Date(msg.created_at).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        })
      : "";
    return {
      id: msg.id,
      senderId: senderProfile.id, // Keep sender ID
      senderName:
        senderProfile.full_name || senderProfile.username || "Unknown User",
      senderAvatar: senderProfile.avatar_url,
      content: msg.content,
      timestamp: timestamp,
      isSelf: senderProfile.id === currentUser?.id,
      isEncrypted: msg.is_encrypted, // Pass flag for potential UI indicators
      originalCiphertextType: msg.encryption_header?.type, // Pass original type if needed
    };
  };

  // --- Effects ---

  // 1. Get current user and profile
  useEffect(() => {
    const fetchUserAndProfile = async () => {
      console.log("[Effect 1] Running fetchUserAndProfile...");
      setLoadingConversations(true); // Keep loading conversations true initially

      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession();
      console.log("[Effect 1] Session data:", session);
      console.error("[Effect 1] Session error:", sessionError);

      if (sessionError) {
        console.error("Error getting session:", sessionError);
        setError("Failed to load user session.");
        setLoadingConversations(false);
        return;
      }

      if (!session?.user) {
        console.log("No user session found, redirecting to login.");
        navigate("/login");
        return;
      }

      console.log("[Effect 1] User found:", session.user);
      setCurrentUser(session.user);

      // Fetch profile details
      console.log("[Effect 1] Fetching profile for user ID:", session.user.id);
      const { data: profileData, error: profileError } = await supabase
        .from("profiles")
        .select("id, username, full_name, avatar_url, status") // Select id as well
        .eq("id", session.user.id)
        .single();

      console.log("[Effect 1] Profile fetch result:", {
        profileData,
        profileError,
      });

      if (profileError && profileError.code !== "PGRST116") {
        // PGRST116: Row not found, might be acceptable if profile creation is separate
        console.error("Error fetching profile:", profileError);
        setError(`Failed to load user profile: ${profileError.message}`);
        // Don't set profile, let subsequent effects handle null profile
      } else if (!profileData) {
        console.warn("[Effect 1] Profile not found for user:", session.user.id);
        setError("User profile not found. Please complete profile setup."); // More specific error
        // Don't set profile
      } else {
        console.log("[Effect 1] Setting profile state:", profileData);
        setProfile(profileData); // Set profile state successfully
        setError(null); // Clear any previous errors if profile loads
      }
      // setLoadingConversations(false); // Keep loading true until conversations are attempted
    };

    fetchUserAndProfile();
  }, [navigate]);

  // 2. Fetch conversations once user profile is loaded
  useEffect(() => {
    console.log("[Effect 2] Checking profile state:", profile);
    if (!profile?.id) {
      console.log(
        "[Effect 2] No profile ID found, skipping conversation fetch."
      );
      // If profile loading previously failed, we need to stop the main loading indicator
      if (!loadingConversations && !profile) {
        setLoadingConversations(false); // Ensure loading stops if profile never loads
      }
      return;
    }
    const fetchConversations = async () => {
      setLoadingConversations(true);
      console.log("Fetching conversations for profile:", profile.id);
      try {
        // Fetch conversation IDs the user is part of
        const { data: participantData, error: participantError } =
          await supabase
            .from("conversation_participants")
            .select("conversation_id")
            .eq("profile_id", profile.id);

        if (participantError) throw participantError;

        const conversationIds = participantData.map((p) => p.conversation_id);

        if (conversationIds.length === 0) {
          setConversations([]);
          setLoadingConversations(false);
          return;
        }

        // Fetch details for these conversations and their participants
        // This query is more complex: get conversation, its participants, and their profiles
        // Adjust based on performance needs (might need separate queries or a DB function)
        const { data: convData, error: convError } = await supabase
          .from("conversations")
          .select(
            `
            id,
            created_at,
            conversation_participants(
              profile_id,
              profiles(id, username, full_name, avatar_url, status)
            )
          `
          )
          .in("id", conversationIds);

        if (convError) throw convError;

        console.log("Fetched raw conversation data:", convData);
        const formattedConversations = convData.map((conv) => {
          const participants = conv.conversation_participants.map(
            (p) => p.profiles
          );
          // Find the other participant(s) for naming/avatar
          const otherParticipant =
            participants.find((p) => p.id !== profile.id) || participants[0];
          const name =
            otherParticipant?.full_name ||
            otherParticipant?.username ||
            "Unknown User";
          const avatar = otherParticipant?.avatar_url;
          // TODO: Fetch last message and time (requires another query or denormalization)
          return {
            id: conv.id,
            name: name,
            lastMessage: "...",
            time: "",
            unread: 0,
            avatar: avatar,
            participants: participants,
          };
        });
        console.log("Formatted conversations:", formattedConversations);

        setConversations(formattedConversations);
        if (!selectedConversation && formattedConversations.length > 0) {
          console.log(
            "Setting selected conversation to first one:",
            formattedConversations[0]
          );
          setSelectedConversation(formattedConversations[0]);
        } else if (formattedConversations.length === 0) {
          console.log("No conversations found for this user.");
          setSelectedConversation(null); // Ensure it's null if none found
        }
      } catch (fetchError) {
        console.error("Error fetching conversations:", fetchError);
        setError("Failed to load conversations.");
      } finally {
        console.log(
          "Finished fetching conversations, setting loadingConversations to false."
        );
        setLoadingConversations(false);
      }
    };

    fetchConversations();
  }, [profile?.id]); // Removed selectedConversation dependency for clarity

  // 3. Fetch messages when selectedConversation changes - UPDATED FOR INDEXEDDB + Rehydration
  useEffect(() => {
    if (!selectedConversation?.id || !currentUser?.id) {
      setMessages([]); // Clear messages if no conversation selected
      return;
    }

    let isMounted = true; // Flag to prevent state updates on unmounted component
    setLoadingMessages(true);
    setError(null);
    console.log(
      `[Effect 3 - Combined] Loading messages for convo ${selectedConversation.id}`
    );

    // Helper to format messages loaded from IndexedDB
    const formatLocalMessage = (localMsg) => ({
      id: localMsg.id,
      senderId: localMsg.senderId,
      senderName: localMsg.senderName,
      senderAvatar: localMsg.senderAvatar,
      content: localMsg.content, // Content is already plaintext
      timestamp: new Date(localMsg.timestamp).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }), // Format timestamp for display
      isSelf: localMsg.senderId === currentUser.id, // Re-calculate isSelf based on current user
    });

    const loadAndRehydrateMessages = async () => {
      try {
        // --- Step 1: Load existing messages from IndexedDB ---
        let localMessages = await db.messages
          .where("conversationId")
          .equals(selectedConversation.id)
          .toArray();

        // Purge any that are empty *or* the initial-session placeholder
        localMessages = await Promise.all(
          localMessages.map(async (m) => {
            const shouldPurge =
              !m.content.trim() || m.content === "(initial session packet)";
            if (shouldPurge) {
              await db.messages.delete(m.id);
              console.log(`Purged message ${m.id} from IndexedDB`);
              return null;
            }
            return m;
          })
        ).then((arr) => arr.filter(Boolean));

        // Sort by timestamp
        localMessages.sort(
          (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
        );

        if (!isMounted) return;

        console.log(
          `[Effect 3 - DB] Using ${localMessages.length} clean messages locally.`
        );
        setMessages(localMessages.map(formatLocalMessage));

        // --- Step 2: Fetch ALL messages from Supabase to find missing ones ---
        console.log(
          `[Effect 3 - Supa] Fetching all messages from Supabase for potential rehydration.`
        );
        const { data: supabaseMessages, error: messagesError } = await supabase
          .from("messages")
          .select(
            `
            id,
            conversation_id,
            content,
            created_at,
            profile_id,
            is_encrypted,
            encryption_header,
            profiles ( id, full_name, username, avatar_url )
          `
          )
          .eq("conversation_id", selectedConversation.id)
          .order("created_at", { ascending: true });

        if (messagesError) throw messagesError;
        if (!isMounted) return;

        console.log(
          `[Effect 3 - Supa] Fetched ${supabaseMessages.length} raw messages from Supabase.`
        );

        // --- Step 3: Identify and decrypt messages NOT already in IndexedDB ---
        const localIds = new Set(localMessages.map((m) => m.id));
        const messagesToProcess = supabaseMessages.filter(
          (supaMsg) =>
            supaMsg.profile_id !== currentUser.id && // from someone else
            !localIds.has(supaMsg.id) // not already stored
        );

        console.log(
          `[Effect 3 - Decrypt] Found ${messagesToProcess.length} missing/undecrypted messages.`
        );

        if (messagesToProcess.length === 0) {
          console.log("No messages to process.");
          return;
        }

        if (messagesToProcess.length > 0) {
          for (const msg of messagesToProcess) {
            let plaintext = msg.content;

            // *only* decrypt if it's still marked encrypted
            if (msg.is_encrypted) {
              try {
                const { plaintext: p } = await post("/api/messages/decrypt", {
                  recipient_id: currentUser.id,
                  sender_id: msg.profile_id,
                  header_b64: msg.encryption_header,
                  ciphertext_b64: msg.content,
                });
                plaintext = p;
              } catch (err) {
                console.warn(`Failed to decrypt ${msg.id}, skipping:`, err);
                continue; // or set plaintext = "[decryption error]" if you prefer
              }
            }
            if (!plaintext.trim()) {
              console.log(`Skipping empty/handshake message ${msg.id}`);
              continue;
            }
            const toStore = {
              id: msg.id,
              conversationId: msg.conversation_id,
              senderId: msg.profile_id,
              senderName:
                msg.profiles?.full_name || msg.profiles?.username || "Unknown",
              senderAvatar: msg.profiles?.avatar_url,
              content: plaintext,
              timestamp: new Date(msg.created_at).toISOString(),
            };

            await db.messages.put(toStore);

            if (!isMounted) break;

            setMessages((prev) => {
              const formatted = {
                id: toStore.id,
                senderId: toStore.senderId,
                senderName: toStore.senderName,
                senderAvatar: toStore.senderAvatar,
                content: toStore.content,
                timestamp: new Date(toStore.timestamp).toLocaleTimeString([], {
                  hour: "2-digit",
                  minute: "2-digit",
                }),
                isSelf: toStore.senderId === currentUser.id,
              };
              return [...prev, formatted].sort(
                (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
              );
            });
          }
        }
      } catch (err) {
        console.error("[Effect 3] Error loading messages:", err);
        if (isMounted) setError("Failed to load messages.");
      } finally {
        if (isMounted) {
          setLoadingMessages(false);
          console.log("[Effect 3] Finished loading messages.");
        }
      }
    };

    loadAndRehydrateMessages();

    // Cleanup function
    return () => {
      isMounted = false;
      console.log("[Effect 3 - Combined] Unmounting/cleanup.");
    };

    // Dependency array: Fetch when conversation or user changes
  }, [selectedConversation?.id, currentUser?.id]);

  // 4. Scroll to bottom when messages change
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // 5. Realtime subscription for new messages
  useEffect(() => {
    if (!selectedConversation?.id || !currentUser?.id) {
      // If no conversation selected, remove any existing subscription
      if (messageSubscription) {
        supabase.removeChannel(messageSubscription);
        setMessageSubscription(null);
      }
      return;
    }

    // Create a new channel for the selected conversation
    const channel = supabase
      .channel(`messages:${selectedConversation.id}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
          filter: `conversation_id=eq.${selectedConversation.id}`, // Filter for current conversation
        },
        // Modified handler to include decryption
        async (payload) => {
          console.log("[Realtime] handleNewMessage triggered:", payload);

          const newMessageData = payload.new;

          // --- BEGIN FIX: Ignore own messages from realtime insert ---
          if (newMessageData.profile_id === currentUser.id) {
            console.log(
              "[Realtime] Ignoring own message insert notification (already handled by local echo)."
            );
            return;
          }
          // --- END FIX ---

          // Check if it belongs to the current conversation (extra safety)
          if (newMessageData.conversation_id !== selectedConversation.id) {
            console.log(
              "[Realtime] Message is for a different conversation, skipping."
            );
            return;
          }

          // Avoid adding duplicates if message already exists (e.g., from initial fetch)
          if (messages.some((msg) => msg.id === newMessageData.id)) {
            console.log("[Realtime] Duplicate message detected, skipping.");
            return;
          }

          // Fetch sender profile for the new message
          const { data: senderProfile, error: profileError } = await supabase
            .from("profiles")
            .select("id, full_name, username, avatar_url")
            .eq("id", newMessageData.profile_id)
            .single();

          if (profileError) {
            console.error(
              "[Realtime] Error fetching profile for new message:",
              profileError
            );
            return;
          }
          console.log("[Realtime] Fetched sender profile:", senderProfile);

          let contentToFormat = { ...newMessageData, profiles: senderProfile };

          // Check if message is encrypted and needs decryption
          if (
            newMessageData.is_encrypted &&
            newMessageData.profile_id !== currentUser.id
            // Removed check for content/header here, rely on is_encrypted
          ) {
            console.log(
              `[Realtime] Encrypted message ${newMessageData.id} received, needs decryption.`
            );
            try {
              console.log(
                `[Realtime] Calling backend decrypt for msg ${newMessageData.id}...`
              );
              // Use post helper for decryption
              const decryptResult = await post("/api/messages/decrypt", {
                recipient_id: currentUser.id,
                sender_id: newMessageData.profile_id,
                header_b64: newMessageData.encryption_header,
                ciphertext_b64: newMessageData.content,
              });

              // Only need plaintext now, already_decrypted check happens via !localIds.has()
              const { plaintext } = decryptResult;

              console.log(
                `[Realtime] Decryption successful for msg ${newMessageData.id}.`
              );

              // Update contentToFormat with decrypted data
              contentToFormat.content = plaintext;
              contentToFormat.is_encrypted = false; // Mark as plaintext for formatting
              contentToFormat.encryption_header = null; // Conceptually nullify header
            } catch (decryptionError) {
              console.error(
                `[Realtime] Error during decryption call for msg ${newMessageData.id}:`,
                decryptionError
              );
              contentToFormat.content = "[Decryption Error]"; // Update content to show error
              contentToFormat.is_encrypted = true; // Keep flag true as decryption failed
            }
          } else {
            // Message is plaintext or self-sent
            console.log(
              `[Realtime] Message ${newMessageData.id} is plaintext or self-sent.`
            );
            // Ensure contentToFormat reflects this if necessary (it should already have the correct content/flags from payload)
          }

          // *** NEW: skip both empty and handshake packets ***
          if (
            !contentToFormat.content.trim() ||
            contentToFormat.content === "(initial session packet)"
          ) {
            console.log(
              `Skipping realtime handshake/empty msg ${newMessageData.id}`
            );
            return;
          }

          // Format the message for the UI (using potentially decrypted content)
          const formatted = formatMessage(contentToFormat);
          if (formatted) {
            const toStore = {
              id: contentToFormat.id,
              conversationId: contentToFormat.conversation_id,
              senderId: contentToFormat.profile_id,
              senderName: senderProfile.full_name || senderProfile.username,
              senderAvatar: senderProfile.avatar_url,
              content: contentToFormat.content,
              timestamp: new Date(payload.new.created_at).toISOString(),
            };
            try {
              await db.messages.put(toStore);
            } catch (err) {
              console.error("Failed to persist incoming msg:", err);
            }
            console.log(
              "[Realtime] Adding formatted message to state:",
              formatted
            );
            setMessages((prevMessages) => [...prevMessages, formatted]);
          } else {
            console.warn(
              "[Realtime] Failed to format message payload:",
              payload.new
            );
          }
        }
      )
      .subscribe((status, err) => {
        if (status === "SUBSCRIBED") {
          console.log(
            `Subscribed to messages for conversation ${selectedConversation.id}`
          );
        } else if (status === "CHANNEL_ERROR") {
          console.error("Realtime channel error:", err);
          setError("Realtime connection error. Please refresh.");
        } else if (status === "TIMED_OUT") {
          console.warn("Realtime connection timed out.");
        }
      });

    setMessageSubscription(channel); // Store the channel

    // Cleanup function: Remove the channel subscription when conversation changes or component unmounts
    return () => {
      if (channel) {
        console.log(
          `Unsubscribing from messages for conversation ${selectedConversation.id}`
        );
        supabase.removeChannel(channel);
        setMessageSubscription(null);
      }
    };
  }, [selectedConversation?.id, currentUser?.id]); // Re-subscribe ONLY if conversation or user changes

  // Filter conversations based on search query
  const filteredConversations = conversations.filter((conv) =>
    conv.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleSendMessage = async () => {
    if (!newMessage.trim() || !selectedConversation || !profile?.id) return;

    const recipientProfile = selectedConversation.participants.find(
      (p) => p.id !== profile.id
    );

    if (!recipientProfile) {
      console.error(
        "Could not find recipient profile in selected conversation."
      );
      setError("Error sending message: Recipient not found.");
      return;
    }

    const recipientId = recipientProfile.id;
    const plaintextMessage = newMessage.trim();
    setNewMessage(""); // Clear input immediately
    console.log(`[SendMessage] Preparing to encrypt: "${plaintextMessage}"`);
    let insertedMessages = null; // Declare insertedMessages here

    try {
      // --- Step 0: Ensure Session is Initiated ---
      console.log(
        `[SendMessage] Ensuring session initiated for ${profile.id} -> ${recipientId}...`
      );
      // Use post helper to initiate session
      const initiateResult = await post("/api/sessions/initiate", {
        sender_id: profile.id,
        recipient_id: recipientId,
      });

      console.log(
        "[SendMessage] Session initiation check completed:",
        initiateResult.message // Use message from post result
      );
      // Step 0b: If there's an initial handshake packet, store it
      if (initiateResult.initial_packet_header_b64) {
        console.log("[SendMessage] Storing handshake packet…");
        const { error: hsError } = await supabase.from("messages").insert({
          conversation_id: selectedConversation.id,
          profile_id: profile.id,
          content: initiateResult.initial_packet_ciphertext_b64,
          is_encrypted: true,
          encryption_header: initiateResult.initial_packet_header_b64,
        });
        if (hsError) {
          console.error("Failed to store handshake packet:", hsError);
          throw new Error("Handshake storage failed");
        }
        console.log("[SendMessage] Handshake packet stored.");
      }
      // --- Step 1: Call Backend Encryption API ---
      console.log(
        `[SendMessage] Calling backend encrypt for recipient ${recipientId}...`
      );
      // Use post helper to encrypt
      const { header_b64, ciphertext_b64 } = await post(
        "/api/messages/encrypt",
        {
          sender_id: profile.id,
          recipient_id: recipientId,
          plaintext: plaintextMessage,
        }
      );

      console.log(
        `[SendMessage] Encryption successful. Header and Ciphertext received.`
      );

      // --- Step 2: Store Encrypted Message in Supabase ---
      console.log(`[SendMessage] Storing encrypted message to Supabase...`);
      const { data: supabaseData, error: insertError } = await supabase
        .from("messages")
        .insert({
          conversation_id: selectedConversation.id,
          profile_id: profile.id,
          content: ciphertext_b64,
          is_encrypted: true,
          encryption_header: header_b64,
        })
        .select("id") // Select the ID of the inserted row
        .single(); // Expecting a single row back

      if (insertError) {
        console.error(
          "[SendMessage] Error inserting message into Supabase:",
          insertError
        );
        throw new Error(
          `Database Error: ${insertError.message || "Failed to save message"}`
        );
      }
      insertedMessages = supabaseData; // Assign to the outer scoped variable
    } catch (err) {
      console.error("[SendMessage] Error encrypting or saving message:", err);
      setError(`Error sending message: ${err.message}`);
      return; // bail out—don't try to send files or update UI
    }

    // now you're outside the first try/catch, safe to do file‐attachment and optimistic UI
    if (
      !selectedConversation ||
      !currentUser ||
      (!newMessage.trim() && !selectedFile)
    )
      return;

    const conversationId = selectedConversation.id;
    const profileId = currentUser.id;

    try {
      if (newMessage.trim()) {
        await supabase.from("messages").insert({
          conversation_id: conversationId,
          profile_id: profileId,
          content: newMessage.trim(),
        });
      }

      if (selectedFile) {
        await supabase.from("messages").insert({
          conversation_id: conversationId,
          profile_id: profileId,
          content: `[File] ${selectedFile.name}`,
        });
      }

      console.log("[SendMessage] Message stored successfully in Supabase.");

      // --- Step 3: Store Plaintext Locally in IndexedDB ---
      if (!insertedMessages?.id) {
        console.error(
          "[SendMessage] Failed to get ID of inserted message from Supabase. Cannot store locally."
        );
      } else {
        const messageId = insertedMessages.id;
        const messageForDb = {
          id: messageId, // Use the REAL ID from Supabase
          conversationId: selectedConversation.id,
          senderId: profile.id,
          senderName: profile.full_name || profile.username,
          senderAvatar: profile.avatar_url,
          content: plaintextMessage, // Store PLAINTEXT
          timestamp: new Date().toISOString(), // Store ISO string for consistent sorting
        };
        try {
          await db.messages.put(messageForDb);
          console.log(
            `[SendMessage] Stored outgoing plaintext message locally with ID: ${messageId}`
          );
        } catch (dbError) {
          console.error(
            "[SendMessage] Error storing outgoing message locally in IndexedDB:",
            dbError
          );
          // Consider how to handle this failure - the message IS sent.
        }
      }

      // --- Step 4: Optimistic UI Update ---
      // Keep this for immediate feedback. Reloads will use the data stored in DB.
      setMessages((prev) => [
        ...prev,
        {
          id: crypto.randomUUID(), // Use a temporary ID for the optimistic UI update
          senderId: profile.id,
          senderName: profile.full_name || profile.username,
          senderAvatar: profile.avatar_url,
          content: plaintextMessage, // <-- clear-text
          timestamp: new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }),
          isSelf: true,
          isEncrypted: false, // UI shows plaintext
        },
      ]);
    } catch (err) {
      console.error("[SendMessage] Error during message sending process:", err);
      setError(`Error sending message: ${err.message}`);
      // Restore the input field content if sending fails?
      setNewMessage(plaintextMessage); // Put message back on error
    } finally {
      // setLoadingMessages(false); // Maybe not needed here as insert is quick?
    }

    setNewMessage("");
    setSelectedFile(null);
  };

  const handleFileSelect = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const maxSizeMB = 10;
    if (file.size > maxSizeMB * 1024 * 1024) {
      alert(`File size exceeds ${maxSizeMB}MB limit.`);
      return;
    }

    setSelectedFile(file);
  };

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error("Error logging out:", error);
    } else {
      navigate("/login");
    }
  };

  const handleUserSelect = async (selectedUser) => {
    console.log("Selected user to start chat with:", selectedUser);
    if (!currentUser || !profile) {
      console.error("Current user or profile not loaded.");
      return;
    }
    if (selectedUser.id === currentUser.id) {
      console.warn("Cannot start chat with self.");
      return;
    }

    setIsNewChatModalOpen(false); // Close modal immediately

    try {
      // 1. Check if a conversation already exists
      const existingConversation = conversations.find((conv) => {
        // Check if participants array exists and has exactly 2 participants (for 1-on-1 chat)
        // Adjust this logic if group chats need different handling
        if (!conv.participants || conv.participants.length !== 2) return false;
        // Check if both currentUser and selectedUser are participants
        const hasCurrentUser = conv.participants.some(
          (p) => p.id === currentUser.id
        );
        const hasSelectedUser = conv.participants.some(
          (p) => p.id === selectedUser.id
        );
        return hasCurrentUser && hasSelectedUser;
      });

      if (existingConversation) {
        console.log("Found existing conversation:", existingConversation);
        setSelectedConversation(existingConversation);
      } else {
        console.log("No existing conversation found, creating new one...");
        // 2. Create New Conversation
        const { data: newConvData, error: convInsertError } = await supabase
          .from("conversations")
          .insert({})
          .select()
          .single();

        if (convInsertError) throw convInsertError;
        const newConversationId = newConvData.id;
        console.log("Created new conversation with ID:", newConversationId);

        // 3. Add Participants
        const { error: participantInsertError } = await supabase
          .from("conversation_participants")
          .insert([
            { conversation_id: newConversationId, profile_id: currentUser.id },
            { conversation_id: newConversationId, profile_id: selectedUser.id },
          ]);

        if (participantInsertError) throw participantInsertError;
        console.log("Added participants to new conversation.");

        // 4. Construct new conversation object for UI state
        const newConversationForState = {
          id: newConversationId,
          name: selectedUser.full_name || selectedUser.username, // Use selected user's name for 1-on-1
          lastMessage: "", // No messages yet
          time: "",
          unread: 0,
          avatar: selectedUser.avatar_url, // Use selected user's avatar
          participants: [
            {
              // Current user's profile
              id: profile.id,
              username: profile.username,
              full_name: profile.full_name,
              avatar_url: profile.avatar_url,
              status: profile.status,
            },
            {
              // Selected user's profile (from modal data)
              id: selectedUser.id,
              username: selectedUser.username,
              full_name: selectedUser.full_name,
              avatar_url: selectedUser.avatar_url,
              status: "offline", // Assume offline initially, status updates needed separately
            },
          ],
        };

        // 5. Update State
        setConversations((prev) => [newConversationForState, ...prev]); // Add to beginning
        setSelectedConversation(newConversationForState);
        console.log(
          "Set new conversation as selected:",
          newConversationForState
        );
      }
    } catch (err) {
      console.error("Error starting chat:", err);
      setError("Failed to start chat. " + err.message);
    }
  };

  if (loadingConversations && !profile) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-white">
        Loading...
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900 text-red-400">
        Error: {error}
      </div>
    );
  }

  return (
    <div className="flex h-screen bg-slate-900">
      {/* Sidebar - Chat List */}
      {!isMobile || isMobileMenuOpen ? (
        <AnimatePresence>
          <div
            className={`${
              isMobile ? "absolute z-10 w-full max-w-xs" : "w-80"
            } h-full bg-slate-800 border-r border-slate-700 flex flex-col`}
          >
            {/* Header */}
            <div className="p-4 border-b border-slate-700 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <MessageSquare className="h-5 w-5 text-emerald-400" />
                <h1 className="font-bold text-white">Messages</h1>
              </div>
              <div className="flex gap-2">
                <Dialog
                  open={isNewChatModalOpen}
                  onOpenChange={setIsNewChatModalOpen}
                >
                  <DialogTrigger asChild>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="text-slate-400 hover:text-white"
                    >
                      <Plus className="h-5 w-5" />
                    </Button>
                  </DialogTrigger>
                  <NewChatModal
                    currentUser={currentUser}
                    onUserSelect={handleUserSelect}
                  />
                </Dialog>
                {isMobile && (
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                    onClick={() => setIsMobileMenuOpen(false)}
                  >
                    <ArrowLeft className="h-5 w-5" />
                  </Button>
                )}
              </div>
            </div>

            {/* Search */}
            <div className="p-4 border-b border-slate-700">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                <Input
                  placeholder="Search conversations..."
                  className="pl-9 bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
            </div>

            {/* Chat List Area */}
            <ScrollArea className="flex-1">
              <div className="p-2">
                {filteredConversations.map((conv) => (
                  <div
                    key={conv.id}
                    className={`p-3 rounded-lg cursor-pointer mb-1 hover:bg-slate-700/50 ${
                      selectedConversation?.id === conv.id ? "bg-slate-700" : ""
                    }`}
                    onClick={() => {
                      setSelectedConversation(conv);
                      if (isMobile) setIsMobileMenuOpen(false);
                    }}
                  >
                    <div className="flex items-center gap-3">
                      <Avatar>
                        <AvatarImage
                          src={conv.avatar || "/placeholder.svg"}
                          alt={conv.name}
                        />
                        <AvatarFallback className="bg-emerald-500 text-white">
                          {conv.name
                            ?.split(" ")
                            .map((n) => n[0])
                            .join("") || "??"}
                        </AvatarFallback>
                      </Avatar>
                      <div className="flex-1 min-w-0">
                        <div className="flex justify-between items-center">
                          <h3 className="font-medium text-white truncate">
                            {conv.name}
                          </h3>
                          <span className="text-xs text-slate-400">
                            {conv.time}
                          </span>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-sm text-slate-400 truncate">
                            {conv.lastMessage}
                          </p>
                          {conv.unread > 0 && (
                            <span className="bg-emerald-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                              {conv.unread}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>

            {/* Footer Profile Section */}
            <div className="p-4 border-t border-slate-700 flex items-center justify-between">
              <Link to="/profile" className="flex items-center gap-3">
                <Avatar>
                  <AvatarImage
                    src={
                      profile?.avatar_url ||
                      "/placeholder.svg?height=40&width=40"
                    }
                    alt="Your Avatar"
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {(profile?.full_name || profile?.username || "??")
                      .split(" ")
                      .map((n) => n[0])
                      .join("")}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="font-medium text-white">
                    {profile?.full_name || profile?.username || "Loading..."}
                  </p>
                  <p className="text-xs text-slate-400">
                    {profile?.status || "Offline"}
                  </p>
                </div>
              </Link>
              <div className="flex gap-1">
                <Link to="/settings">
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-slate-400 hover:text-white"
                  >
                    <Settings className="h-5 w-5" />
                  </Button>
                </Link>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-slate-400 hover:text-white"
                  onClick={handleLogout}
                >
                  <LogOut className="h-5 w-5" />
                </Button>
              </div>
            </div>
          </div>
        </AnimatePresence>
      ) : null}

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col h-full">
        {/* Chat Header */}
        <div className="p-4 border-b border-slate-700 flex items-center justify-between bg-slate-800">
          <div className="flex items-center gap-3">
            {isMobile && (
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white"
                onClick={() => setIsMobileMenuOpen(true)}
              >
                <Menu className="h-5 w-5" />
              </Button>
            )}

            {selectedConversation && (
              <>
                <Avatar>
                  <AvatarImage
                    src={selectedConversation.avatar || "/placeholder.svg"}
                    alt={selectedConversation.name}
                  />
                  <AvatarFallback className="bg-emerald-500 text-white">
                    {selectedConversation.name
                      ?.split(" ")
                      .map((n) => n[0])
                      .join("") || "??"}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <h2 className="font-medium text-white">
                    {selectedConversation.name}
                  </h2>
                  <p className="text-xs text-slate-400">Online</p>
                </div>
              </>
            )}
            {!selectedConversation && !loadingConversations && (
              <div className="text-slate-400">
                Select a conversation to start chatting
              </div>
            )}
          </div>

          {/* More Options Sheet */}
          <Sheet>
            <SheetTrigger asChild disabled={!selectedConversation}>
              <Button
                variant="ghost"
                size="icon"
                className="text-slate-400 hover:text-white disabled:opacity-50"
              >
                <MoreVertical className="h-5 w-5" />
              </Button>
            </SheetTrigger>
            <SheetContent className="bg-slate-800 border-slate-700 text-white">
              <div className="space-y-4 py-4">
                <div className="flex flex-col items-center gap-2 pb-4 border-b border-slate-700">
                  <Avatar className="h-20 w-20">
                    <AvatarImage
                      src={selectedConversation?.avatar || "/placeholder.svg"}
                      alt={selectedConversation?.name}
                    />
                    <AvatarFallback className="bg-emerald-500 text-white text-xl">
                      {selectedConversation?.name
                        ?.split(" ")
                        .map((n) => n[0])
                        .join("") || "??"}
                    </AvatarFallback>
                  </Avatar>
                  <h3 className="text-xl font-bold">
                    {selectedConversation?.name}
                  </h3>
                  <p className="text-sm text-slate-400">Online</p>
                </div>

                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-slate-400">
                    Options
                  </h4>
                  <div className="space-y-1">
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-white"
                    >
                      <User className="mr-2 h-4 w-4" />
                      View Profile
                    </Button>
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-white"
                    >
                      <MessageSquare className="mr-2 h-4 w-4" />
                      Search in Conversation
                    </Button>
                    <Button
                      variant="ghost"
                      className="w-full justify-start text-red-400 hover:text-red-300 hover:bg-red-900/20"
                    >
                      <LogOut className="mr-2 h-4 w-4" />
                      Delete Conversation
                    </Button>
                  </div>
                </div>
              </div>
            </SheetContent>
          </Sheet>
        </div>

        {/* Messages Area */}
        <ScrollArea className="flex-1 p-4 bg-gradient-to-b from-slate-900 to-slate-800">
          <div className="space-y-4">
            {loadingMessages && (
              <div className="text-center text-slate-400 py-4">
                Loading messages...
              </div>
            )}
            {!loadingMessages &&
              messages.map((message) => (
                <div
                  key={message.id}
                  className={`flex ${
                    message.isSelf ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] ${
                      message.isSelf ? "order-2" : "order-1"
                    }`}
                  >
                    {!message.isSelf && (
                      <div className="flex items-center gap-2 mb-1">
                        <Avatar className="h-6 w-6">
                          <AvatarImage
                            src={message.senderAvatar || "/placeholder.svg"}
                            alt={message.senderName}
                          />
                          <AvatarFallback className="bg-emerald-500 text-white text-xs">
                            {message.senderName
                              ?.split(" ")
                              .map((n) => n[0])
                              .join("") || "??"}
                          </AvatarFallback>
                        </Avatar>
                        <span className="text-xs text-slate-400">
                          {message.senderName}
                        </span>
                      </div>
                    )}
                    <div
                      className={`rounded-lg p-3 ${
                        message.isSelf
                          ? "bg-emerald-500 text-white rounded-tr-none"
                          : "bg-slate-700 text-white rounded-tl-none"
                      }`}
                    >
                      <p>
                        {message.content.startsWith("[File](") ? (
                          // Format: [File](url) filename
                          (() => {
                            const match = message.content.match(
                              /\[File\]\((.*?)\)\s*(.*)/
                            );
                            const url = match?.[1];
                            const name = match?.[2] || "Download File";
                            return (
                              <a
                                href={url}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="underline text-blue-400"
                              >
                                📎 {name}
                              </a>
                            );
                          })()
                        ) : message.content.startsWith("[File] ") ? (
                          // Format: [File] filename (no URL yet — fallback)
                          <span className="text-slate-300">
                            📎 {message.content.slice(7)}
                          </span>
                        ) : (
                          message.content
                        )}
                      </p>
                    </div>
                    <p className="text-xs text-slate-400 mt-1 ${message.isSelf ? 'text-left' : 'text-right'}">
                      {message.timestamp}
                    </p>
                  </div>
                </div>
              ))}
            {!loadingMessages &&
              messages.length === 0 &&
              selectedConversation && (
                <div className="text-center text-slate-500 pt-10">
                  No messages yet. Start the conversation!
                </div>
              )}
            <div ref={messagesEndRef} />
          </div>
          {!selectedConversation && !loadingConversations && (
            <div className="text-center text-slate-500 pt-10">
              Select a conversation to view messages.
            </div>
          )}
        </ScrollArea>

        {/* Message Input */}
        <div className="p-4 border-t border-slate-700 bg-slate-800 relative">
          <form
            onSubmit={(e) => {
              e.preventDefault();
              handleSendMessage();
            }}
            className="flex items-center gap-2"
          >
            <Button
              type="button"
              variant="ghost"
              className="text-slate-400 hover:text-white"
              onClick={() => fileInputRef.current.click()}
            >
              📎
            </Button>

            <input
              type="file"
              ref={fileInputRef}
              style={{ display: "none" }}
              onChange={handleFileSelect}
            />

            <Input
              placeholder="Type a message..."
              className="bg-slate-700 border-slate-600 text-slate-200 placeholder:text-slate-400"
              value={newMessage}
              onChange={(e) => {
                console.log("Input Disabled Status:", {
                  hasSelected: !!selectedConversation,
                  isLoading: loadingConversations,
                });
                setNewMessage(e.target.value);
              }}
              disabled={!selectedConversation || loadingConversations}
            />
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={() => setShowEmojiPicker((prev) => !prev)}
            >
              😀
            </Button>
            <Button
              type="submit"
              size="icon"
              className="bg-emerald-500 hover:bg-emerald-600 text-white"
              disabled={
                (!newMessage.trim() && !selectedFile) ||
                !selectedConversation ||
                loadingConversations
              }
            >
              <Send className="h-5 w-5" />
            </Button>
          </form>
          {/* --- Emoji Picker Feature --- */}
          {showEmojiPicker && (
            <div className="absolute bottom-24 right-8 z-50">
              <EmojiPicker
                onEmojiClick={(emojiData) => {
                  setNewMessage((prev) => prev + emojiData.emoji);
                }}
              />
            </div>
          )}

          {selectedFile && (
            <div className="text-slate-400 text-xs mt-2 ml-2">
              Attached: {selectedFile.name}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/pages/ProfilePage.jsx
================
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ArrowLeft, Camera } from "lucide-react";
import { motion } from "framer-motion";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Switch } from "@/components/ui/switch";

export default function ProfilePage() {
  const [name, setName] = useState("Your Name");
  const [email, setEmail] = useState("your.email@example.com");
  const [bio, setBio] = useState(
    "I'm a software developer interested in secure communications and privacy."
  );
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  const handleSave = async () => {
    setIsSaving(true);

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));

    setIsEditing(false);
    setIsSaving(false);
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/chat"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Chat
        </Link>
      </header>

      <main className="flex-1 container mx-auto px-4 py-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="max-w-2xl mx-auto"
        >
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="pb-4">
              <div className="flex flex-col sm:flex-row items-center gap-4 sm:gap-6">
                <div className="relative">
                  <Avatar className="h-24 w-24">
                    <AvatarImage
                      src="/placeholder.svg?height=96&width=96"
                      alt="Your Avatar"
                    />
                    <AvatarFallback className="bg-emerald-500 text-white text-2xl">
                      {name
                        .split(" ")
                        .map((n) => n[0])
                        .join("")}
                    </AvatarFallback>
                  </Avatar>
                  <Button
                    size="icon"
                    className="absolute bottom-0 right-0 h-8 w-8 rounded-full bg-emerald-500 hover:bg-emerald-600 text-white"
                  >
                    <Camera className="h-4 w-4" />
                  </Button>
                </div>
                <div className="text-center sm:text-left">
                  <CardTitle className="text-2xl text-white">{name}</CardTitle>
                  <CardDescription className="text-slate-400">
                    {email}
                  </CardDescription>
                </div>
              </div>
            </CardHeader>

            <Tabs defaultValue="profile" className="w-full">
              <TabsList className="grid grid-cols-2 mx-4 bg-slate-700">
                <TabsTrigger
                  value="profile"
                  className="data-[state=active]:bg-slate-600"
                >
                  Profile
                </TabsTrigger>
                <TabsTrigger
                  value="security"
                  className="data-[state=active]:bg-slate-600"
                >
                  Security
                </TabsTrigger>
              </TabsList>

              <TabsContent value="profile" className="p-0">
                <CardContent className="p-6">
                  {isEditing ? (
                    <form className="space-y-4">
                      <div className="space-y-2">
                        <Label htmlFor="name" className="text-slate-200">
                          Full Name
                        </Label>
                        <Input
                          id="name"
                          value={name}
                          onChange={(e) => setName(e.target.value)}
                          className="bg-slate-900/50 border-slate-700 text-slate-200"
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor="email" className="text-slate-200">
                          Email
                        </Label>
                        <Input
                          id="email"
                          type="email"
                          value={email}
                          onChange={(e) => setEmail(e.target.value)}
                          className="bg-slate-900/50 border-slate-700 text-slate-200"
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor="bio" className="text-slate-200">
                          Bio
                        </Label>
                        <textarea
                          id="bio"
                          value={bio}
                          onChange={(e) => setBio(e.target.value)}
                          rows={4}
                          className="w-full rounded-md bg-slate-900/50 border border-slate-700 text-slate-200 p-2"
                        />
                      </div>
                    </form>
                  ) : (
                    <div className="space-y-4">
                      <div>
                        <h3 className="text-sm font-medium text-slate-400 mb-1">
                          Full Name
                        </h3>
                        <p className="text-white">{name}</p>
                      </div>

                      <div>
                        <h3 className="text-sm font-medium text-slate-400 mb-1">
                          Email
                        </h3>
                        <p className="text-white">{email}</p>
                      </div>

                      <div>
                        <h3 className="text-sm font-medium text-slate-400 mb-1">
                          Bio
                        </h3>
                        <p className="text-white">{bio}</p>
                      </div>
                    </div>
                  )}
                </CardContent>

                <CardFooter className="flex justify-end gap-2 p-6 pt-0">
                  {isEditing ? (
                    <>
                      <Button
                        variant="outline"
                        className="border-slate-600 text-slate-200 hover:bg-slate-700"
                        onClick={() => setIsEditing(false)}
                        disabled={isSaving}
                      >
                        Cancel
                      </Button>
                      <Button
                        className="bg-emerald-500 hover:bg-emerald-600 text-white"
                        onClick={handleSave}
                        disabled={isSaving}
                      >
                        {isSaving ? "Saving..." : "Save Changes"}
                      </Button>
                    </>
                  ) : (
                    <Button
                      className="bg-emerald-500 hover:bg-emerald-600 text-white"
                      onClick={() => setIsEditing(true)}
                    >
                      Edit Profile
                    </Button>
                  )}
                </CardFooter>
              </TabsContent>

              <TabsContent value="security" className="p-0">
                <CardContent className="p-6 space-y-6">
                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">Password</h3>
                    <Button
                      variant="outline"
                      className="border-slate-600 text-slate-200 hover:bg-slate-700"
                    >
                      Change Password
                    </Button>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">
                      Two-Factor Authentication
                    </h3>
                    <div className="flex items-center justify-between">
                      <div>
                        <p className="text-slate-200">
                          Protect your account with 2FA
                        </p>
                        <p className="text-sm text-slate-400">
                          Add an extra layer of security
                        </p>
                      </div>
                      <Switch />
                    </div>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">
                      Session Management
                    </h3>
                    <Button
                      variant="outline"
                      className="border-slate-600 text-slate-200 hover:bg-slate-700"
                    >
                      Sign Out All Devices
                    </Button>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-medium text-white">
                      Account Deletion
                    </h3>
                    <Button
                      variant="destructive"
                      className="bg-red-900/20 hover:bg-red-900/40 text-red-400"
                    >
                      Delete Account
                    </Button>
                  </div>
                </CardContent>
              </TabsContent>
            </Tabs>
          </Card>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/SettingsPage.jsx
================
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  ArrowLeft,
  Bell,
  Globe,
  Lock,
  Moon,
  Shield,
  Sun,
  Volume2,
} from "lucide-react";
// eslint-disable-next-line
import { motion } from "framer-motion";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";

export default function SettingsPage() {
  const [darkMode, setDarkMode] = useState(true);
  const [notifications, setNotifications] = useState(true);
  const [sounds, setSounds] = useState(true);
  const [readReceipts, setReadReceipts] = useState(true);
  const [language, setLanguage] = useState("english");
  const [volume, setVolume] = useState([70]);

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/chat"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Chat
        </Link>
      </header>

      <main className="flex-1 container mx-auto px-4 py-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="max-w-2xl mx-auto"
        >
          <h1 className="text-3xl font-bold text-white mb-6">Settings</h1>

          <div className="space-y-6">
            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Sun className="h-5 w-5 text-emerald-400" />
                  Appearance
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Customize how SecureChat looks
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Dark Mode</Label>
                    <p className="text-sm text-slate-400">
                      Toggle between light and dark themes
                    </p>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Sun className="h-4 w-4 text-slate-400" />
                    <Switch checked={darkMode} onCheckedChange={setDarkMode} />
                    <Moon className="h-4 w-4 text-slate-400" />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label className="text-slate-200">Language</Label>
                  <Select value={language} onValueChange={setLanguage}>
                    <SelectTrigger className="bg-slate-900/50 border-slate-700 text-slate-200">
                      <SelectValue placeholder="Select language" />
                    </SelectTrigger>
                    <SelectContent className="bg-slate-800 border-slate-700 text-slate-200">
                      <SelectItem value="english">English</SelectItem>
                      <SelectItem value="spanish">Spanish</SelectItem>
                      <SelectItem value="french">French</SelectItem>
                      <SelectItem value="german">German</SelectItem>
                      <SelectItem value="japanese">Japanese</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </CardContent>
            </Card>

            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Bell className="h-5 w-5 text-emerald-400" />
                  Notifications
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Manage how you receive notifications
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Push Notifications</Label>
                    <p className="text-sm text-slate-400">
                      Receive notifications when you're not active
                    </p>
                  </div>
                  <Switch
                    checked={notifications}
                    onCheckedChange={setNotifications}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Sound Effects</Label>
                    <p className="text-sm text-slate-400">
                      Play sounds for new messages and calls
                    </p>
                  </div>
                  <Switch checked={sounds} onCheckedChange={setSounds} />
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <Label className="text-slate-200">
                      Notification Volume
                    </Label>
                    <span className="text-sm text-slate-400">{volume[0]}%</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <Volume2 className="h-4 w-4 text-slate-400" />
                    <Slider
                      value={volume}
                      onValueChange={setVolume}
                      max={100}
                      step={1}
                      className="flex-1"
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Shield className="h-5 w-5 text-emerald-400" />
                  Privacy & Security
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Manage your privacy and security settings
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label className="text-slate-200">Read Receipts</Label>
                    <p className="text-sm text-slate-400">
                      Let others know when you've read their messages
                    </p>
                  </div>
                  <Switch
                    checked={readReceipts}
                    onCheckedChange={setReadReceipts}
                  />
                </div>

                <div className="space-y-0.5">
                  <Label className="text-slate-200">Encryption Key</Label>
                  <div className="flex items-center gap-2">
                    <div className="bg-slate-900/50 border border-slate-700 rounded-md p-2 text-slate-400 text-sm font-mono flex-1 truncate">
                      a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      className="border-slate-600 text-slate-200 hover:bg-slate-700"
                    >
                      Rotate
                    </Button>
                  </div>
                  <p className="text-xs text-slate-400 mt-1">
                    Your encryption key is stored locally and never sent to our
                    servers
                  </p>
                </div>

                <Button
                  variant="outline"
                  className="w-full border-slate-600 text-slate-200 hover:bg-slate-700"
                >
                  <Lock className="mr-2 h-4 w-4" />
                  Advanced Security Settings
                </Button>
              </CardContent>
            </Card>

            <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white flex items-center gap-2">
                  <Globe className="h-5 w-5 text-emerald-400" />
                  About
                </CardTitle>
                <CardDescription className="text-slate-400">
                  Information about SecureChat
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-1">
                    Version
                  </h3>
                  <p className="text-white">1.0.0</p>
                </div>

                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-1">
                    Terms of Service
                  </h3>
                  <Link
                    to="/terms"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Read our Terms of Service
                  </Link>
                </div>

                <div>
                  <h3 className="text-sm font-medium text-slate-400 mb-1">
                    Privacy Policy
                  </h3>
                  <Link
                    to="/privacy"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Read our Privacy Policy
                  </Link>
                </div>
              </CardContent>
            </Card>
          </div>
        </motion.div>
      </main>
    </div>
  );
}

================
File: src/pages/SignupPage.jsx
================
import { useState } from "react";
import { useNavigate, Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { AlertCircle, ArrowLeft, Lock, Shield } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { supabase } from "../lib/supabaseClient";

export default function SignupPage() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");

    if (!name || !email || !password || !confirmPassword) {
      setError("All fields are required");
      return;
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    if (password.length < 8) {
      setError("Password must be at least 8 characters long");
      return;
    }

    setIsLoading(true);

    try {
      const { data: signUpData, error: signUpError } =
        await supabase.auth.signUp({
          email: email,
          password: password,
        });

      if (signUpError) {
        if (signUpError.message.includes("User already registered")) {
          setError("This email is already registered. Please try logging in.");
        } else {
          setError(signUpError.message);
        }
        setIsLoading(false);
        return;
      }

      if (!signUpData.user) {
        throw new Error("Signup process did not return user data.");
      }

      const newUser = signUpData.user;
      console.log("Signup successful, user:", newUser);

      console.log(`Upserting profile for user ${newUser.id}...`);
      const { error: profileError } = await supabase.from("profiles").upsert(
        {
          id: newUser.id,
          full_name: name,
          username: email,
        },
        { onConflict: "id" }
      );

      if (profileError) {
        console.error("Error upserting profile:", profileError);
        throw new Error(
          `Failed to create/update user profile: ${profileError.message}`
        );
      }
      console.log(`Profile upserted successfully for user ${newUser.id}.`);

      console.log(`Checking for existing key bundle for user ${newUser.id}...`);
      const { data: existingKeys, error: keyCheckError } = await supabase
        .from("prekey_bundles")
        .select("user_id")
        .eq("user_id", newUser.id)
        .maybeSingle();

      if (keyCheckError) {
        console.error("Error checking for existing keys:", keyCheckError);
        throw new Error(
          `Failed to check for existing encryption keys: ${keyCheckError.message}`
        );
      }

      if (!existingKeys) {
        console.log(
          `No existing keys found. User ${newUser.id} will register keys via SignalProvider on chat page load.`
        );

        // Check if user needs email confirmation
        if (
          signUpData.session &&
          signUpData.session.user.email_confirmed_at === null
        ) {
          setError(
            "Account created! Please check your email to confirm your account before logging in."
          );
          // Optionally sign the user out until confirmed
          // await supabase.auth.signOut();
        } else if (signUpData.user) {
          // User might be auto-confirmed or already confirmed
          console.log("Navigating to chat...");
          navigate("/chat");
        } else {
          // Should not happen if signup succeeded, but handle defensively
          setError(
            "Signup seems complete, but login state is unclear. Please try logging in or check your email."
          );
        }
      } else {
        // This block handles the case where keys *already* exist
        console.log(
          `Encryption keys already exist for user ${newUser.id}. Skipping generation.`
        );
        // If keys exist, the user should be okay to proceed
        console.log("Existing keys found. Navigating to chat...");
        navigate("/chat");
      }
    } catch (err) {
      // This outer catch handles errors from Supabase signup or profile upsert primarily
      console.error("Error during sign up process (before key gen):", err);
      if (!error) {
        // Avoid overwriting specific errors like 'email exists'
        setError(`Signup failed: ${err.message || "Please try again."}`);
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 flex flex-col">
      <header className="container mx-auto p-4">
        <Link
          to="/"
          className="inline-flex items-center text-slate-300 hover:text-white"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Home
        </Link>
      </header>

      <main className="flex-1 flex items-center justify-center p-4">
        <div className="w-full max-w-md">
          <Card className="border-slate-700 bg-slate-800/50 backdrop-blur-sm">
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-2">
                <div className="relative">
                  <Lock className="h-8 w-8 text-emerald-400" />
                  <div className="absolute -top-1 -right-1 bg-emerald-400 rounded-full p-1">
                    <Shield className="h-3 w-3 text-slate-900" />
                  </div>
                </div>
              </div>
              <CardTitle className="text-2xl text-center text-white">
                Create an account
              </CardTitle>
              <CardDescription className="text-center text-slate-400">
                Enter your details to get started with SecureChat
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <Alert
                  variant="destructive"
                  className="mb-4 bg-red-900/20 border-red-800 text-red-300"
                >
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              <form onSubmit={handleSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="name" className="text-slate-200">
                    Full Name
                  </Label>
                  <Input
                    id="name"
                    placeholder="John Doe"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="email" className="text-slate-200">
                    Email
                  </Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="name@example.com"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="password" className="text-slate-200">
                    Password
                  </Label>
                  <Input
                    id="password"
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="confirmPassword" className="text-slate-200">
                    Confirm Password
                  </Label>
                  <Input
                    id="confirmPassword"
                    type="password"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    className="bg-slate-900/50 border-slate-700 text-slate-200"
                  />
                </div>

                <div className="text-xs text-slate-400">
                  By creating an account, you agree to our{" "}
                  <Link
                    to="/terms"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Terms of Service
                  </Link>{" "}
                  and{" "}
                  <Link
                    to="/privacy"
                    className="text-emerald-400 hover:text-emerald-300"
                  >
                    Privacy Policy
                  </Link>
                </div>

                <Button
                  type="submit"
                  className="w-full bg-emerald-500 hover:bg-emerald-600 text-white"
                  disabled={isLoading}
                >
                  {isLoading ? "Creating account..." : "Create account"}
                </Button>
              </form>
            </CardContent>
            <CardFooter className="flex justify-center">
              <p className="text-sm text-slate-400">
                Already have an account?{" "}
                <Link
                  to="/login"
                  className="text-emerald-400 hover:text-emerald-300"
                >
                  Sign in
                </Link>
              </p>
            </CardFooter>
          </Card>
        </div>
      </main>
    </div>
  );
}

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    // ...
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
    // ...
  }
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

================
File: vite.config.js
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "path";
import { fileURLToPath } from "url";

// Get the directory name in an ES module context
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
